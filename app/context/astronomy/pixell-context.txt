# \- pixell | Complete Documentation -

## index

# Welcome to pixell’s documentation!

# Contents:

  * [Usage](usage.md)
  * [The `ndmap` object](usage.md#the-ndmap-object)
  * [Creating an `ndmap`](usage.md#creating-an-ndmap)
  * [Passing maps through functions that act on `numpy` arrays](usage.md#passing-maps-through-functions-that-act-on-numpy-arrays)
  * [Reading maps from disk](usage.md#reading-maps-from-disk)
  * [Inspecting a map](usage.md#inspecting-a-map)
  * [Selecting regions of the sky](usage.md#selecting-regions-of-the-sky)
  * [Relating pixels to the sky](usage.md#relating-pixels-to-the-sky)
  * [Fourier operations](usage.md#fourier-operations)
  * [Filtering maps in Fourier space](usage.md#filtering-maps-in-fourier-space)
  * [Building a map geometry](usage.md#building-a-map-geometry)
  * [Resampling maps](usage.md#resampling-maps)
  * [Masking and windowing](usage.md#masking-and-windowing)
  * [Flat-sky diagnostic power spectra](usage.md#flat-sky-diagnostic-power-spectra)
  * [Curved-sky operations](usage.md#curved-sky-operations)
  * [Reprojecting maps](usage.md#reprojecting-maps)
  * [Simulating maps](usage.md#simulating-maps)
  * [Reference](reference.md)
  * [enmap - General map manipulation](reference.md#module-pixell.enmap)
  * [fft - Fourier transforms](reference.md#module-pixell.fft)
  * [curvedsky - Curved-sky harmonic transforms](reference.md#module-pixell.curvedsky)
  * [utils - General utilities](reference.md#module-pixell.utils)
  * [reproject - Map reprojection](reference.md#module-pixell.reproject)
  * [resample - Map resampling](reference.md#module-pixell.resample)
  * [lensing - Lensing](reference.md#module-pixell.lensing)
  * [pointsrcs - Point Sources](reference.md#module-pixell.pointsrcs)
  * [interpol - Interpolation](reference.md#module-pixell.interpol)
  * [coordinates - Coordinate Transformation](reference.md#module-pixell.coordinates)
  * [wcsutils - World Coordinate Sytem utilities](reference.md#module-pixell.wcsutils)
  * [powspec - CMB power spectra utilities](reference.md#module-pixell.powspec)
  * [enplot - Producing plots from ndmaps](reference.md#module-pixell.enplot)
  * [tilemap - Tiled maps where only some tiles are stored](reference.md#module-pixell.tilemap)

# Indices and tables

  * [Index](genindex.md)
  * [Module Index](py-modindex.md)
  * [Search Page](search.md)

* * *

## readme

* * *

## usage

# Usage

## The `ndmap` object

The `pixell` library supports manipulation of sky maps that are represented as
2-dimensional grids of rectangular pixels. The supported projection and
pixelization schemes are a subset of the schemes supported by FITS
conventions. In addition, we provide support for a

```

plain’ coordinate system, corresponding to a Cartesian plane with identically
shaped pixels (useful for true flat-sky calculations).

In `pixell`, a map is encapsulated in an `ndmap`, which combines two objects:
a numpy array (of at least two dimensions) whose two trailing dimensions
correspond to two coordinate axes of the map, and a `wcs` object that
specifies the World Coordinate System. The `wcs` component is an instance of
Astropy’s `astropy.wcs.wcs.WCS` class. The combination of the `wcs` and the
`shape` of the numpy array completely specifies the footprint of a map of the
sky, and is called the `geometry`. This library helps with manipulation of
`ndmap` objects in ways that are aware of and preserve the validity of the wcs
information.

### `ndmap` as an extension of `numpy.ndarray`

The `ndmap` class extends the `numpy.ndarray` class, and thus has all of the
usual attributes (`.shape`, `.dtype`, etc.) of an `ndarray`. It is likely that
an `ndmap` object can be used in any functions that usually operate on an
`ndarray`; this includes the usual numpy array arithmetic, slicing,
broadcasting, etc.

```python

> > > from pixell import enmap
>>>

>>> # ... code that resulted in an ndmap called imap

>>>

>>> print(imap.shape, imap.wcs) (100, 100)
:{cdelt:[1,1],crval:[0,0],crpix:[0,0]} imap_extract = imap[:50,:50] # A view
of one corner of the map. imap_extract *= 1e6 # Re-calibrate. (Also affects
imap!) ```

An `ndmap` must have at least two dimensions. The two right-most axes
represent celestial coordinates (typically Declination and Right Ascension).
Maps can have arbitrary number of leading dimensions, but many of the `pixell`
CMB-related tools interpret 3D arrays with shape `(ncomp,Ny,Nx)` as
representing `Ny` x `Nx` maps of intensity, polarization Q and U Stokes
parameters, in that order.

Note that `wcs` information is correctly adjusted when the array is sliced;
for example the object returned by `imap[:50,:50]` is a view into the `imap`
data attached to a new `wcs` object that correctly describes the footprint of
the extracted pixels.

Apart from all the numpy functionality, `ndmap` comes with a host of
additional attributes and functions that utilize the WCS information.

### `ndmap.wcs`

The `wcs` information describes the correspondence between celestial
coordinates (typically the Right Ascension and Declination in the Equatorial
system) and the pixel indices in the two right-most axes. In some projections,
such as CEA or CAR, rows (and columns) of the pixel grid will often follow
lines of constant Declination (and Right Ascension). In other projections,
this will not be the case.

The WCS system is very flexible in how celestial coordinates may be associated
with the pixel array. By observing certain conventions, we can make life
easier for users of our maps. We recommend the following:

  * The first pixel, index [0,0], should be the one that you would normally display (on a monitor or printed figure) in the lower left-hand corner of the image. The pixel indexed by [0,1] should appear to the right of [0,0], and pixel [1,0] should be above pixel [0,0]. (This recommendation originates in FITS standards documentation.)
  * When working with large maps that are not near the celestial poles, Right Ascension should be roughly horizontal and Declination should be roughly vertical. (It should go without saying that you should also present information “as it would appear on the sky”, i.e. with Right Ascension increasing to the left!)

The examples in the rest of this document are designed to respect these two
conventions.

TODO: I’ve listed below common operations that would be useful to demonstrate
here. Finish this! (See [2 Reference](reference.md#referencepage) for a dump
of all member functions)

## Creating an `ndmap`

To create an empty `ndmap`, call the `enmap.zeros` or `enmap.empty` functions
and specify the map shape as well as the pixelization information (the WCS).
Here is a basic example:

```python

> > > from pixell import enmap, utils box = np.array([[-5,10],[5,-10]]) *
> utils.degree shape,wcs = enmap.geometry(pos=box,res=0.5 *
> utils.arcmin,proj='car') imap = enmap.zeros((3,) + shape, wcs=wcs) ```

In this example we are requesting a pixelization that spans from -5 to +5 in
declination, and +10 to -10 in Right Ascension. Note that we need to specify
the Right Ascension coordinates in decreasing order, or the map, when we
display it with pixel [0,0] in the lower left-hand corner, will not have the
usual astronomical orientation.

For more information on designing the geometry, see 1.10 Building a map
geometry.

## Passing maps through functions that act on `numpy` arrays

You can also perform arithmetic with and use functions that act on numpy
arrays. In most situations, functions that usually act on numpy arrays will
return an `ndmap` when an `ndmap` is passed to it in lieu of a numpy array. In
those situations where the WCS information is removed, one can always add it
back like this:

```python

> > > from pixell import enmap
>>>

>>> # ... code that resulted in an ndmap called imap

>>>

>>> print(imap.shape, imap.wcs) (100, 100)
:{cdelt:[1,1],crval:[0,0],crpix:[0,0]} omap = some_function(imap)
print(omap.wcs) Traceback (most recent call last): AttributeError:
'numpy.ndarray' object has no attribute 'wcs'

>>>

>>> # Uh oh, the WCS information was removed by some_function

>>>

>>> omap = enmap.ndmap(omap, wcs) # restore the wcs omap = enmap.samewcs(omap,
imap) # another way to restore the wcs

>>>

>>> # This does the same thing, but force-copies the data array.

>>>

>>> omap = enmap.enmap(omap, wcs) ```

Note that `ndmap` and `samewcs` will not copy the underlying data array if
they don’t have to; the returned object will reference the same memory used by
the input array (as though you had done numpy.asarray). In contrast,
`enmap.enmap` will always create a copy of the input data.

## Reading maps from disk

An entire map in `FITS` or `HDF` format can be loaded using `read_map`, which
is found in the module `pixell.enmap`. The `enmap` module contains the
majority of map manipulation functions.

```python

> > > from pixell import enmap imap = enmap.read_map("map_on_disk.fits") ```

Alternatively, one can select a rectangular region specified through its
bounds using the `box` argument,

```python

> > > import numpy as np from pixell import utils dec_min = -5 ; ra_min = -5 ;
> dec_max = 5 ; ra_max = 5
>>>

>>> # All coordinates in pixell are specified in radians

>>>

>>> box = np.array([[dec_min,ra_min],[dec_max,ra_max])) * utils.degree imap =
enmap.read_map("map_on_disk.fits",box=box) ```

Note the convention used to define coordinate boxes in pixell. To learn how to
use a pixel coordinate box or a numpy slice, please read the docstring for
`read_map`.

## Inspecting a map

An `ndmap` has all the attributes of a `ndarray` numpy array. In particular,
you can inspect its shape.

```python

> > > print(imap.shape) (3,500,1000) ```

Here, `imap` consists of three maps each with 500 pixels along the Y axis and
1000 pixels along the X axis. One can also inspect the WCS of the map,

```python

> > > print(imap.wcs)
> car:{cdelt:[0.03333,0.03333],crval:[0,0],crpix:[500.5,250.5]} ```

Above, we learn that the map is represented in the `CAR` projection system and
what the WCS attributes are.

## Selecting regions of the sky

If you know the pixel coordinates of the sub-region you would like to select,
the cleanest thing to do is to slice it like a numpy array.

```python

> > > imap = enmap.zeros((1000,1000)) print(imap.shape) (1000,1000) omap =
> imap[100:200,50:80] print(omap.shape) (100, 30) ```

However, if you only know the physical coordinate bounding box in radians, you
can use the `submap` function.

```python

> > > box = np.array([[dec_min,ra_min],[dec_max,ra_max]]) # in radians omap =
> imap.submap(box) omap = enmap.submap(imap,box) # an alternative way ```

## Relating pixels to the sky

The geometry specified through `shape` and `wcs` contains all the information
to get properties of the map related to the sky. `pixell` always specifies the
Y coordinate first. So a sky position is often in the form `(dec,ra)` where
`dec` could be the declination and `ra` could be the right ascension in
radians in the equatorial coordinate system.

The pixel corresponding to ra=180,dec=20 can be obtained like

```python

> > > dec = 20 ; ra = 180 coords = np.deg2rad(np.array((dec,ra))) ypix,xpix =
> enmap.sky2pix(shape,wcs,coords) ```

Note that you don’t need to pass each dec,ra separately. You can pass a large
number of coordinates for a vectorized conversion. In this case coords should
have the shape (2,Ncoords), where Ncoords is the number of coordinates you
want to convert, with the first row containing declination and the second row
containing right ascension. Also, the returned pixel coordinates are in
general fractional.

Similarly, pixel coordinates can be converted to sky coordinates

```python

> > > ypix = 100 ; xpix = 300 pixes = np.array((ypix,xpix)) dec,ra =
> enmap.pix2sky(shape,wcs,pixes) ```

with similar considerations as above for passing a large number of
coordinates.

Using the `enmap.posmap` function, you can get a map of shape (2,Ny,Nx)
containing the coordinate positions in radians of each pixel of the map.

```python

> > > posmap = imap.posmap() dec = posmap[0] # declination in radians ra =
> posmap[1] # right ascension in radians ```

Using the `enmap.pixmap` function, you can get a map of shape (2,Ny,Nx)
containing the integer pixel coordinates of each pixel of the map.

```python

> > > pixmap = imap.pixmap() pixy = posmap[0] pixx = posmap[1] ```

Using the `enmap.modrmap` function, you can get a map of shape (Ny,Nx)
containing the physical coordinate distance of each pixel from a given
reference point specified in radians. If the reference point is unspecified,
the distance of each pixel from the center of the map is returned.

```python

> > > modrmap = imap.modrmap() # 2D map of distances from center ```

## Fourier operations

Maps can be 2D Fourier-transformed for manipulation in Fourier space. The 2DFT
of the (real) map is generally a complex `ndmap` with the same shape as the
original map (unless a real transform function is used). To facilitate 2DFTs,
there are functions that do the Fourier transforms themselves, and functions
that provide metadata associated with such transforms.

Since an ndmap contains information about the physical extent of the map and
the physical width of the pixels, the discrete frequencies corresponding to
its numpy array need to be converted to physical wavenumbers of the map.

This is done by the `laxes` function, which returns the wavenumbers along the
Y and X directions. The `lmap` function returns a map of all the `(ly,lx)`
wavenumbers in each pixel of the Fourier-space map. The `modlmap` function
returns the “modulus of lmap”, i.e. a map of the distances of each Fourier-
pixel from `(ly=0,lx=0)`.

You can perform a fast Fourier transform of an (…,Ny,Nx) dimensional ndmap to
return an (…,Ny,Nx) dimensional complex map using `enmap.fft` and `enmap.ifft`
(inverse FFT).

## Filtering maps in Fourier space

A filter can be applied to a map in three steps:

  1. prepare a Fourier space filter `kfilter`
  2. Fourier transform the map `imap` to `kmap`
  3. multiply the filter and k-map
  4. inverse Fourier transform the result

## Building a map geometry

You can create a geometry if you know what its bounding box and pixel size
are:

```python

> > > from pixell import enmap, utils box = np.array([[-5,10],[5,-10]]) *
> utils.degree shape,wcs = enmap.geometry(pos=box,res=0.5 *
> utils.arcmin,proj='car') ```

This creates a CAR geometry centered on RA=0d,DEC=0d with a width of 20
degrees, a height of 10 degrees, and a pixel size of 0.5 arcminutes.

You can create a full-sky geometry by just specifying the resolution:

```python

> > > from pixell import enmap, utils shape,wcs =
> enmap.fullsky_geometry(res=0.5 * utils.arcmin,proj='car') ```

This creates a CAR geometry with pixel size of 0.5 arcminutes that wraps
around the whole sky.

You can create a geometry that wraps around the full sky but does not extend
everywhere in declination:

```python

> > > shape,wcs = enmap.band_geometry(dec_cut=20*utils.degree, res=0.5 *
> utils.arcmin,proj='car') ```

This creates a CAR geometry with pixel size of 0.5 arcminutes that wraps
around the whole sky but is limited to DEC=-20d to 20d. The following creates
the same except with a declination extent from -60d to 30d.

```python

> > > shape,wcs = enmap.band_geometry(dec_cut=np.array([-60,30])*utils.degree,
> res=0.5 * utils.arcmin,proj='car') ```

## Resampling maps

## Masking and windowing

## Flat-sky diagnostic power spectra

## Curved-sky operations

The resulting spherical harmonic alm coefficients of an SHT are stored in the
same convention as with `HEALPIX`, so one can use `healpy.almxfl` to apply an
isotropic filter to an SHT.

## Reprojecting maps

## Simulating maps

* * *

## reference

# Reference

See [1 Usage](usage.md#usagepage) for how to use these functions for common
map manipulation tasks.

## enmap - General map manipulation

### _class_ pixell.enmap.ndmap(arr, wcs)

Implements (stacks of) flat, rectangular, 2-dimensional maps as a dense numpy
array with a fits WCS. The axes have the reverse ordering as in the fits file,
and hence the WCS object. This class is usually constructed by using one of
the functions following it, much like numpy arrays. We assume that the WCS
only has two axes with unit degrees. The ndmap itself uses radians for
everything.

#### copy(order='C')

Return a copy of the array.

  * **Parameters:** **order** ( _{'C'_ _,_ _'F'_ _,_ _'A'_ _,_ _'K'}_ _,_ _optional_) – Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and `numpy.copy()` are very similar but have different default values for their order= arguments, and this function always passes sub-classes through.)

#### SEE ALSO

`numpy.copy` : Similar function with different default behavior

`numpy.copyto`

### Notes

This function is the preferred method for creating an array copy. The function
`numpy.copy()` is similar, but it defaults to using order ‘K’, and will not
pass sub-classes through by default.

### Examples

```pycon

> > > import numpy as np x = np.array([[1,2,3],[4,5,6]], order='F') ```

```pycon

> > > y = x.copy() ```

```pycon

> > > x.fill(0) ```

```pycon

> > > x array([[0, 0, 0], [0, 0, 0]]) ```

```pycon

> > > y array([[1, 2, 3], [4, 5, 6]]) ```

```pycon

> > > y.flags['C_CONTIGUOUS'] True ```

For arrays containing Python objects (e.g. dtype=object), the copy is a
shallow one. The new array will contain the same object which may lead to
surprises if that object can be modified (is mutable):

```pycon

> > > a = np.array([1, 'm', [2, 3, 4]], dtype=object) b = a.copy() b[2][0] =
> 10 a array([1, 'm', list([10, 3, 4])], dtype=object) ```

To ensure all elements within an `object` array are copied, use copy.deepcopy:

```pycon

> > > import copy a = np.array([1, 'm', [2, 3, 4]], dtype=object) c =
> copy.deepcopy(a) c[2][0] = 10 c array([1, 'm', list([10, 3, 4])],
> dtype=object) a array([1, 'm', list([2, 3, 4])], dtype=object) ```

#### sky2pix(coords, safe=True, corner=False)

#### pix2sky(pix, safe=True, corner=False)

#### l2pix(ls)

#### pix2l(pix)

#### contains(pos, unit='coord')

#### corners(npoint=10, corner=True)

#### box(npoint=10, corner=True)

#### pixbox_of(oshape, owcs)

#### posmap(safe=True, corner=False, separable='auto', dtype=)

#### posaxes(safe=True, corner=False, dtype=)

#### pixmap()

#### laxes(oversample=1, method='auto', broadcastable=False)

#### lmap(oversample=1)

#### lform(method='auto')

#### modlmap(oversample=1, min=0)

#### modrmap(ref='center', safe=True, corner=False)

#### lbin(bsize=None, brel=1.0, return_nhit=False, return_bins=False,
lop=None)

#### rbin(center=[0, 0], bsize=None, brel=1.0, return_nhit=False,
return_bins=False, rop=None)

#### area()

#### pixsize()

#### pixshape(signed=False)

#### pixsizemap(separable='auto', broadcastable=False)

#### pixshapemap(separable='auto', signed=False)

#### lpixsize(signed=False, method='auto')

#### lpixshape(signed=False, method='auto')

#### extent(method='auto', signed=False)

#### _property_ preflat

Returns a view of the map with the non-pixel dimensions flattened.

#### _property_ npix

#### _property_ geometry

#### resample(oshape, off=(0, 0), method='fft', border='wrap', corner=True,
order=3)

#### project(shape, wcs, mode='spline', order=3, border='constant', cval=0,
safe=True)

#### extract(shape, wcs, omap=None, wrap='auto', op=>, cval=0, iwcs=None,
reverse=False)

#### extract_pixbox(pixbox, omap=None, wrap='auto', op=>, cval=0, iwcs=None,
reverse=False)

#### insert(imap, wrap='auto', op=>, cval=0, iwcs=None)

#### insert_at(pix, imap, wrap='auto', op=>, cval=0, iwcs=None)

#### at(pos, mode='spline', order=3, border='constant', cval=0.0,
unit='coord', safe=True, ip=None)

#### argmax(axis=None, out=None, , keepdims=False)

Return indices of the maximum values along the given axis.

Refer to numpy.argmax for full documentation.

#### SEE ALSO

`numpy.argmax` : equivalent function

#### autocrop(method='plain', value='auto', margin=0, factors=None,
return_info=False)

#### apod(width, profile='cos', fill='zero')

#### stamps(pos, shape, aslist=False)

#### distance_from(points, omap=None, odomains=None, domains=False,
method='cellgrid', rmax=None, step=1024)

#### distance_transform(omap=None, rmax=None, method='cellgrid')

#### labeled_distance_transform(omap=None, odomains=None, rmax=None,
method='cellgrid')

#### _property_ plain

#### padslice(box, default=nan)

#### center()

#### downgrade(factor, op=, ref=None, off=None)

#### upgrade(factor, off=None, oshape=None, inclusive=False)

#### fillbad(val=0, inplace=False)

#### to_healpix(nside=0, order=3, omap=None, chunk=100000,
destroy_input=False)

#### to_flipper(omap=None, unpack=True)

#### submap(box, mode=None, wrap='auto', recenter=False)

Extract the part of the map inside the given coordinate box box : array_like

> The [[fromy,fromx],[toy,tox]] coordinate box to select. The resulting map
> will have bottom-left and top-right corners as close as possible to this,
> but will differ slightly due to the finite pixel size.

mode : How to handle partially selected pixels: : “round”: round bounds using
standard rules “floor”: both upper and lower bounds will be rounded down
“ceil”: both upper and lower bounds will be rounded up “inclusive”: lower
bounds are rounded down, and upper bounds up “exclusive”: lower bounds are
rounded up, and upper bounds down

#### subinds(box, mode=None, cap=True)

#### write(fname, fmt=None)

### pixell.enmap.submap(map, box, mode=None, wrap='auto', recenter=False,
iwcs=None)

Extract the part of the map inside the given coordinate box box : array_like

> The [[fromy,fromx],[toy,tox]] coordinate box to select. The resulting map
> will have corners as close as possible to this, but will differ slightly due
> to the finite pixel size.

mode : How to handle partially selected pixels: : “round”: round bounds using
standard rules “floor”: both upper and lower bounds will be rounded down
“ceil”: both upper and lower bounds will be rounded up “inclusive”: lower
bounds are rounded down, and upper bounds up “exclusive”: lower bounds are
rounded up, and upper bounds down  
The iwcs argument allows the wcs to be overriden. This is usually not
necessary.

### pixell.enmap.subgeo(shape, wcs, box=None, pixbox=None, mode=None,
wrap='auto', noflip=False, recenter=False)

Extract the part of the geometry inside the coordinate box box : array_like

> The [[fromy,fromx],[toy,tox]] coordinate box to select. The resulting map
> will have corners as close as possible to this, but will differ slightly due
> to the finite pixel size.

mode : How to handle partially selected pixels: : “round”: round bounds using
standard rules “floor”: both upper and lower bounds will be rounded down
“ceil”: both upper and lower bounds will be rounded up “inclusive”: lower
bounds are rounded down, and upper bounds up “exclusive”: lower bounds are
rounded up, and upper bounds down

### pixell.enmap.subinds(shape, wcs, box, mode=None, cap=True, noflip=False,
epsilon=0.0001)

Helper function for submap. Translates the coordinate box provided into a
pixel units.

When box is translated into pixels, the result will in general have fractional
pixels, which need to be rounded before we can do any slicing. To get as
robust results as possible, we want

>   1. two boxes that touch should results in iboxses that also touch. This
> means that upper and lower bounds must be handled consistently. inclusive
> and exclusive modes break this, and should be used with caution.
>   2. tiny floating point errors should not usually be able to cause the ibox
> to change. Most boxes will have some simple fraction of a whole degree, and
> most have pixels with centers or pixel edges at a simple fraction of a whole
> degree. mode=”floor” or “ceil” break when pixel centers are at whole values.
> mode=”round” breaks when pixel edges are at whole values. But since small
> (but not float-precision-size) offsets from these cases are unlikely, we can
> define safe rounding by adding an epsilon to the values before rounding. As
> long as this epsilon is use consistently, box overlap still works.
>

With epsilon in place, modes “round”, “floor” and “ceil” are all safe. We make
“round” the default.

### pixell.enmap.slice_geometry(shape, wcs, sel, nowrap=False)

Slice a geometry specified by shape and wcs according to the slice sel.
Returns a tuple of the output shape and the correponding wcs.

### pixell.enmap.scale_geometry(shape, wcs, scale)

Scale the geometry so that the number of pixels is scaled by the factor scale.

### pixell.enmap.get_unit(wcs)

### pixell.enmap.npix(shape)

### _class_ pixell.enmap.Geometry(shape, wcs=None)

#### _property_ npix

#### _property_ nopre

#### with_pre(pre)

#### submap(box=None, pixbox=None, mode=None, wrap='auto', noflip=False,
recenter=False)

#### scale(scale)

#### downgrade(factor, op=)

#### copy()

#### sky2pix(coords, safe=True, corner=False)

#### pix2sky(pix, safe=True, corner=False)

#### l2pix(ls)

#### pix2l(pix)

### pixell.enmap.corners(shape, wcs, npoint=10, corner=True)

Return the coordinates of the bottom left and top right corners of the
geometry given by shape, wcs.

If corner==True it is similar to
enmap.pix2sky([[-0.5,shape[-2]-0.5],[-0.5,shape[-1]-0.5]]). That is, it return
sthe coordinate of the bottom left corner of the bottom left pixel and the top
right corner of the top right pixel. If corner==False, then it instead returns
the corresponding pixel centers.

It differs from the simple pix2sky calls above by handling 2*pi wrapping
ambiguities differently. enmap.corners ensures that the coordinates returned
are on the same side of the wrapping cut so that the coordinates of the two
corners can be compared without worrying about wrapping. It does this by
evaluating a set of intermediate points between the corners and counting and
undoing any sudden jumps in coordinates it finds. This is controlled by the
npoint option. The default of 10 should be more than enough.

Returns [{bottom left,top right},{dec,ra}] in radians (or equivalent for other
coordinate systems). e.g. an array of the form [[dec_min, ra_min ], [dec_max,
ra_max]].

### pixell.enmap.box(shape, wcs, npoint=10, corner=True)

Alias for corners.

### pixell.enmap.enmap(arr, wcs=None, dtype=None, copy=True)

Construct an ndmap from data.

  * **Parameters:**
  * **arr** (_array_like_) – The data to initialize the map with. Must be at least two-dimensional.
  * **wcs** (_WCS object_)
  * **dtype** (_data-type_ _,_ _optional_) – The data type of the map. Default: Same as arr.
  * **copy** (_boolean_) – If true, arr is copied. Otherwise, a referance is kept.

### pixell.enmap.empty(shape, wcs=None, dtype=None)

Return an enmap with entries uninitialized (like numpy.empty).

### pixell.enmap.zeros(shape, wcs=None, dtype=None)

Return an enmap with entries initialized to zero (like numpy.zeros).

### pixell.enmap.ones(shape, wcs=None, dtype=None)

Return an enmap with entries initialized to one (like numpy.ones).

### pixell.enmap.full(shape, wcs, val, dtype=None)

Return an enmap with entries initialized to val (like numpy.full).

### pixell.enmap.posmap(shape, wcs, safe=True, corner=False, separable='auto',
dtype=, bsize=1000000.0, bcheck=False)

Return an enmap where each entry is the coordinate of that entry, such that
posmap(shape,wcs)[{0,1},j,k] is the {y,x}-coordinate of pixel (j,k) in the
map. Results are returned in radians, and if safe is true (default), then
sharp coordinate edges will be avoided. separable controls whether a fast
calculation that assumes that ra is only a function of x and dec is only a
function of y is used. The default is “auto”, which determines this based on
the wcs, but True or False can also be passed to control this manually.

For even greater speed, and to save memory, consider using posaxes directly
for cases where you know that the wcs will be separable. For separable cases,
separable=True is typically 15-20x faster than separable=False, while posaxes
is 1000x faster.

### pixell.enmap.posmap_old(shape, wcs, safe=True, corner=False)

### pixell.enmap.posaxes(shape, wcs, safe=True, corner=False, dtype=,
bcheck=False)

### pixell.enmap.pixmap(shape, wcs=None)

Return an enmap where each entry is the pixel coordinate of that entry.

### pixell.enmap.pix2sky(shape, wcs, pix, safe=True, corner=False,
bcheck=False)

Given an array of pixel coordinates [{y,x},…], return sky coordinates in the
same ordering.

### pixell.enmap.sky2pix(shape, wcs, coords, safe=True, corner=False,
bcheck=False)

Given an array of coordinates [{dec,ra},…], return pixel coordinates with the
same ordering. The corner argument specifies whether pixel coordinates start
at pixel corners or pixel centers. This represents a shift of half a pixel. If
corner is False, then the integer pixel closest to a position is
round(sky2pix(…)). Otherwise, it is floor(sky2pix(…)).

### pixell.enmap.pix2l(shape, wcs, pix)

Given an array of fourier-pixel coordinates [{y,x},…], returns the 2d fourier
coordinates [{ly,lx},…].

### pixell.enmap.l2pix(shape, wcs, ls)

Given an array of fourier-pixel coordinates [{y,x},…], returns the 2d fourier
coordinates [{ly,lx},…].

### pixell.enmap.skybox2pixbox(shape, wcs, skybox, npoint=10, corner=False,
include_direction=False)

Given a coordinate box [{from,to},{dec,ra}], compute a corresponding pixel box
[{from,to},{y,x}]. We avoid wrapping issues by evaluating a number of
subpoints.

### pixell.enmap.pixbox2skybox(shape, wcs, pixbox)

### pixell.enmap.contains(shape, wcs, pos, unit='coord')

For the points with coordinates pos[{dec,ra},…] return whether each is inside
the geometry given by shape, wcs

### pixell.enmap.project(map, shape, wcs, mode='spline', order=3,
border='constant', cval=0.0, force=False, safe=True, bsize=1000, context=50,
ip=None)

Project map to a new geometry.

This function is not suited for going down in resolution, because only
interpolation is done, not averaging. This means that if the output geometry
has lower resolution than the input, then information will be lost because
noise will not average down the way it optimally would.

  * map: enmap.ndmap of shape […,ny,nx]
  * shape, wcs: The geometry to project to
  * mode: The interpolation mode. Same meaning as in utils.interpol. Valid values are “nearest”, “linear”, “cubic”, “spline” and “fourier”. “nearest” and “linear” are local interpolations, where one does not need to worry about edge effects and ringing. “cubic” and especially “fourier” are sensitive to the boundary conditions, and maps may need to be apodized first. Only “fourier” interpolation preserves map power on all scales. The other types lose a bit of power at high multipoles. fourier > cubic > linear > nearest for high-l fidelity. “spline” is a generalization of “nearest”, “linear” and “cubic”, depending on the “order” argument: 0, 1 and 3.
  * order: Controls the “spline” mode. See above.
  * border: The boundary condition to assume for spline interpolation. Ignored for Fourier-interpolation, which always assumes periodic boundary conditions. Defaults to “constant”, where areas outside the map are assumed to have the constant value “cval”.
  * cval: See “border”.
  * force: Force interpolation, even when the input and output pixels are directly compatible, so no interpolation is necessary. Normally the faster enmap.extract is used in this case.
  * safe: If True (default) make extra effort to resolve 2pi sky wrapping degeneracies in the coordinate conversion.
  * bsize: The interpolation is done in blocks in the y axis to save memory. This argument controls how many rows are processed at once.
  * context: How much to pad each y block by. Used to avoid ringing due to discontinuities at block boundaries. Defaults to 50.
  * ip: An interpolator object as returned by utils.interpolator(). If provided, this interpolator is used directly, and the interpolation arguments (mode, order, border, cval) are ignored. If the interpolator does not count as “prefiltered” (meaning that each use of the interpolator could incurr a potentially large cost regardless of how few points are interpolated), then the whole map is processed in one go, ignoring bsize

### pixell.enmap.pixbox_of(iwcs, oshape, owcs)

Obtain the pixbox which when extracted from a map with WCS=iwcs returns a map
that has geometry oshape,owcs.

### pixell.enmap.extract(map, shape, wcs, omap=None, wrap='auto', op=>,
cval=0, iwcs=None, reverse=False)

Like project, but only works for pixel-compatible wcs. Much faster because it
simply copies over pixels.

Can be used in co-adding by specifying an output map and a combining
operation. The deafult operation overwrites the output. Use np.ndarray.__iadd_
_ to get a copy-less += operation. Not that areas outside are not assumed to
be zero if an omap is specified - instead those areas will simply not be
operated on.

The optional iwcs argument is there to support input maps that are numpy-like
but can’t be made into actual enmaps. The main example of this is a fits hdu
object, which can be sliced like an array to avoid reading more into memory
than necessary.

### pixell.enmap.extract_pixbox(map, pixbox, omap=None, wrap='auto', op=>,
cval=0, iwcs=None, reverse=False, recenter=False)

This function extracts a rectangular area from an enmap based on the given
pixbox[{from,to,[stride]},{y,x}]. The difference between this function and
plain slicing of the enmap is that this one supports wrapping around the sky.
This is necessary to make things like fast thumbnail or tile extraction at the
edge of a (horizontally) fullsky map work.

### pixell.enmap.insert(omap, imap, wrap='auto', op=>, cval=0, iwcs=None)

Insert imap into omap based on their world coordinate systems, which must be
compatible. Essentially the reverse of extract.

### pixell.enmap.insert_at(omap, pix, imap, wrap='auto', op=>, cval=0,
iwcs=None)

Insert imap into omap at the position given by pix. If pix is [y,x], then
[0:ny,0:nx] in imap will be copied into [y:y+ny,x:x+nx] in omap. If pix is
[{from,to,[stride]},{y,x}], then this specifies the omap pixbox into which to
copy imap. Wrapping is handled the same way as in extract.

### pixell.enmap.map_union(map1, map2)

Given two maps with compatible wcs but possibly covering different parts of
the sky, return a new map that contains all pixels of both maps. If the input
maps overlap, then those pixels will have the sum of the two maps

### pixell.enmap.overlap(shape, wcs, shape2_or_pixbox, wcs2=None, wrap='auto')

Compute the overlap between the given geometry (shape, wcs) and another
_compatible_ geometry. This can be either another shape, wcs pair or a
pixbox[{from,to},{y,x}]. Returns the geometry of the overlapping region.

### pixell.enmap.neighborhood_pixboxes(shape, wcs, poss, r)

Given a set of positions poss[npos,{dec,ra}] in radians and a distance r in
radians, return pixboxes[npos][{from,to},{y,x}] corresponding to the regions
within a distance of r from each entry in poss.

### pixell.enmap.at(map, pos, mode='spline', order=3, border='constant',
cval=0.0, unit='coord', safe=True, ip=None)

### pixell.enmap.argmax(map, unit='coord')

Return the coordinates of the maximum value in the specified map. If map has
multiple components, the maximum value for each is returned separately, with
the last axis being the position. If unit is “pix”, the position will be given
in pixels. Otherwise it will be in physical coordinates.

### pixell.enmap.argmin(map, unit='coord')

Return the coordinates of the minimum value in the specified map. See argmax
for details.

### pixell.enmap.rand_map(shape, wcs, cov, scalar=False, seed=None,
pixel_units=False, iau=False, spin=[0, 2])

Generate a standard flat-sky pixel-space CMB map in TQU convention based on
the provided power spectrum. If cov.ndim is 4, 2D power is assumed else 1D
power is assumed. If pixel_units is True, the 2D power spectra is assumed to
be in pixel units, not in steradians.

### pixell.enmap.rand_gauss(shape, wcs, dtype=None)

Generate a map with random gaussian noise in pixel space.

### pixell.enmap.rand_gauss_harm(shape, wcs)

Mostly equivalent to np.fft.fft2(np.random.standard_normal(shape)), but avoids
the fft by generating the numbers directly in frequency domain. Does not
enforce the symmetry requried for a real map. If box is passed, the result
will be an enmap.

### pixell.enmap.rand_gauss_iso_harm(shape, wcs, cov, pixel_units=False)

Generates a random map with component covariance cov in harmonic space, where
cov is a (comp,comp,l) array or a (comp,comp,Ny,Nx) array. Despite the name,
the map doesn’t need to be isotropic since 2D power spectra are allowed.

If cov.ndim is 4, cov is assumed to be an array of 2D power spectra. else cov
is assumed to be an array of 1D power spectra. If pixel_units is True, the 2D
power spectra is assumed to be in pixel units, not in steradians.

### pixell.enmap.massage_spectrum(cov, shape)

given a spectrum cov[nl] or cov[n,n,nl] and a shape (stokes,ny,nx) or (ny,nx),
return a new ocov that has a shape compatible with shape, padded with zeros if
necessary. If shape is scalar (ny,nx), then ocov will be scalar (nl). If shape
is (stokes,ny,nx), then ocov will be (stokes,stokes,nl).

### pixell.enmap.extent(shape, wcs, nsub=None, signed=False, method='auto')

Returns the area of a patch with the given shape and wcs, in steradians.

### pixell.enmap.extent_intermediate(shape, wcs, signed=False)

Estimate the flat-sky extent of the map as the WCS intermediate coordinate
extent. This is very simple, but is only appropriate for very flat coordinate
systems

### pixell.enmap.extent_subgrid(shape, wcs, nsub=None, safe=True,
signed=False)

Returns an estimate of the “physical” extent of the patch given by shape and
wcs as [height,width] in radians. That is, if the patch were on a sphere with
radius 1 m, then this function returns approximately how many meters tall and
wide the patch is. These are defined such that their product equals the
physical area of the patch. Obs: Has trouble with areas near poles.

### pixell.enmap.extent_cyl(shape, wcs, signed=False)

Extent specialized for a cylindrical projection. Vertical: ny*cdelt[1]
Horizontal: Each row is nx*cdelt[0]*cos(dec), but we want a single
representative number, which will be some kind of average, and we’re free to
choose which. We choose the one that makes the product equal the true area.
Area = nx*ny*cdelt[0]*cdelt[1]*mean(cos(dec)) =
vertical*(nx*cdelt[0]*mean(cos)), so horizontal = nx*cdelt[0]*mean(cos)

### pixell.enmap.area(shape, wcs, nsamp=1000, method='auto')

Returns the area of a patch with the given shape and wcs, in steradians.

### pixell.enmap.area_intermediate(shape, wcs)

Get the area of a completely flat sky

### pixell.enmap.area_cyl(shape, wcs)

Get the area of a cylindrical projection. Fast and exact.

### pixell.enmap.area_contour(shape, wcs, nsamp=1000)

Get the area of the map by doing a contour integral (1-sin(dec)) d(RA) over
the closed path (dec(t), ra(t)) that bounds the valid region of the map, so it
only works for projections where we can figure out this boundary. Using only
d(RA) in the integral corresponds to doing a top-hat integral instead of
something trapezoidal, but this method is fast enough that we can afford many
points to compensate. The present implementation works for cases where the
valid region of the map runs through the centers of the pixels on each edge or
through the outer edge of those pixels (this detail can be different for each
edge). The former case is needed in the full-sky cylindrical projections that
have pixels centered exactly on the poles.

### pixell.enmap.pixsize(shape, wcs)

Returns the average pixel area, in steradians.

### pixell.enmap.pixshape(shape, wcs, signed=False)

Returns the average pixel height and width, in radians.

### pixell.enmap.pixshapemap(shape, wcs, bsize=1000, separable='auto',
signed=False, bcheck=False)

Returns the physical width and heigh of each pixel in the map in radians.
Heavy for big maps. Much faster approaches are possible for known
pixelizations.

### pixell.enmap.pixshapes_cyl(shape, wcs, signed=False, bcheck=False)

Returns the physical width and height of pixels for each row of a cylindrical
map with the given shape, wcs, in radians, as an array [{height,width},ny].
All pixels in a row have the same shape in a cylindrical projection.

### pixell.enmap.pixsizemap(shape, wcs, separable='auto', broadcastable=False,
bsize=1000, bcheck=False)

Returns the physical area of each pixel in the map in steradians.

If separable is True, then the map will be assumed to be in a cylindircal
projection, where the pixel size is only a function of declination. This makes
the calculation dramatically faster, and the resulting array will also use
much less memory due to numpy striding tricks. The default, separable=auto”,
determines whether to use this shortcut based on the properties of the wcs.

Normally the function returns a ndmap of shape [ny,nx]. If broadcastable is
True, then it is allowed to return a smaller array that would still broadcast
correctly to the right shape. This can be useful to save work if one is going
to be doing additional manipulation of the pixel size before using it. For a
cylindrical map, the result would have shape [ny,1] if broadcastable is True.

BUG: This function assumes parallelogram-shaped pixels. This breaks for non-
cylindrical projections!

### pixell.enmap.pixsizemap_contour(shape, wcs, bsize=1000, bcheck=False)

### pixell.enmap.pixshapebounds(shape, wcs, separable='auto')

Return the minimum and maximum pixel height and width for the given geometry,
in the form [{min,max},{y,x}]. Fast for separable geometries like cylindrical
ones, which it will try to recognize, but this can be forced by setting
separable to True (or disabled with False). Heavy in the general case.

### pixell.enmap.lmap(shape, wcs, oversample=1, method='auto')

Return a map of all the wavenumbers in the fourier transform of a map with the
given shape and wcs.

### pixell.enmap.modlmap(shape, wcs, oversample=1, method='auto', min=0)

Return a map of all the abs wavenumbers in the fourier transform of a map with
the given shape and wcs.

### pixell.enmap.center(shape, wcs)

### pixell.enmap.modrmap(shape, wcs, ref='center', safe=True, corner=False)

Return an enmap where each entry is the distance from center of that entry.
Results are returned in radians, and if safe is true (default), then sharp
coordinate edges will be avoided.

### pixell.enmap.laxes(shape, wcs, oversample=1, method='auto',
broadcastable=False)

### pixell.enmap.lrmap(shape, wcs, oversample=1)

Return a map of all the wavenumbers in the fourier transform of a map with the
given shape and wcs.

### pixell.enmap.lpixsize(shape, wcs, signed=False, method='auto')

### pixell.enmap.lpixshape(shape, wcs, signed=False, method='auto')

### pixell.enmap.fft(emap, omap=None, nthread=0, normalize=True,
adjoint_ifft=False, dct=False)

Performs the 2d FFT of the enmap pixels, returning a complex enmap. If
normalize is “phy”, “phys” or “physical”, then an additional normalization is
applied such that the binned square of the fourier transform can be directly
compared to theory (apart from mask corrections) , i.e., pixel area factors
are corrected for.

### pixell.enmap.ifft(emap, omap=None, nthread=0, normalize=True,
adjoint_fft=False, dct=False)

Performs the 2d iFFT of the complex enmap given, and returns a pixel-space
enmap.

### pixell.enmap.dct(emap, omap=None, nthread=0, normalize=True)

### pixell.enmap.idct(emap, omap=None, nthread=0, normalize=True)

### pixell.enmap.fft_adjoint(emap, omap=None, nthread=0, normalize=True)

### pixell.enmap.ifft_adjoint(emap, omap=None, nthread=0, normalize=True)

### pixell.enmap.idct_adjoint(emap, omap=None, nthread=0, normalize=True)

### pixell.enmap.dct_adjoint(emap, omap=None, nthread=0, normalize=True)

### pixell.enmap.map2harm(emap, nthread=0, normalize=True, iau=False, spin=[0,
2], adjoint_harm2map=False)

Performs the 2d FFT of the enmap pixels, returning a complex enmap. If
normalize starts with “phy” (for physical), then an additional normalization
is applied such that the binned square of the fourier transform can be
directly compared to theory (apart from mask corrections) , i.e., pixel area
factors are corrected for.

### pixell.enmap.harm2map(emap, nthread=0, normalize=True, iau=False, spin=[0,
2], keep_imag=False, adjoint_map2harm=False)

### pixell.enmap.map2harm_adjoint(emap, nthread=0, normalize=True, iau=False,
spin=[0, 2], keep_imag=False)

### pixell.enmap.harm2map_adjoint(emap, nthread=0, normalize=True, iau=False,
spin=[0, 2])

### pixell.enmap.queb_rotmat(lmap, inverse=False, iau=False, spin=2, wcs=None)

### pixell.enmap.rotate_pol(emap, angle, comps=[-2, -1], spin=2, axis=-3)

Rotate the polarization of the given enmap “emap” by angle (in radians) along
the given components (the last two by default) of the given axis (the 3rd-last
axis by default). In standard enmaps the 3rd-last axis is holds the Stokes
components of the map in the order T, Q, U. The spin argument controls the
spin, and defaults to spin-2. This function is flexible enough to work with
non-enmaps too.

### pixell.enmap.map_mul(mat, vec)

Elementwise matrix multiplication mat*vec. Result will have the same shape as
vec. Multiplication happens along the last non-pixel indices.

### pixell.enmap.smooth_gauss(emap, sigma)

Smooth the map given as the first argument with a gaussian beam with the given
standard deviation sigma in radians. If sigma is negative, then the complement
of the smoothed map will be returned instead (so it will be a highpass
filter).

### pixell.enmap.inpaint(map, mask, method='nearest')

Inpaint regions in emap where mask==True based on the nearest unmasked pixels.
Uses scipy.interpolate.griddata internally. See its documentation for the
meaning of method. Note that if method is not “nearest”, then areas where the
mask touches the edge will be filled with NaN instead of sensible values.

The purpose of this function is mainly to allow inapinting bad values with a
continuous signal with the right order of magnitude, for example to allow
fourier operations of masked data with large values near the edge of the mask
(e.g. a galactic mask). Its goal is not to inpaint with something realistic-
looking. For that heavier methods are needed.

FIXME: This function is slow and not very good. Fix or remove.

### pixell.enmap.calc_window(shape, order=0, scale=1)

Compute fourier-space pixel window function. Since the window function is
separable, it is returned as an x and y part, such that window =
wy[:,None]*wx[None,:]. By default the pixel window for interpolation order 0
mapmaking (nearest neighbor) is returned. Pass 1 for bilinear mapmaking’s
pixel window. The scale argument can be used to calculate the pixel window at
non-native resolutions. For example, with scale=2 you will get the pixwin for
a map with twice the resolution

### pixell.enmap.apply_window(emap, pow=1.0, order=0, scale=1, nofft=False)

Apply the pixel window function to the specified power to the map, returning a
modified copy. Use pow=-1 to unapply the pixel window. By default the pixel
window for interpolation order 0 mapmaking (nearest neighbor) is applied. Pass
1 for bilinear mapmaking’s pixel window.

### pixell.enmap.unapply_window(emap, pow=1.0, order=0, scale=1, nofft=False)

The inverse of apply_window. Equivalent to just flipping the sign of the pow
argument.

### pixell.enmap.samewcs(arr, *args)

Returns arr with the same wcs information as the first enmap among args. If no
matches are found, arr is returned as is. Will reference, rather than copy,
the underlying array data whenever possible.

### pixell.enmap.geometry2(pos=None, res=None, shape=None, proj='car',
variant=None, deg=False, pre=(), ref=None, **kwargs)

Consruct a shape,wcs pair suitable for initializing enmaps. Some combination
of pos, res and shape must be passed:

  * Only res given: A fullsky geometry with this resolution is constructed
  * Only shape given: Fullsky geometry with the given shape. This may result in different resolution in the y and x directions if the shape is not chosen carefully
  * pos and res given: A fullsky geometry with the given resolution is constructed, and is then cropped using pos. pos must be [{from,to},{dec,ra}], which specifies the corners of the geometry (to within a pixel).
  * pos, res and shape given: As previous, but pos is just [{dec,ra}] and specifies the center of the geometry (to within a pixel), with the shape being given by shape

Other combinations are not supported. The other arguments are:

  * proj: The projection to use. Either name or name:variant, where name is a WCS projection name like “CAR” (case-insensitive) and variant is a pixelization variant (see next)
  * variant: A pixelization variant. Specifies how to split the full sky into pixels. Valid values: * “safe”: pixel edge at all domain edges, e.g. both poles in dec and

> wraparound point in ra for cylindricatl projections. This rule is downgrade-
> safe, meaning that constructing a geometry and then downgrading it will
> produce the same geometry as directly constructing it at the downgraded
> resolution. This has the Fejer1 quadrature rules, but has a different name
> to distinguish it from our original implementation of Fejer1. Equivalent to
> the rule “hh,hh”.

  * “fejer1”: pixel edge at top/bottom domain edges, but pixel center at left/right domain edges. Follows the Fejer1 quadrature rules. Only partially downgrade-safe: Can still SHT after downgrading, but is not pixel-compatible with directly constructing a geometry at the target resolution. Equivalent to the rule “00,hh”. This is the default, but it may be changed to “safe” in the future.
  * “cc”: pixel center at all domain edges. Follows the Clenshaw-Curtis quadrature rules. Not downgrade-safe at all - cannot efficiently SHT after downgrade. Equivalent to the rule “00,00”.
  * “any”: No restriction on pixel center/edge placement. Allows for arbitrary-resolution maps, but not fast SHTs. Equivalent to the rule “**,** ”.
  * A rule of the form “lr,bt”, where l,r,b,t specify the pixel placement for the left, right, bottom and top domain edges respectively. Each can take the values * “0”: pixel center here (0 offset) * “h”: pixel edge here (half-pixel offset) * “*”: no restriction
  * deg: If True (defaults to False), then pos, res and ref have units of degrees instead of radians.
  * pre: Tuple of pre-dimensions to prepend to the returned shape
  * ref: Reference point coordinates. This is the point the full geometry is built around. E.g. for Mollweide it would be the center of the Mollweide ellipse. Changing this point actually changes the projection, and projections with different ref will be incompatible with each other aside from special cases. Defaults to ra=dec=0 for non-azimuthal projections and ra=0, dec=pi/2 for azimuthal projections. The special value “mid” will use pos to set the reference point. Should probably be left alone unless you have special requirements.

### pixell.enmap.fullsky_geometry2(res=None, shape=None, pre=None, deg=False,
proj='car', variant=None, dims=None)

Build a fullsky geometry with the given resolution or shape. Simply forwards
to geometry(). See its docstring for the meaning of the arguments.

dims is an alias for pre provided for backwards compatibility

### pixell.enmap.band_geometry2(decrange, res=None, shape=None, pre=None,
deg=False, proj='car', variant=None, dims=None)

Build a geometry covering a range of declinations. Equivalent to
geometry(pos=[[decrange[0],pi],[decrange[1],-pi]], …). See geometry’s
documentation for the meaning of the other arguments.

dims is an alias for pre provided for backwards compatibility

### pixell.enmap.geometry(pos, res=None, shape=None, proj='car', variant='cc',
deg=False, pre=(), force=False, ref=None, **kwargs)

Consruct a shape,wcs pair suitable for initializing enmaps. pos can be either
a {dec,ra} center position or a [{from,to},{dec,ra}] array giving the bottom-
left and top-right corners of the desired geometry. At least one of res or
shape must be specified. If res is specified, it must either be a number, in
which the same resolution is used in each direction, or {dec,ra}. If shape is
specified, it must be at least [2]. All angles are given in radians.

The projection type is chosen with the proj argument. The default is “car”,
corresponding to the equirectangular plate carree projection. Other valid
projections are “cea”, “zea”, “gnom”, etc. See wcsutils for details.

By default the geometry is tweaked so that a standard position, typically
ra=0,dec=0, would be at an integer logical pixel position (even if that
position is outside the physical map). This makes it easier to generate maps
that are compatible up to an integer pixel offset, as well as maps that are
compatible with the predefined spherical harmonics transform ring weights. The
cost of this tweaking is that the resulting corners can differ by a fraction
of a pixel from the one requested. To force the geometry to exactly match the
corners provided you can pass force=True. It is also possible to manually
choose the reference point via the ref argument, which must be a dec,ra
coordinate pair (in radians).

### pixell.enmap.fullsky_geometry(res=None, shape=None, dims=(), proj='car',
variant='fejer1')

Build an enmap covering the full sky, with the outermost pixel centers at the
poles and wrap-around points. Only the car projection is supported for now,
but the variants CC and fejer1 can be selected using the variant keyword. This
currently defaults to CC, but will likely change to fejer1 in the future.

### pixell.enmap.band_geometry(dec_cut, res=None, shape=None, dims=(),
proj='car', variant='fejer1')

Return a geometry corresponding to a sky that had a full-sky geometry but to
which a declination cut was applied. If dec_cut is a single number, the
declination range will be (-dec_cut,dec_cut) radians, and if specified with
two components, it is interpreted as (dec_cut_min,dec_cut_max). The remaining
arguments are the same as fullsky_geometry and pertain to the geometry before
cropping to the cut-sky.

### pixell.enmap.thumbnail_geometry(r=None, res=None, shape=None, dims=(),
proj='tan')

Build a geometry in the given projection centered on (0,0), which will be
exactly at a pixel center.

> r: The radius from the center to the edges of the patch, in radians. res:
> The resolution of the patch, in radians. shape: The target shape of the
> patch. Will be forced to odd numbers if necessary.

Any two out of these three arguments must be specified. The most common usage
will probably be to specify r and res, e.g.

> shape, wcs = enmap.thumbnail_geometry(r=1*utils.degree,
> res=0.5*utils.arcmin)

The purpose of this function is to provide a geometry appropriate for object
stacking, etc. Ideally enmap.geometry would do this, but this specialized
function makes it easier to ensure that the center of the coordinate system
will be at excactly the pixel index (y,x) = shape//2+1, which was a commonly
requested feature (even though which pixel is at the center shouldn’t really
matter as long as one takes into account the actual coordinates of each
pixel).

### pixell.enmap.union_geometry(geometries)

Given a list of compatible geometries, return a new geometry that’s the union
if the inputs, in the sense that it contains all the pixels that the
individual ones contain

### pixell.enmap.recenter_cyl(shape, wcs)

Given a cylindrical geometry with the equator horizontal, move the reference
point to the point along the equator closest to the middle of the geometry.
This is useful when deriving a sub-geometry that strattles the wrap-around
point of another geometry

### pixell.enmap.recenter_geo(shape, wcs, mode='auto')

Return either a recentered geometry or the original one, depending on the
value of mode, which accepts three values: * True: Always attempts to
recenter. Will fail if it’s a non-cylindrical geometry * False: Leaves the
geometry as it is * “auto”: Recenters only if it’s a cylindrical geometry

### pixell.enmap.create_wcs(shape, box=None, proj='cea')

Very old function. Do not use

### pixell.enmap.spec2flat(shape, wcs, cov, exp=1.0, border='constant',
oversample=1, smooth='auto')

Given a (ncomp,ncomp,l) power spectrum, expand it to harmonic map space,
returning (ncomp,ncomp,y,x). This involves a rescaling which converts from
power in terms of multipoles, to power in terms of 2d frequency. The optional
exp argument controls the exponent of the rescaling factor. To use this with
the inverse power spectrum, pass exp=-1, for example. If apply_exp is True,
the power spectrum will be taken to the exp’th power. Otherwise, it is assumed
that this has already been done, and the exp argument only controls the
normalization of the result.

It is irritating that this function needs to know what kind of matrix it is
expanding, but I can’t see a way to avoid it. Changing the units of harmonic
space is not sufficient, as the following demonstrates:

> m = harm2map(map_mul(spec2flat(s, b, multi_pow(ps, 0.5), 0.5),
> map2harm(rand_gauss(s,b))))

The map m is independent of the units of harmonic space, and will be wrong
unless the spectrum is properly scaled. Since this scaling depends on the
shape of the map, this is the appropriate place to do so, ugly as it is.

### pixell.enmap.spec2flat_corr(shape, wcs, cov, exp=1.0, border='constant')

### pixell.enmap.smooth_spectrum(ps, kernel='gauss', weight='mode', width=1.0)

Smooth the spectrum ps with the given kernel, using the given weighting.

### pixell.enmap.calc_ps2d(harm, harm2=None)

Compute the 2d power spectrum of the harmonic-space enmap “harm”, as output by
map2harm. Use map2harm with norm=”phys” to get physical units in this
spectrum. If harm2 is specified, then the cross-spectrum between harm and
harm2 is computed instead.

Some example usage, where the notation a[{x,y,z},n,m] specifies that the array
a has shape [3,n,m], and the 3 entries in the first axis should be interpreted
as x, y and z respectively.

  1. cl[nl] = calc_ps2d(harm[ny,nx]) This just computes the standard power spectrum of the given harm, resulting in a single 2d enmap.
  2. cl[nl] = calc_ps2d(harm1[ny,nx], harm2[ny,nx]) This compues the 1d cross-spectrum between the 2d enmaps harm1 and harm2.
  3. cl[{T,E,B},{T,E,B},nl] = calc_ps2d(harm[{T,E,B},None,ny,nx], harm[None,{T,E,B},ny,nx]) This computes the 3x3 polarization auto-spectrum for a 3d polarized harmonic enmap.
  4. cl[{T,E,B},{T,E,B},nl] = calc_ps2d(harm1[{T,E,B},None,ny,nx], harm2[None,{T,E,B},ny,nx]) As above, but gives the 3x3 polarization cross-spectrum between two 3d harmonic enmaps.

The output is in the shape one would expect from numpy broadcasting. For
example, in the last example, the TE power spectrum would be found in cl[0,1],
and the ET power spectrum (which is different for the cross-spectrum case) is
in cl[1,0].

### pixell.enmap.multi_pow(mat, exp, axes=[0, 1])

Raise each sub-matrix of mat (ncomp,ncomp,…) to the given exponent in eigen-
space.

### pixell.enmap.get_downgrade_offset(shape, wcs, factor, ref=None)

Get the pixel offset required to keep a map downgraded by the given factor
aligned with the reference point.

### pixell.enmap.downgrade(emap, factor, op=, ref=None, off=None,
inclusive=False)

Returns enmap “emap” downgraded by the given integer factor (may be a list for
each direction, or just a number) by averaging inside pixels. Returns the
original map if factor is None or 1.

### pixell.enmap.downgrade_fft(emap, factor)

Like downgrade(emap, factor), but uses fourier-resampling. This avoids
introducing both a pixel window and aliasing, but assumes periodic boundary
conditions.

### pixell.enmap.upgrade_fft(emap, factor)

Like upgrade(emap, factor), but uses fourier-resampling. This avoids
introducing any sharp edges, preserving the shape of the power spectrum.

### pixell.enmap.upgrade(emap, factor, off=None, oshape=None, inclusive=False)

Upgrade emap to a larger size using nearest neighbor interpolation, returning
the result. More advanced interpolation can be had using enmap.interpolate.

### pixell.enmap.downgrade_geometry(shape, wcs, factor)

Returns the oshape, owcs corresponding to a map with geometry shape, wcs that
has been downgraded by the given factor. Similar to scale_geometry, but
truncates the same way as downgrade, and only supports integer factors.

### pixell.enmap.upgrade_geometry(shape, wcs, factor)

### pixell.enmap.crop_geometry(shape, wcs, box=None, pixbox=None, oshape=None)

### pixell.enmap.distance_transform(mask, omap=None, rmax=None,
method='cellgrid')

Given a boolean mask, produce an output map where the value in each pixel is
the distance to the closest false pixel in the mask. See distance_from for the
meaning of rmax.

### pixell.enmap.labeled_distance_transform(labels, omap=None, odomains=None,
rmax=None, method='cellgrid')

Given a map of labels going from 1 to nlabel, produce an output map where the
value in each pixel is the distance to the closest nonzero pixel in the
labels, as well as a map of which label each pixel was closest to. See
distance_from for the meaning of rmax.

### pixell.enmap.distance_from(shape, wcs, points, omap=None, odomains=None,
domains=False, method='cellgrid', rmax=None, step=1024)

Find the distance from each pixel in the geometry (shape, wcs) to the nearest
of the points[{dec,ra},npoint], returning a [ny,nx] map of distances. If
domains==True, then it will also return a [ny,nx] map of the index of the
point that was closest to each pixel. If rmax is specified and the method is
“cellgrid” or “bubble”, then distances will only be computed up to rmax.
Beyond that distance will be set to rmax and domains to -1. This can be used
to speed up the calculation when one only cares about nearby areas.

### pixell.enmap.distance_transform_healpix(mask, omap=None, rmax=None,
method='heap')

Given a boolean healpix mask, produce an output map where the value in each
pixel is the distance to the closest false pixel in the mask. See
distance_from for the meaning of rmax.

### pixell.enmap.labeled_distance_transform_healpix(labels, omap=None,
odomains=None, rmax=None, method='heap')

Given a healpix map of labels going from 1 to nlabel, produce an output map
where the value in each pixel is the distance to the closest nonzero pixel in
the labels, as well as a map of which label each pixel was closest to. See
distance_from for the meaning of rmax.

### pixell.enmap.distance_from_healpix(nside, points, omap=None,
odomains=None, domains=False, rmax=None, method='bubble')

Find the distance from each pixel in healpix map with nside nside to the
nearest of the points[{dec,ra},npoint], returning a [ny,nx] map of distances.
If domains==True, then it will also return a [ny,nx] map of the index of the
point that was closest to each pixel. If rmax is specified, then distances
will only be computed up to rmax. Beyond that distance will be set to rmax and
domains to -1. This can be used to speed up the calculation when one only
cares about nearby areas.

### pixell.enmap.grow_mask(mask, r)

Grow the True part of boolean mask “mask” by a distance of r radians

### pixell.enmap.shrink_mask(mask, r)

Shrink the True part of boolean mask “mask” by a distance of r radians

### pixell.enmap.pad(emap, pix, return_slice=False, wrap=False, value=0)

Pad enmap “emap”, creating a larger map with zeros filled in on the sides. How
much to pad is controlled via pix, which har format [{from,to},{y,x}], [{y,x}]
or just a single number to apply on all sides. E.g. pix=5 would pad by 5 on
all sides, and pix=[[1,2],[3,4]] would pad by 1 on the bottom, 2 on the left,
3 on the top and 4 on the right.

### pixell.enmap.find_blank_edges(m, value='auto')

Returns blanks[{front,back},{y,x}], the size of the blank area at the
beginning and end of each axis of the map, where the argument “value”
determines which value is considered blank. Can be a float value, or the
strings “auto” or “none”. Auto will choose the value that maximizes the edge
area considered blank. None will result in nothing being consideered blank.

### pixell.enmap.autocrop(m, method='plain', value='auto', margin=0,
factors=None, return_info=False)

Adjust the size of m to be more fft-friendly. If possible, blank areas at the
edge of the map are cropped to bring us to a nice length. If there there
aren’t enough blank areas, the map is padded instead. If value=”none” no
values are considered blank, so no cropping will happen. This can be used to
autopad for fourier-friendliness.

### pixell.enmap.padcrop(m, info)

### pixell.enmap.grad(m)

Returns the gradient of the map m as [2,…].

### pixell.enmap.grad_pix(m)

The gradient of map m expressed in units of pixels. Not the same as the
gradient of m with resepect to pixels. Useful for avoiding sky2pix-calls for
e.g. lensing, and removes the complication of axes that increase in
nonstandard directions.

### pixell.enmap.div(m)

Returns the divergence of the map m[2,…] as […].

### pixell.enmap.laplace(m)

### pixell.enmap.apod(map, width, profile='cos', fill='zero', inplace=False)

### pixell.enmap.apod_profile_lin(x)

### pixell.enmap.apod_profile_cos(x)

### pixell.enmap.apod_mask(mask, width=0.017453292519943295, edge=True,
profile=)

Given an enmap mask that’s 0 in bad regions and 1 in good regions, return an
apodization map that’s still 0 in bad regions, but transitions smoothly to 1
in the good region over the given width in radians. The transition profile is
controlled by the profile argument. Regions outside the image are considered
to be bad.

### pixell.enmap.lform(map, method='auto')

Given an enmap, return a new enmap that has been fftshifted (unless
shift=False), and which has had the wcs replaced by one describing fourier
space. This is mostly useful for plotting or writing 2d power spectra.

It could have been useful more generally, but because all “plain” coordinate
systems are assumed to need conversion between degrees and radians, sky2pix
etc. get confused when applied to lform-maps.

### pixell.enmap.lwcs(shape, wcs, method='auto')

Build world coordinate system for l-space

### pixell.enmap.rbin(map, center=[0, 0], bsize=None, brel=1.0,
return_nhit=False, return_bins=False, rop=None)

Radially bin map around the given center point ([0,0] by default). If bsize it
given it will be the constant bin width. This defaults to the pixel size. brel
can be used to scale up the bin size. This is mostly useful when using
automatic bsize.

Returns bvals[…,nbin], r[nbin], where bvals is the mean of the map in each
radial bin and r is the mid-point of each bin

### pixell.enmap.lbin(map, bsize=None, brel=1.0, return_nhit=False,
return_bins=False, lop=None)

Like rbin, but for fourier space. Returns b(l),l

### pixell.enmap.radial_average(map, center=[0, 0], step=1.0)

### pixell.enmap.padslice(map, box, default=nan)

Equivalent to map[…,box[0,0]:box[1,0],box[0,1]:box[1,1]], except that pixels
outside the map are treated as actually being present, but filled with the
value given by “default”. Hence, ther esult will always have size
box[1]-box[0].

### pixell.enmap.tile_maps(maps)

Given a 2d list of enmaps representing contiguous tiles in the same global
pixelization, stack them into a total map and return it. E.g. if maps =
[[a,b],[c,d]], then the result would be

> c d

map = a b

### pixell.enmap.stamps(map, pos, shape, aslist=False)

Given a map, extract a set of identically shaped postage stamps with corners
at pos[ntile,2]. The result will be an enmap with shape [ntile,…,ny,nx] and a
wcs appropriate for the _first_ tile only. If that is not the behavior wanted,
you can specify aslist=True, in which case the result will be a list of
enmaps, each with the correct wcs.

### pixell.enmap.to_healpix(imap, omap=None, nside=0, order=3, chunk=100000)

### pixell.enmap.to_flipper(imap, omap=None, unpack=True)

Convert the enmap “imap” into a flipper map with the same geometry. If omap is
given, the output will be written to it. Otherwise, a an array of flipper maps
will be constructed. If the input map has dimensions [a,b,c,ny,nx], then the
output will be an [a,b,c] array with elements that are flipper maps with
dimension [ny,nx]. The exception is for a 2d enmap, which is returned as a
plain flipper map, not a 0-dimensional array of flipper maps. To avoid this
unpacking, pass

Flipper needs cdelt0 to be in decreasing order. This function ensures that, at
the cost of losing the original orientation. Hence to_flipper followed by
from_flipper does not give back an exactly identical map to the one on started
with.

### pixell.enmap.from_flipper(imap, omap=None)

Construct an enmap from a flipper map or array of flipper maps imap. If omap
is specified, it must have the correct shape, and the data will be written
there.

### pixell.enmap.write_map(fname, emap, fmt=None, address=None, extra={},
allow_modify=False)

Writes an enmap to file. If fmt is not passed, the file type is inferred from
the file extension, and can be either fits or hdf. This can be overriden by
passing fmt with either ‘fits’ or ‘hdf’ as argument.

The other arguments are passed to write_fits and/or write_hdf.

### pixell.enmap.read_map(fname, fmt=None, sel=None, box=None, pixbox=None,
geometry=None, wrap='auto', mode=None, sel_threshold=10000000.0, wcs=None,
hdu=None, delayed=False, verbose=False, address=None, recenter=False)

Read an enmap from file. The file type is inferred from the file extension,
unless fmt is passed. fmt must be one of ‘fits’ and ‘hdf’.

The sel, box, pixbox, geometry, wrap, mode, and delayed arguments are all used
by read_helper to (optionally) select a subregion of the map or change how it
is wrapped on the sky.

The hdu and verbose arguments are only used for FITS (see read_fits). The
address argument is only used for HDF (see read_hdf).

### pixell.enmap.read_map_geometry(fname, fmt=None, hdu=None, address=None)

Read an enmap geometry from file. The file type is inferred from the file
extension, unless fmt is passed. fmt must be one of ‘fits’ and ‘hdf’.

### pixell.enmap.read_map_dtype(fname, fmt=None, hdu=None, address=None)

### pixell.enmap.write_map_geometry(fname, shape, wcs, fmt=None)

Write an enmap geometry to file. The file type is inferred from the file
extension, unless fmt is passed. fmt must be one of ‘fits’ and ‘hdf’. Only
fits is supported for now, though.

### pixell.enmap.write_fits(fname, emap, extra={}, allow_modify=False)

Write an enmap to a fits file.

### pixell.enmap.write_fits_geometry(fname, shape, wcs)

Write just the geometry to a fits file that will only contain the header

### pixell.enmap.read_fits(fname, hdu=None, sel=None, box=None, pixbox=None,
geometry=None, wrap='auto', mode=None, sel_threshold=10000000.0, wcs=None,
delayed=False, recenter=False, verbose=False)

Read an enmap from the specified fits file. By default, the map and coordinate
system will be read from HDU 0. Use the hdu argument to change this. The map
must be stored as a fits image. If sel is specified, it should be a slice that
will be applied to the image before reading. This avoids reading more of the
image than necessary. Instead of sel, a coordinate box
[[yfrom,xfrom],[yto,xto]] can be specified.

### pixell.enmap.read_fits_header(fname, hdu=None, quick=True)

### pixell.enmap.read_fits_geometry(fname, hdu=None, quick=True)

Read an enmap wcs from the specified fits file. By default, the map and
coordinate system will be read from HDU 0. Use the hdu argument to change
this. The map must be stored as a fits image.

### pixell.enmap.read_fits_dtype(fname, hdu=None, quick=True)

### pixell.enmap.write_hdf(fname, emap, address=None, extra={})

Write an enmap as an hdf file, preserving all the WCS metadata.

  * **Parameters:**
  * **fname** (_str_ _or_ _h5py.Group_) – Filename or open h5py handle.
  * **emap** (_ndmap_) – Object to store.
  * **address** (_str_) – Group address within the HDF file to place the result. If None, the data are written at root level after truncating the file.
  * **extra** (_dict_) – additional data to write into the output.

### Notes

If address is None, the output file will be replaced if it exists. If address
is a string, and the target file exists, the file will not be reset but
anything living at that address will be replaced with the encoded emap.

### pixell.enmap.read_hdf(fname, hdu=None, sel=None, box=None, pixbox=None,
geometry=None, wrap='auto', mode=None, sel_threshold=10000000.0, wcs=None,
delayed=False, address=None, recenter=False)

Read an enmap from the specified hdf file. Two formats are supported. The old
enmap format, which simply used a bounding box to specify the coordinates, and
the new format, which uses WCS properties. The latter is used if available.
With the old format, plate carree projection is assumed. Note: some of the old
files have a slightly buggy wcs, which can result in 1-pixel errors.

If address is a string, the map will be loaded from that group address within
fname.

Note fname can be passed in as an h5py.Group (e.g. an open h5py.File) instead
of a string, and the map will be read from that handle.

### pixell.enmap.read_hdf_geometry(fname, address=None)

Read an enmap wcs from the specified hdf file.

### pixell.enmap.read_hdf_dtype(fname, address=None)

### pixell.enmap.read_npy(fname, hdu=None, sel=None, box=None, pixbox=None,
geometry=None, wrap='auto', mode=None, sel_threshold=10000000.0, wcs=None,
delayed=False, address=None, recenter=False)

Read an enmap from the specified npy file. Only minimal support. No wcs
information.

### pixell.enmap.fix_python3(s)

Convert “bytes” to string in python3, while leaving other types unmolested.
Python3 string handling is stupid.

### pixell.enmap.read_helper(data, sel=None, box=None, pixbox=None,
geometry=None, wrap='auto', mode=None, delayed=False, recenter=False)

Helper function for map reading. Handles the slicing, sky-wrapping and
capping, etc.

### _class_ pixell.enmap.ndmap_proxy(shape, wcs, dtype, fname='',
threshold=10000000.0)

#### _property_ ndim

#### _property_ geometry

#### _property_ npix

#### submap(box, mode=None, wrap='auto', recenter=False)

#### stamps(pos, shape, aslist=False)

#### area()

#### box(npoint=10, corner=True)

#### center()

#### distance_from(points, omap=None, odomains=None, domains=False,
method='cellgrid', rmax=None, step=1024)

#### extent(method='auto', signed=False)

#### extract(shape, wcs, omap=None, wrap='auto', op=>, cval=0, iwcs=None,
reverse=False)

#### extract_pixbox(pixbox, omap=None, wrap='auto', op=>, cval=0, iwcs=None,
reverse=False)

#### lmap(oversample=1)

#### modlmap(oversample=1, min=0)

#### modrmap(ref='center', safe=True, corner=False)

#### pix2sky(pix, safe=True, corner=False)

#### pixbox_of(oshape, owcs)

#### pixmap()

#### pixshape(signed=False)

#### pixshapemap(separable='auto', signed=False)

#### pixsize()

#### pixsizemap(separable='auto', broadcastable=False)

#### posmap(safe=True, corner=False, separable='auto', dtype=)

#### sky2pix(coords, safe=True, corner=False)

### _class_ pixell.enmap.ndmap_proxy_fits(hdu, wcs, fname='',
threshold=10000000.0, verbose=False)

### _class_ pixell.enmap.ndmap_proxy_hdf(dset, wcs, fname='',
threshold=10000000.0)

### pixell.enmap.fix_endian(map)

Make endianness of array map match the current machine. Returns the result.

### pixell.enmap.get_stokes_flips(hdu)

Given a FITS HDU, parse its header to determine which, if any, axes need to
have their sign flip to get them in the COSMO polarization convention. Returns
an array of length ndim, with each entry being the index of the axis that
should be flipped, or -1 if none should be flipped.

### pixell.enmap.shift(map, off, inplace=False, keepwcs=False)

Cyclicly shift the pixels in map such that a pixel at position (i,j) ends up
at position (i+off[0],j+off[1])

### pixell.enmap.fractional_shift(map, off, keepwcs=False, nofft=False)

Shift map cyclically by a non-integer amount off [{y_off,x_off}]

### pixell.enmap.fftshift(map, inplace=False)

### pixell.enmap.ifftshift(map, inplace=False)

### pixell.enmap.fillbad(map, val=0, inplace=False)

### pixell.enmap.resample(map, oshape, off=(0, 0), method='fft',
border='wrap', corner=True, order=3)

Resample the input map such that it covers the same area of the sky with a
different number of pixels given by oshape.

### pixell.enmap.resample_fft(fimap, oshape, fomap=None, off=(0, 0),
corner=True, norm='pix', op=>, dummy=False)

Like resample, but takes a fourier-space map as input and outputs a fourier-
space map. unit specifies which fourier-space unit is used. “pix” corresponds
to the standard enmap normalization (normalize=True in enmap.fft). “phys”
corresponds to physical normalization (normalize=”phys”). The fourier-units
matter because some fourier-space units need rescaline when going from one
resolution to another.

### pixell.enmap.spin_helper(spin, n)

### pixell.enmap.spin_pre_helper(spin, pre)

Like spin_helper, but also handles looping over pre-dimensions

### pixell.enmap.padtiles(*maps, tshape=600, pad=60, margin=60, mode='auto',
start=0, step=1)

Iterate over padded tiles in one or more maps. The tiling will have a logical
tile shape of tshape, but each yielded tile will be expanded with some data
from its neighbors. The extra area consists of two parts: The padding and the
margin. For a read-iterator these are equivalent, but for a write-iterator the
margin will be ignored (and so can be used for apodization), while the padding
will be used for crossfading when mergin the tiles together.

Typical usage:

> for itile, otile in padtiles(imap, imap, margin=60): : itile = apod(itile,
> 60) otile[:] = some_filter(itile)

This would iterate over tiles of imap and omap, with the default padding and a
margin of 60 pixels. The margin region is used for apodization, and some
filter is then applied to the tile, writing the result to the output tile.
Note the use of [:] to actually write to otile instead of just rebinding the
variable name!

It’s also possible to iterate over fewer or more maps at once. See the “mode”
argument.

If the tile shape does not evenly divide the map shape, then the last tile in
each row and column will extend beyond the edge of the map. These pixels will
be treated as enmap.extract does, with the potential of sky wrapping. Warning:
Write-iterators for a map that goes all the way around the sky while the tile
shape does not divide the map shape will incorrectly weight the wrapped tiles,
so avoid this.

  * **Parameters:**
  * ***maps** ( _*_) – 

The maps to iterate over. Must have the same pixel dimensions. * **tshape** (
_*_) – The tile shape. Either an integer or a (yshape,xshape) tuple. Default:
600 pixels. * **pad** ( _*_) – The padding. Either an integer or a (ypad,xpad)
tuple. Used to implement context and crossfading. Cannot be larger than half
of tshape. Default: 60 pixels. * **margin** ( _*_) – The margin size. Either
an integer or a (ymargin,xmargin) tuple. Ignored in write-iterators, so
suitable for apodization. Default 60 pixels. * **mode** ( _*_) – Specifies
which maps should be read-iterated vs. write-iterated. A read-iterated map
will yield padded tiles from the corresponding map. Writes to these tiles are
discarded. A write-iterated map yields zeroed tiles of the same shape as the
read-iterator. Writes to these tiles are used to update the corresponding map,
including crossfading the overlapping regions (due to the padding) such that
there aren’t any sharp tile boundaries in the output map. mode can be either
“auto” or a string of the same length as maps consisting of “r” and “w”
characters. If the nth character is r/w then the corresponding map will be
read/write-iterated. If the string is “auto”, then the last map will be
output-iterated and all the others input- iterated, unless there’s only a
single map in which case it will be input- iterated. Default: “auto”. *
**start** ( _*_) – Flattened tile offset to start at. Useful for mpi loops.
Default: 0. * **step** ( _*_) – Flattened tile stride. Useful for mpi loops.
Default: 1

### _class_ pixell.enmap.Padtiler(tshape=600, pad=60, margin=60, start=0,
step=1)

Helper class used to implement padtiles. See its docstring for details.

#### read(imap)

#### write(omap)

## fft - Fourier transforms

This is a convenience wrapper of pyfftw.

### _class_ pixell.fft.numpy_FFTW(a, b, axes=-1, direction='FFTW_FORWARD',
*args, **kwargs)

Minimal wrapper of numpy in order to be able to provide it as an engine. Not a
full-blown interface.

### _class_ pixell.fft.ducc_FFTW(a, b, axes=(-1,), direction='FFTW_FORWARD',
threads=1, *args, **kwargs)

Minimal wrapper of ducc in order to be able to provide it as an engine. Not a
full-blown interface.

#### do_dct(kind, *args, **kwargs)

### pixell.fft.numpy_empty_aligned(shape, dtype, n=None)

This dummy function just skips the alignment, since numpy doesn’t provide an
easy way to get it.

### _class_ pixell.fft.NumpyEngine

### _class_ pixell.fft.DuccEngine

### pixell.fft.set_engine(eng)

### pixell.fft.get_engine(eng)

### pixell.fft.fft(tod, ft=None, nthread=0, axes=[-1], flags=None,
_direction='FFTW_FORWARD', engine='auto')

Compute discrete fourier transform of tod, and store it in ft. What transform
to do (real or complex, number of dimension etc.) is determined from the size
and type of tod and ft. If ft is left out, a complex transform is assumed. The
optional nthread argument specifies the number of theads to use in the fft.
The default (0) uses the value specified by the OMP_NUM_THREAD environment
varible if that is specified, or the total number of cores on the computer
otherwise.

### pixell.fft.ifft(ft, tod=None, nthread=0, normalize=False, axes=[-1],
flags=None, engine='auto')

Compute inverse discrete fourier transform of ft, and store it in tod. What
transform to do (real or complex, number of dimension etc.) is determined from
the size and type of tod and ft. The optional nthread argument specifies the
number of theads to use in the fft. The default (0) uses the value specified
by the OMP_NUM_THREAD environment varible if that is specified, or the total
number of cores on the computer otherwise. By default this is not normalized,
meaning that fft followed by ifft will multiply the data by the length of the
transform. By specifying the normalize argument, you can turn normalization
on, though the normalization step will not use paralellization.

### pixell.fft.rfft(tod, ft=None, nthread=0, axes=[-1], flags=None,
engine='auto')

Equivalent to fft, except that if ft is not passed, it is allocated with
appropriate shape and data type for a real-to-complex transform.

### pixell.fft.irfft(ft, tod=None, n=None, nthread=0, normalize=False,
axes=[-1], flags=None, engine='auto')

Equivalent to ifft, except that if tod is not passed, it is allocated with
appropriate shape and data type for a complex-to-real transform. If n is
specified, that is used as the length of the last transform axis of the output
array. Otherwise, the length of this axis is computed assuming an even
original array.

### pixell.fft.dct(tod, dt=None, nthread=0, normalize=False, axes=[-1],
flags=None, type='DCT-I', engine='auto')

Compute discrete cosine transform of tod, and store it in dt. By default it
will do a DCT-I trasnform, but this can be controlled with the type argument.
Even the much less common discrete sine transforms are avialble by passing
e.g. type=”DST-I”. Valid values are DCT-I, DCT-II, DCT-III, DCT-IV, DST-I,
DST-II, DST-III and DST-IV, or the raw FFTW names the correspond to (e.g.
FFTW_REDFT00). If dt is not passed, it will be allocated with the same shape
and data type as tod.

The optional nthread argument specifies the number of theads to use in the
fft. The default (0) uses the value specified by the OMP_NUM_THREAD
environment varible if that is specified, or the total number of cores on the
computer otherwise.

Note that DCTs and DSTs were only added to pyfftw in version 13.0. The
function will fail with an Invalid scheme error for older versions.

### pixell.fft.idct(dt, tod=None, nthread=0, normalize=False, axes=[-1],
flags=None, type='DCT-I', engine='auto')

Compute the inverse discrete cosine transform of dt, and store it in tod. By
default it will do the inverse of a DCT-I trasnform, but this can be
controlled with the type argument. Even the much less common discrete sine
transforms are avialble by passing e.g. type=”DST-I”. Valid values are DCT-I,
DCT-II, DCT-III, DCT-IV, DST-I, DST-II, DST-III and DST-IV, or the raw FFTW
names the correspond to (e.g. FFTW_REDFT00). If tod is not passed, it will be
allocated with the same shape and data type as tod.

By the default an unnormalized transform is performed. Pass normalize=True to
get an actual inverse transform. This divides by a factor of 2*N+d for each
axis the transform is performed along, where N is the length of the axis and d
is -1 for DCT-1, +1 for DST-I and 0 for all the others. Usually it’s faster to
compute this factor once and combine it with other scalar factors in your math
than to let this function do it, which is why it’s turned off by default.

Note that this function already takes care of figuring out which transform is
the appropriate inverse. E.g. the inverse of b = dct(a, type=”DCT-II”) is
idct(b, type=”DCT-II”, normalize=True), not idct(b, type=”DCT-III”,
normalize=True) even though DCT-III is the inverse of DCT-II.

The optional nthread argument specifies the number of theads to use in the
fft. The default (0) uses the value specified by the OMP_NUM_THREAD
environment varible if that is specified, or the total number of cores on the
computer otherwise.

Note that DCTs and DSTs were only added to pyfftw in version 13.0. The
function will fail with an Invalid scheme error for older versions.

### pixell.fft.redft00(a, b=None, nthread=0, normalize=False, flags=None,
engine='auto')

Old brute-force work-around for missing dcts in pyfftw. Can be removed when
newer versions of pyfftw become common. It’s not very fast, sadly - about 5
times slower than an rfft. Transforms along the last axis.

### pixell.fft.chebt(a, b=None, nthread=0, flags=None, engine='auto')

The chebyshev transform of a, along its last dimension.

### pixell.fft.ichebt(a, b=None, nthread=0, engine='auto')

The inverse chebyshev transform of a, along its last dimension.

### pixell.fft.fft_len(n, direction='below', factors=None)

### pixell.fft.asfcarray(a)

### pixell.fft.empty(shape, dtype)

### pixell.fft.fftfreq(n, d=1.0, dtype=)

### pixell.fft.rfftfreq(n, d=1.0, dtype=)

### pixell.fft.ind2freq(n, i, d=1.0)

### pixell.fft.int2rfreq(n, i, d=1.0)

### pixell.fft.freq2ind(n, f, d=1.0)

### pixell.fft.rfreq2ind(n, f, d=1.0)

### pixell.fft.shift(a, shift, axes=None, nofft=False, deriv=None,
engine='auto')

Shift the array a by a (possibly fractional) number of samples “shift” to the
right, along the specified axis, which defaults to the last one. shift can
also be an array, in which case multiple axes are shifted together.

### pixell.fft.resample(a, n, axes=None, nthread=0, engine='auto')

Given an array a, resize the given axes (defaulting to the last ones) to
length n (tuple or int) using Fourier resampling. For example, if a has shape
(2,3,4), then resample(a, 10, -1) has shape (2,3,10), and resample(a, (20,10),
(0,2)) has shape (20,3,10).

### pixell.fft.resample_fft(fa, n, out=None, axes=-1, norm=1, op=>)

Given array fa[{dims}] which is the fourier transform of some array a,
transform it so that that it corresponds to the fourier transform of a version
of a with a different number of samples by padding or truncating the fourier
space. The argument n controls the new number of samples. By default this is
for the last axis, but this can be changed using the axes argument. Multiple
axes can be resampled at once by specifying a tuple for axes and n.

The resulting array is multiplied by the argument norm. This can be used for
normalization purposes. If norm is 1, then the multiplication is skipped.

The argument out can be used to specify an already allocated output array. If
it is None (the default), then an array will be allocated automatically.
Normally the output array is overwritten, but this can be controlled using the
op argument, which should be a function (out,fa)->out

### pixell.fft.interpol_nufft(a, inds, out=None, axes=None, normalize=True,
periodicity=None, epsilon=None, nthread=None, nofft=False, complex=False)

Given some array a[{pre},{dims}] interpolate it at the given
inds[len(dims),{post}], resulting in an output with shape [{pre},{post}]. The
signal is assumed to be periodic with the size of a unless this is overridden
with the periodicity argument, which should have an integer for each axis
being transformed. Normally the last ndim = len(inds) axes of a are
interpolated. This can be overridden with the axes argument.

By default the interpolation is properly normalized. This can be turned off
with the normalization argument, in which case the output will be too high by
a factor of np.prod([a.shape[ax] for ax in axes]). If all axes are used, this
simplifies to a.size

### pixell.fft.u2nu(fa, inds, out=None, axes=None, periodicity=None,
epsilon=None, nthread=None, normalize=False, forward=False, complex=True,
op=None)

Given complex fourier coefficients fa[{pre},{dims}] corresponding to some
real-space array a, evaluate the real-space signal at the given
inds[len(dims),{post}], resulting in a output with shape [{pre},{post}].

Arguments: * fa: Array of equi-spaced fourier coefficients. Complex with shape
[{pre},{dims}] * inds: Array of positions at which to evaluate the inverse
Fourier transform

> of fa. Real with shape [len(dims),{post}] * out: Array to write result to.
> Real or complex with shape [{pre},{post}]. : Optional. Allocated if missing.
> * axes: Tuple of axes to perform the transform along. len(axes)=len(dims). :
> Optional. Defaults to the last len(dims) axes. * periodicity: Periodicity
> assumed in the Fourier transform. Tuple with length : len(dims). Defaults to
> the shape of the axes being transformed. * epsilon: The target relative
> accuracy of the non-uniform FFT. Defaults : to 1e-5 for single precision and
> 1e-12 for double precision. See the ducc0.nufft documentation for details. *
> normalize: If True, the output is divided by prod([fa.shape[ax] for ax in
> axes]), : that is, the total number of elements in the transform. This
> normalization is equivalent to that of ifft. Defaults to False. * forward:
> Controls the sign of the exponent in the Fourier transform. By default : a
> backwards transform (fourier to real) is performed. By passing forward=True,
> you can instead regard fa as a real-sapce array and out as a non-equispaced
> Fourier array. * complex: Only relevant if out=None. Controls whether out is
> allocated as a : real or complex array. Defaults to complex.

### pixell.fft.nu2u(a, inds, out=None, oshape=None, axes=None,
periodicity=None, epsilon=None, nthread=None, normalize=False, forward=False)

### pixell.fft.iu2nu(a, inds, out=None, oshape=None, axes=None,
periodicity=None, epsilon=None, nthread=None, normalize=False, forward=False)

The inverse of nufft/u2nu. Given non-equispaced samples a[{pre},{post}] and
their coordinates inds[len(dims),{post}], calculates the equispaced Fourier
coefficients out[{pre},{dims}] of a.

Arguments: * a: Array of of non-equispaced values. Real or complex with shape
[{pre},{post}] * inds: Coordinates of samples in a. Real with shape
[len(dims),{post}]. * out: Equispaced Fourier coefficients of a. Complex with
shape [{pre},{dims}].

> Optional, but if missing, the shape of the out array to allocate must be
> specified using the oshape argument * oshape: Tuple giving the shape to use
> when allocating out (if it’s not passed in).

See u2nu for the meaning of the other arguments.

### pixell.fft.inu2u(fa, inds, out=None, axes=None, periodicity=None,
epsilon=None, nthread=None, normalize=False, forward=False, complex=True)

### pixell.fft.nufft(a, inds, out=None, oshape=None, axes=None,
periodicity=None, epsilon=None, nthread=None, normalize=False, flip=False)

Alias of iu2nu(…, forward=flip). This involves inverting a system with
conjugate gradients

### pixell.fft.inufft(fa, inds, out=None, axes=None, periodicity=None,
epsilon=None, nthread=None, normalize=False, flip=False, complex=True,
op=None)

Alias of u2nu(…, forward=flip)

### pixell.fft.nufft_adjoint(a, inds, out=None, oshape=None, axes=None,
periodicity=None, epsilon=None, nthread=None, normalize=False, flip=False)

Alias of nu2u(…, forward=not flip)

### pixell.fft.inufft_adjoint(fa, inds, out=None, axes=None, periodicity=None,
epsilon=None, nthread=None, normalize=False, flip=False, complex=True)

Alias of inu2u(…, forward=not flip). This involves inverting a system with
conjugate gradients

### _class_ pixell.fft.u2nu_plan(fa, axes, periodicity=None, epsilon=None,
nthread=None, normalize=False, forward=False, complex=True, op=None)

#### eval(inds, out=None)

### pixell.fft.fft_flat(tod, ft, nthread=1, axes=[-1], flags=None,
_direction='FFTW_FORWARD')

Workaround for intel FFTW wrapper. Flattens appropriate dimensions of intput
and output arrays to avoid crash that otherwise happens for arrays with ndim >
N + 1, where N is the dimension of the transform. If ‘axes’ correspond to the
last dimensions of the arrays, the workaround is essentially free. If axes
correspond to other axes, copies are made when reshaping the arrays.

### pixell.fft.ifft_flat(ft, tod, nthread=1, axes=[-1], flags=None)

Same workaround as fft_flat but now for the inverse transform.

## curvedsky - Curved-sky harmonic transforms

This module provides functions for taking into account the curvature of the
full sky.

### _exception_ pixell.curvedsky.ShapeError

### pixell.curvedsky.rand_map(shape, wcs, ps, lmax=None, dtype=, seed=None,
spin=[0, 2], method='auto', verbose=False)

Generates a CMB realization with the given power spectrum for an enmap with
the specified shape and WCS. This is identical to enlib.rand_map, except that
it takes into account the curvature of the full sky. This makes it much slower
and more memory-intensive. The map should not cross the poles.

### pixell.curvedsky.pad_spectrum(ps, lmax)

### pixell.curvedsky.rand_alm_healpy(ps, lmax=None, seed=None, dtype=)

### pixell.curvedsky.rand_alm(ps, ainfo=None, lmax=None, seed=None, dtype=,
m_major=True, return_ainfo=False)

This is a replacement for healpy.synalm. It generates the random numbers in
l-major order before transposing to m-major order in order to allow generation
of low-res and high-res maps that agree on large scales. It uses 2/3 of the
memory of healpy.synalm, and has comparable speed.

### pixell.curvedsky.alm2map(alm, map, spin=[0, 2], deriv=False,
adjoint=False, copy=False, method='auto', ainfo=None, verbose=False,
nthread=None, epsilon=1e-06, pix_tol=1e-06, locinfo=None, tweak=False)

Spherical harmonics synthesis. Transform from harmonic space to real space.

  * **Parameters:**
  * **alm** (_complex64_ _or_ _complex128 numpy array with shape_ _[_ _..._ _,__ncomp_ _,__nelem_ _]_ _,_) – [ncomp,nelem] or [nelem]. Spin transforms will be applied to the ncomp axis, controlled by the spin argument below.
  * **map** (_float32_ _or_ _float64 enmap with shape_ _[_ _..._ _,__ncomp_ _,__ny_ _,__nx_ _]_ _,_ _[__ncomp_ _,__ny_ _,__nx_ _]_) – or [ny,nx]. All but last two dimensions must match alm. Will be overwritten unless copy is True
  * **Options**
  * **\-------**
  * **spin** (_list_ _of_ _spins. These describe how to handle the_ _[__ncomp_ _]_ _axis._) – 0: scalar transform. Consumes one element in the component axis not 0: spin transform. Consumes two elements from the component axis. For example, if you have a TEB alm [3,nelem] and want to transform it to a TQU map [3,ny,nx], you would use spin=[0,2] to perform a scalar transform for the T component and a spin-2 transform for the Q,U components. Another example. If you had an alm [5,nelem] and map [5,ny,nx] and the first element was scalar, the next pair spin-1 and the next pair spin-2, you woudl use spin=[0,1,2]. default:[0,2]
  * **deriv** (_If true_ _,_ _instead calculates the d/ddec and d/dra derivatives_) – of the map corresponding to the alms. In this case the alm must have shape […,nelem] or [nelem] and the map must have shape […,2,ny,nx] or [2,ny,nx]. default: False
  * **adjoint** (_If true_ _,_ _instead calculates the adjoint_ _of_ _the_) – alm2map operation. This reads from map and writes to alm. default: False
  * **copy** (_If true_ _,_ _writes to a copy_ _of_ _map instead_ _of_ _overwriting the_) – map argument. The resulting map is returned.
  * **method** (_Select the spherical harmonics transform method:_) – 

“2d”: Use ducc’s “2d” transforms. These are fast and accurate, but : require
full-sky CAR maps with one of a limited set of pixel layouts (CC, F1, MW,
MWflip, DH, F2), see the ducc documentation. Maps with partial sky coverage
compatible with these pixelizations will be temporarily padded to full sky
before the transform. For other maps, this method will fail.

”cyl”: Use ducc’s standard transforms. These work for any cylindrical :
projection where pixels are equi-spaced and evenly divide the sky along each
horizontal line. Maps with partial sky coverage will be temporarily padded
horizontally as necessary.

”general”: Use ducc’s general transforms. These work for any pixelization, :
but are significantly more expensive, both in terms of time and memory.

”auto”: Automatically choose “2d”, “cyl” or “general”. This is the default., *
**ainfo** (_alm_info object containing information about the alm layout._) –
default: standard triangular layout, * **verbose** (_If True_ _,_ _prints
information about what's being done_) * **nthread** (_Number_ _of_ _threads to
use. Defaults to OMP_NUM_THREADS._) * **epsilon** (_The desired fractional
accuracy. Used for interpolation_) – in the “general” method. Default: 1e-6. *
**pix_tol** (_Tolerance for matching a pixel layout with a predefined one_
_,_) – in fractions of a pixel. Default: 1e-6. * **locinfo** (_Information
about the coordinates and validity_ _of_ _each pixel._) – Only relevant for
the “general” method. Computed via calc_locinfo if missing. If you’re doing
multiple transforms with the same geometry, you can speed things up by
precomputing this and passing it in here. * **Returns:** * _The resulting map.
This will be the same object as the map argument,_ * _or a copy if copy ==
True._

### pixell.curvedsky.alm2map_adjoint(map, alm=None, spin=[0, 2], deriv=False,
copy=False, method='auto', ainfo=None, verbose=False, nthread=None,
epsilon=None, pix_tol=1e-06, locinfo=None)

The adjoint of map2alm. Forwards to map2alm; see its docstring for details

### pixell.curvedsky.alm2map_pos(alm, pos=None, loc=None, ainfo=None,
map=None, spin=[0, 2], deriv=False, copy=False, verbose=False, adjoint=False,
nthread=None, epsilon=None)

Like alm2map, but operates directly on arbitrary positions instead of an
enmap. The positions are given either with the pos argument or the loc
argument.

> pos: [{dec,ra},…] in radians loc: […,{codec,ra}] in radians. codec is pi/2 -
> dec, ra must be positive

The underlying implementation uses loc, so if pos is passed an internal loc
will be built. See alm2map for the meaning of the other arguments.

### pixell.curvedsky.map2alm(map, alm=None, lmax=None, spin=[0, 2],
deriv=False, adjoint=False, copy=False, method='auto', ainfo=None,
verbose=False, nthread=None, niter=0, epsilon=None, pix_tol=1e-06,
weights=None, locinfo=None, tweak=False)

Spherical harmonics analysis. Transform from real space to harmonic space.

  * **Parameters:**
  * **map** (_float32_ _or_ _float64 enmap with shape_ _[_ _..._ _,__ncomp_ _,__ny_ _,__nx_ _]_ _,_ _[__ncomp_ _,__ny_ _,__nx_ _]_) – or [ny,nx]. All but last two dimensions must match alm.
  * **alm** (_complex64_ _or_ _complex128 numpy array with shape_ _[_ _..._ _,__ncomp_ _,__nelem_ _]_ _,_) – [ncomp,nelem] or [nelem]. Spin transforms will be applied to the ncomp axis, controlled by the spin argument below. Will be overwritten unless copy is True
  * **Options**
  * **\-------**
  * **spin** (_list_ _of_ _spins. These describe how to handle the_ _[__ncomp_ _]_ _axis._) – 0: scalar transform. Consumes one element in the component axis not 0: spin transform. Consumes two elements from the component axis. For example, if you have a TEB alm [3,nelem] and want to transform it to a TQU map [3,ny,nx], you would use spin=[0,2] to perform a scalar transform for the T component and a spin-2 transform for the Q,U components. Another example. If you had an alm [5,nelem] and map [5,ny,nx] and the first element was scalar, the next pair spin-1 and the next pair spin-2, you woudl use spin=[0,1,2]. default:[0,2]
  * **deriv** (_If true_ _,_ _instead calculates the d/ddec and d/dra derivatives_) – of the map corresponding to the alms. In this case the alm must have shape […,nelem] or [nelem] and the map must have shape […,2,ny,nx] or [2,ny,nx]. default: False
  * **adjoint** (_If true_ _,_ _instead calculates the adjoint_ _of_ _the_) – map2alm operation. This reads from alm and writes to map. default: False
  * **copy** (_If true_ _,_ _writes to a copy_ _of_ _map instead_ _of_ _overwriting the_) – map argument. The resulting map is returned.
  * **method** (_Select the spherical harmonics transform method:_) – 

“2d”: Use ducc’s “2d” transforms. These are fast and accurate, but : require
full-sky CAR maps with one of a limited set of pixel layouts (CC, F1, MW,
MWflip, DH, F2), see the ducc documentation. Maps with partial sky coverage
compatible with these pixelizations will be temporarily padded to full sky
before the transform. For other maps, this method will fail.

”cyl”: Use ducc’s standard transforms. These work for any cylindrical :
projection where pixels are equi-spaced and evenly divide the sky along each
horizontal line. Maps with partial sky coverage will be temporarily padded
horizontally as necessary.

”general”: Use ducc’s general transforms. These work for any pixelization, :
but are significantly more expensive, both in terms of time and memory.

”auto”: Automatically choose “2d”, “cyl” or “general”. This is the default., *
**ainfo** (_alm_info object containing information about the alm layout._) –
default: standard triangular layout, * **verbose** (_If True_ _,_ _prints
information about what's being done_) * **nthread** (_Number_ _of_ _threads to
use. Defaults to OMP_NUM_THREADS._) * **niter** (_The number_ _of_ _Jacobi
iteration steps to perform when_) – estimating the map2alm integral. Should
ideally be controlled via epsilon, but is manual for now. Only relevant for
the “cyl” and “general” methods. Time proportional to 1+2*niter. For a flat
spectrum, niter=0 typically results in std(alm-alm_true)/std(alm_true) ≈ 1e-5,
improving to 1e-8 by niter=3. Default: 0 * **epsilon** (_The desired
fractional accuracy. Used for interpolation_) – in the “general” method.
Default: 1e-6. * **pix_tol** (_Tolerance for matching a pixel layout with a
predefined one_ _,_) – in fractions of a pixel. Default: 1e-6. * **weights**
(_Integration weights to use. Only used for methods "cyl" and "general"._) –
Defaults to ducc’s grid weights if available, otherwise the pixel area.
Somewhat heavy to compute and store for the “general” method, so if you’re
performing multiple map2alm operations with the same geometry, consider
precomputing them and passing them with this argument. Must have the same
shape as locinfo.loc for the “general” method. * **locinfo** (_Information
about the coordinates and validity_ _of_ _each pixel._) – Only relevant for
the “general” method. Computed via calc_locinfo if missing. If you’re doing
multiple transforms with the same geometry, you can speed things up by
precomputing this and passing it in here. * **Returns:** * _The resulting alm.
This will be the same object as the alm argument,_ * _or a copy if copy ==
True._

### pixell.curvedsky.map2alm_adjoint(alm, map, lmax=None, spin=[0, 2],
deriv=False, copy=False, method='auto', ainfo=None, verbose=False,
nthread=None, niter=0, epsilon=1e-06, pix_tol=1e-06, weights=None,
locinfo=None)

The adjoint of alm2map. Forwards to map2alm. See its docstring for details

### pixell.curvedsky.alm2map_healpix(alm, healmap=None, spin=[0, 2],
deriv=False, adjoint=False, copy=False, ainfo=None, nside=None,
theta_min=None, theta_max=None, nthread=None)

Projects the given alm[…,ncomp,nalm] onto the given healpix map
healmap[…,ncomp,npix].

### pixell.curvedsky.map2alm_healpix(healmap, alm=None, ainfo=None, lmax=None,
spin=[0, 2], weights=None, deriv=False, copy=False, verbose=False,
adjoint=False, niter=0, theta_min=None, theta_max=None, nthread=None)

map2alm for healpix maps. Similar to healpy’s map2alm. See the map2alm
docstring for details.

### _class_ pixell.curvedsky.alm_info(lmax=None, mmax=None, nalm=None,
stride=1, layout='triangular')

#### _property_ nl

#### _property_ nm

#### lm2ind(l, m)

#### get_map()

Return the explicit [nelem,{l,m}] mapping this alm_info represents.

#### transpose_alm(alm, out=None)

In order to accomodate l-major ordering, which is not directly supported, this
function efficiently transposes Alm into Aml. If the out argument is
specified, the transposed result will be written there. In order to perform an
in-place transpose, call this function with the same array as “alm” and “out”.
If the out argument is not specified, then a new array will be constructed and
returned.

#### alm2cl(alm, alm2=None)

Computes the cross power spectrum for the given alm and alm2, which : must
have the same dtype and broadcast. For example, to get the TEB,TEB cross
spectra for a single map you would do  

> cl = ainfo.alm2cl(alm[:,None,:], alm[None,:,:])  
>  To get the same TEB,TEB spectra crossed with a different map it would be  
>  cl = ainfo.alm2cl(alm1[:,None,:], alm2[None,:,:])  
>  In both these cases the output will be [{T,E,B},{T,E,B},nl].

The returned cls start at ell=0.

#### lmul(alm, lmat, out=None)

Computes res[a,lm] = lmat[a,b,l]*alm[b,lm], where lm is the position of the
element with (l,m) in the alm array, as defined by this class.

### pixell.curvedsky.get_method(shape, wcs, minfo=None, pix_tol=1e-06)

Return which method map2alm and alm2map will use for the given enmap geometry.
Returns either “2d”, “cyl” or “general”.

### pixell.curvedsky.quad_weights(shape, wcs, pix_tol=1e-06)

Return the quadrature weights to use for map2alm operations for the given
geometry. Only valid for a limited number of cylindrical geometries recognized
by ducc. Returns weights[ny] where ny is shape[-2]. For cases where quadrature
weights aren’t available, it’s a pretty good approximation to just use the
pixel area.

### pixell.curvedsky.profile2harm(br, r, lmax=None, oversample=1, left=None,
right=None)

This is an alternative to healpy.beam2bl. In my tests it’s a bit more accurate
and about 3x faster, most of which is spent constructing the quadrature. It
does use some interpolation internally, though, so there might be cases where
it’s less accurate. Transforms the function br(r) to bl(l). br has shape
[…,nr], and the output will have shape […,nl]. Implemented using sharp SHTs
with one pixel per row and mmax=0. r is in radians and must be in ascending
order.

### pixell.curvedsky.harm2profile(bl, r)

The inverse of profile2beam or healpy.beam2bl. _Much_ faster than these (150x
faster in my test case). Should be exact too.

### pixell.curvedsky.prof2alm(profile, dir=[0, 1.5707963267948966], spin=0,
geometry='CC', nthread=None, norot=False)

Calculate the alms for a 1d equispaced profile[…,n] oriented along the given
[ra,dec] on the sky.

### pixell.curvedsky.npix2nside(npix)

### pixell.curvedsky.prepare_healmap(healmap, nside=None, pre=(), dtype=)

### pixell.curvedsky.apply_minfo_theta_lim(minfo, theta_min=None,
theta_max=None)

### pixell.curvedsky.fill_gauss(arr, bsize=65536)

### pixell.curvedsky.prepare_ps(ps, ainfo=None, lmax=None)

### pixell.curvedsky.rand_alm_white(ainfo, pre=None, alm=None, seed=None,
dtype=, m_major=True)

### pixell.curvedsky.almxfl(alm, lfilter=None, ainfo=None, out=None)

Filter alms isotropically. Unlike healpy (at time of writing), this function
allows leading dimensions in the alm, and also allows the filter to be
specified as a function instead of an array.

  * **Parameters:**
  * **alm** – (…,N) ndarray of spherical harmonic alms
  * **lfilter** – either an array containing the 1d filter to apply starting with ell=0
  * **delta_ell=1** (_and separated by_)
  * **the** (_or a function mapping multipole ell to_)
  * **expression.** (_filtering_)
  * **ainfo** – If ainfo is provided, it is an alm_info describing the layout
  * **itself.** (_of the input alm. Otherwise it will be inferred from the alm_)
  * **Returns:** The filtered alms a_{l,m} * lfilter(l)
  * **Return type:** falm

### pixell.curvedsky.filter(imap, lfilter, ainfo=None, lmax=None)

Filter a map isotropically by a function. Returns alm2map(map2alm(alm *
lfilt(ell),lmax))

  * **Parameters:**
  * **imap** – (…,Ny,Nx) ndmap stack of enmaps.
  * **lmax** – integer specifying maximum multipole beyond which the alms are zeroed
  * **lfilter** – either an array containing the 1d filter to apply starting with ell=0
  * **delta_ell=1** (_and separated by_)
  * **the** (_or a function mapping multipole ell to_)
  * **expression.** (_filtering_)
  * **ainfo** – If ainfo is provided, it is an alm_info describing the layout

of the input alm. Otherwise it will be inferred from the alm itself.

  * **Returns:** (…,Ny,Nx) ndmap stack of filtered enmaps
  * **Return type:** omap

### pixell.curvedsky.alm2cl(alm, alm2=None, ainfo=None)

Compute the power spectrum for alm, or if alm2 is given, the cross-spectrum
between alm and alm2, which must broadcast.

Some example usage, where the notation a[{x,y,z},n,m] specifies that the array
a has shape [3,n,m], and the 3 entries in the first axis should be interpreted
as x, y and z respectively.

  1. cl[nl] = alm2cl(alm[nalm]) This just computes the standard power spectrum of the given alm, resulting in a single 1d array.
  2. cl[nl] = alm2cl(alm1[nalm], alm2[nalm]) This compues the 1d cross-spectrum between the 1d alms alm1 and alm2.
  3. cl[{T,E,B},{T,E,B},nl] = alm2cl(alm[{T,E,B},None,nalm], alm[None,{T,E,B},nalm]) This computes the 3x3 polarization auto-spectrum for a 2d polarized alm.
  4. cl[{T,E,B},{T,E,B},nl] = alm2cl(alm1[{T,E,B},None,nalm], alm2[None,{T,E,B},nalm]) As above, but gives the 3x3 polarization cross-spectrum between two 2d alms.

The output is in the shape one would expect from numpy broadcasting. For
example, in the last example, the TE power spectrum would be found in cl[0,1],
and the ET power spectrum (which is different for the cross-spectrum case) is
in cl[1,0]. If a Healpix-style compressed spectrum is desired, use
pixell.powspec.sym_compress.

### pixell.curvedsky.rotate_alm(alm, psi, theta, phi, lmax=None,
method='auto', nthread=None, inplace=False)

Rotate the given alm[…,:] via the zyz rotations given by euler angles psi,
theta and phi. See curvedsky.euler_angs for some predefined angles. The
underlying implementation is provided by ducc0 or healpy. This is controlled
with the “method” argument, which can be “ducc0”, “healpy” or “auto”. For
“auto” it uses ducc0 if available, otherwise healpy. The resulting alm is
returned. If inplace=True, then the input alm will be modified in place (but
still returned). The number of threads to use is controlled with the nthread
argument. If this is 0 (the default), then the number of threads is given by
the value of the OMP_NUM_THREADS variable.

### pixell.curvedsky.transfer_alm(iainfo, ialm, oainfo, oalm=None, op=>)

Copy data from ialm with layout given by iainfo to oalm with layout given by
oainfo. If oalm is not passed, it will be allocated. In either case oalm is
returned. If op is specified, then it defines out oalm is updated: oalm =
op(ialm, oalm). For example, if op = lambda a,b:a+b, then ialm would be added
to oalm instead of overwriting it.

### pixell.curvedsky.alm2map_2d(alm, map, ainfo=None, minfo=None, spin=[0, 2],
deriv=False, copy=False, verbose=False, adjoint=False, nthread=None,
pix_tol=1e-06)

Helper function for alm2map. See its docstring for details

### pixell.curvedsky.alm2map_cyl(alm, map, ainfo=None, minfo=None, spin=[0,
2], deriv=False, copy=False, verbose=False, adjoint=False, nthread=None,
pix_tol=1e-06)

Helper function for alm2map. See its docstring for details

### pixell.curvedsky.alm2map_general(alm, map, ainfo=None, spin=[0, 2],
deriv=False, copy=False, verbose=False, adjoint=False, nthread=None,
locinfo=None, epsilon=None)

Helper function for alm2map. See its docstring for details

### pixell.curvedsky.map2alm_2d(map, alm=None, ainfo=None, minfo=None,
lmax=None, spin=[0, 2], deriv=False, copy=False, verbose=False, adjoint=False,
nthread=None, pix_tol=1e-06)

Helper function for map2alm. See its docsctring for details.

### pixell.curvedsky.map2alm_cyl(map, alm=None, ainfo=None, minfo=None,
lmax=None, spin=[0, 2], weights=None, deriv=False, copy=False, verbose=False,
adjoint=False, nthread=None, pix_tol=1e-06, niter=0)

Helper function for map2alm. See its docsctring for details.

### pixell.curvedsky.map2alm_general(map, alm=None, ainfo=None, minfo=None,
lmax=None, spin=[0, 2], weights=None, deriv=False, copy=False, verbose=False,
adjoint=False, nthread=None, locinfo=None, epsilon=None, niter=0)

Helper function for map2alm. See its docsctring for details.

### pixell.curvedsky.alm2map_raw_2d(alm, map, ainfo=None, spin=[0, 2],
deriv=False, copy=False, verbose=False, adjoint=False, nthread=None)

Helper function for alm2map_2d. Usually not called directly. See the alm2map
docstring for details.

### pixell.curvedsky.alm2map_raw_cyl(alm, map, ainfo=None, minfo=None,
spin=[0, 2], deriv=False, copy=False, verbose=False, adjoint=False,
nthread=None)

Helper function for alm2map_cyl. Usually not called directly. See the alm2map
docstring for details.

### pixell.curvedsky.alm2map_raw_general(alm, map, loc, ainfo=None, spin=[0,
2], deriv=False, copy=False, verbose=False, adjoint=False, nthread=None,
epsilon=None)

Helper function for alm2map_general. Usually not called directly. See the
alm2map docstring for details.

### pixell.curvedsky.map2alm_raw_2d(map, alm=None, ainfo=None, lmax=None,
spin=[0, 2], deriv=False, copy=False, verbose=False, adjoint=False,
nthread=None)

Helper function for map2alm_2d. Usually not called directly. See the map2alm
docstring for details.

### pixell.curvedsky.map2alm_raw_cyl(map, alm=None, ainfo=None, lmax=None,
spin=[0, 2], weights=None, deriv=False, copy=False, verbose=False,
adjoint=False, niter=0, nthread=None)

Helper function for map2alm_cyl. Usually not called directly. See the map2alm
docstring for details.

### pixell.curvedsky.map2alm_raw_general(map, loc, alm=None, ainfo=None,
lmax=None, spin=[0, 2], weights=None, deriv=False, copy=False, verbose=False,
adjoint=False, nthread=None, niter=0, epsilon=None)

Helper function for map2alm_general. Usually not called directly. See the
map2alm docstring for details.

### pixell.curvedsky.jacobi_inverse(forward, approx_backward, y, niter=0)

Given y = forward(x), attempt to recover x using jacobi iteration with forward
and it’s approximate inverse approx_backward. niter controls the number of
iterations. The number of calls to forward is niter. The number of calls to
approx_backward is 1+niter.

See minres_inverse for a function with faster convergence and better stopping
criterion. But Jacobi’s quick startup time often means it’s finished by the
time minres has gotten started, so unless high accuracy is needed, Jacobi
might be the best choice.

### pixell.curvedsky.minres_inverse(forward, approx_backward, y,
epsilon=1e-06, maxiter=100, zip=None, unzip=None, verbose=False)

Given y = forward(x), attempt to recover the maximum-likelihood solution of x
= (P’N”P)”P’N”P using Minres iteration. Here forward = P and approx_backward =
P’N”. Both of these should be functions that takes a single argument and
returns the result. Iterates until the desired accuracy given by epsilon is
reached, or the maximum number of iterations given by maxiter is reached. If
verbose is True, prints information about each step in the iteration.

This function converges more quickly than jacobi, and has a better defined
stopping criterion, but uses more memory and has a higher startup cost.
Effectively this function starts two iteration steps behind jacobi, and takes
several more steps to catch up. It is therefore not the fastest choice when
only moderate accuracy is needed.

### pixell.curvedsky.nalm2lmax(nalm)

### pixell.curvedsky.get_ring_info(shape, wcs, dtype=)

Return information about the horizontal rings of pixels in a cylindrical
pixelization. Used in map2alm and alm2map with the “cyl” method.

### pixell.curvedsky.get_ring_info_healpix(nside, rings=None)

### pixell.curvedsky.get_ring_info_radial(r)

Construct a ring info for a case where there’s just one pixel in each ring.
This is useful for radially symmetric (mmax=0) transforms.

### pixell.curvedsky.flip2slice(flips)

### pixell.curvedsky.flip_geometry(shape, wcs, flips)

### pixell.curvedsky.flip_array(arr, flips)

### pixell.curvedsky.pad_geometry(shape, wcs, pad)

### pixell.curvedsky.analyse_geometry(shape, wcs, tol=1e-06)

Pass in shape, wcs, and get out an info object that contains : case: : 2d: can
be passed directly to synthesis_2d cyl: can be passed directly to synthesis
partial: can be passed to synthesis after ring-extension,  
> or synthesis_2d after full extension  
general: only synthesis_general can be used  
flip: [flipy,flipx] bools. Only relevant for 2d and cyl. : partial always
needs slices, general never needs them.  
ducc_geo: Matching ducc geometry. Most useful member is .name, which : can be
“CC”, “F1”, “MW”, “MWflip” “DH”, “F2”. ducc_geo is None if this doesn’t
correspond to a ducc geometry.  
ypad: [npre,npost]. Only used when padding to 2d xpad: [npre,npost]. Used when
case==”partial”

### pixell.curvedsky.get_ducc_geo(wcs, shape=None, tol=1e-06)

Return the ducc geometry type for the given world coordinate system object.
Returns a bunch(name, phi0) where name is one of “CC”, “F1”, “MW”, “MWflip”,
“DH” and “F2”. “GL”: gauss-legendre is not supported by wcs. Returns None if
the wcs doesn’t correspond to a ducc geometry.

### pixell.curvedsky.get_ducc_maxlmax(name, ny)

### pixell.curvedsky.calc_locinfo(shape, wcs, bsize=1000)

Calculate pixel position info in the format ducc needs

### pixell.curvedsky.map2buffer(map, flip, pad, obuf=False)

Prepare a map for ducc operations by flipping and/or padding it, returning the
resulting map.

### pixell.curvedsky.buffer2map(map, flip, pad)

The inverse of map2buffer. Undoes flipping and padding

### pixell.curvedsky.prepare_alm(alm=None, ainfo=None, lmax=None, pre=(),
dtype=)

Set up alm and ainfo based on which ones of them are available.

### pixell.curvedsky.prepare_raw(alm, map, ainfo=None, lmax=None, deriv=False,
verbose=False, nthread=None, pixdims=2)

### pixell.curvedsky.dangerous_dtype(dtype)

## utils - General utilities

### _exception_ pixell.utils.DataError

### _exception_ pixell.utils.DataMissing

### pixell.utils.l2ang(l)

Compute the angular scale roughly corresponding to a given multipole. Based on
matching the number of alm degrees of freedom with map degrees of freedom.

### pixell.utils.ang2l(ang)

Compute the multipole roughly corresponding to a given angular scale. Based on
matching the number of alm degrees of freedom with map degrees of freedom.

### pixell.utils.D(f, eps=1e-10)

Clever derivative operator for function f(x) from Ivan Yashchuck. Accurate to
second order in eps. Only calls f(x) once to evaluate the derivative, but f
must accept complex arguments. Only works for real x. Example usage: D(lambda
x: x**4)(1) => 4.0

### pixell.utils.lines(file_or_fname)

Iterates over lines in a file, which can be specified either as a filename or
as a file object.

### pixell.utils.touch(fname)

### pixell.utils.listsplit(seq, elem)

Analogue of str.split for lists. listsplit([1,2,3,4,5,6,7],4) ->
[[1,2],[3,4,5,6]].

### pixell.utils.streq(x, s)

Check if x is the string s. This used to be simply “x is s”, but that now
causes a warning. One can’t just do “x == s”, as that causes a numpy warning
and will fail in the future.

### pixell.utils.find(array, vals, default=None)

Return the indices of each value of vals in the given array.

### pixell.utils.find_any(array, vals)

Like find, but skips missing entries

### pixell.utils.nearest_ind(arr, vals, sorted=False)

Given array arr and values vals, return the index of the entry in arr with
value closest to each entry in val

### pixell.utils.contains(array, vals)

Given an array[n], returns a boolean res[n], which is True for any element in
array that is also in vals, and False otherwise.

### pixell.utils.asfarray(arr, default_dtype=)

### pixell.utils.common_vals(arrs)

Given a list of arrays, returns their intersection. For example

> common_vals([[1,2,3,4,5],[2,4,6,8]]) -> [2,4]

### pixell.utils.common_inds(arrs)

Given a list of arrays, returns the indices into each of them of their common
elements. For example

> common_inds([[1,2,3,4,5],[2,4,6,8]]) -> [[1,3],[0,1]]

### pixell.utils.union(arrs)

Given a list of arrays, returns their union.

### pixell.utils.inverse_order(order)

If order represents a reordering of an array, such as that returned by
np.argsort, inverse_order(order) returns a new reordering that can be used to
recover the old one.

### Example

a = np.array([6,102,32,20,0,91,1910]]) order = np.argsort(a) print(a[order])
=> [0,6,20,32,91,102,1910] invorder = inverse_order(order)
print(a[order][inverse_order]) => [6,102,32,20,0,91,1910] # same as a

### pixell.utils.complement_inds(inds, n)

Given a subset of range(0,n), return the missing values. E.g.
complement_inds([0,2,4],7) => [1,3,5,6]

### pixell.utils.unmask(arr, mask, axis=0, fill=0)

Pseudoinverse of operation arr=result[mask]. That is, it undoes a numpy mask-
indexing operation, returning an array with the shape of mask. Values that
were not selected by mask in the first place will be filled with the fill
value.

### pixell.utils.dict_apply_listfun(dict, function)

Applies a function that transforms one list to another with the same number of
elements to the values in a dictionary, returning a new dictionary with the
same keys as the input dictionary, but the values given by the results of the
function acting on the input dictionary’s values. I.e. if f(x) = x[::-1], then
dict_apply_listfun({“a”:1,”b”:2},f) = {“a”:2,”b”:1}.

### pixell.utils.fallback(*args)

### pixell.utils.unwind(a, period=6.283185307179586, axes=[-1], ref=0,
refmode='left', mask_nan=False)

Given a list of angles or other cyclic coordinates where a and a+period have
the same physical meaning, make a continuous by removing any sudden jumps due
to period-wrapping. I.e. [0.07,0.02,6.25,6.20] would become
[0.07,0.02,-0.03,-0.08] with the default period of 2*pi.

### pixell.utils.rewind(a, ref=0, period=6.283185307179586)

Given a list of angles or other cyclic corodinates, add or subtract multiples
of the period in order to ensure that they all lie within the same period. The
ref argument specifies the angle furthest away from the cut, i.e. the period
cut will be at ref+period/2.

### pixell.utils.cumsplit(sizes, capacities)

Given a set of sizes (of files for example) and a set of capacities (of disks
for example), returns the index of the sizes for which each new capacity
becomes necessary, assuming sizes can be split across boundaries. For example
cumsplit([1,1,2,0,1,3,1],[3,2,5]) -> [2,5]

### pixell.utils.mask2range(mask)

Convert a binary mask [True,True,False,True,…] into a set of ranges
[:,{start,stop}].

### pixell.utils.repeat_filler(d, n)

Form an array n elements long by repeatedly concatenating d and d[::-1].

### pixell.utils.repeat(arr, n, axis=-1)

Repeat the array n times along the given axis. Example: repeat([0,1,2],2) →
[0,1,2,0,1,2]

### pixell.utils.deslope(d, w=1, inplace=False, axis=-1, avg=)

Remove a slope and mean from d, matching up the beginning and end of d. The w
parameter controls the number of samples from each end of d that is used to
determine the value to match up.

### pixell.utils.argmax(arr)

Multidimensional argmax. Returns a tuple indexing the full array instead of
just a number indexing the flattened array like np.argmax does

### pixell.utils.ctime2mjd(ctime)

Converts from unix time to modified julian date.

### pixell.utils.mjd2djd(mjd)

### pixell.utils.djd2mjd(djd)

### pixell.utils.mjd2jd(mjd)

### pixell.utils.jd2mjd(jd)

### pixell.utils.ctime2djd(ctime)

### pixell.utils.djd2ctime(djd)

### pixell.utils.ctime2jd(ctime)

### pixell.utils.jd2ctime(jd)

### pixell.utils.mjd2ctime(mjd)

Converts from modified julian date to unix time

### pixell.utils.medmean(x, axis=None, frac=0.5)

### pixell.utils.medmean2(x, axis=None, frac=0.1, bsize=None)

This is what medmean should have bean. This should be faster and have less
bias. Consider replacing medmean with this, as medmean doen’t seem to have
been used much

### pixell.utils.maskmed(arr, mask=None, axis=-1, maskval=0)

Median of array along the given axis, but ignoring entries with the given mask
value.

### pixell.utils.moveaxis(a, o, n)

### pixell.utils.moveaxes(a, old, new)

### pixell.utils.search(a, v, side='left')

Like np.searchsorted, but searches a[…,n] along the last axis for v[…] values,
returning the inds[…] values. Does not perform a binary search, so less
efficient on large arrays, but faster than my original idea of shoehorning the
arrays into a single monotonic array, since that would have required touching
all the values anyway.

### pixell.utils.weighted_quantile(map, ivar, quantile, axis=-1)

Multidimensional weighted quantile. Takes the given quantile (scalar) along
the given axis (default last axis) of the array “map”. Each element along the
axis is given weight from the corresponding element in “ivar”. This is based
on the weighted percentile method in
<https://en.wikipedia.org/wiki/Percentile>.

Arguments: map: The array to find quantiles for. Must broadcast with ivar
ivar: The weight array. Must broadcast with map quantiles: The quantiles to
evaluate. axis: The axis to take the quantiles along.

If post-broadcast map and ivar have shape A when excluding the quantile-axis
and quantile has shape B, then the result will have shape B+A.

### pixell.utils.weighted_median(map, ivar=1, axis=-1)

Compute the multidimensional weghted median. See weighted_quantile for details

### pixell.utils.partial_flatten(a, axes=[-1], pos=0)

Flatten all dimensions of a except those mentioned in axes, and put the
flattened one at the given position.

Example: if a.shape is [1,2,3,4], then partial_flatten(a,[-1],0).shape is
[6,4].

### pixell.utils.partial_expand(a, shape, axes=[-1], pos=0)

Undo a partial flatten. Shape is the shape of the original array before
flattening, and axes and pos should be the same as those passed to the flatten
operation.

### pixell.utils.addaxes(a, axes)

### pixell.utils.delaxes(a, axes)

### _class_ pixell.utils.flatview(array, axes=[], mode='rwc', pos=0)

Produce a read/writable flattened view of the given array, via with
flatview(arr) as farr:

> do stuff with farr

Changes to farr are propagated into the original array. Flattens all
dimensions of a except those mentioned in axes, and put the flattened one at
the given position.

### _class_ pixell.utils.nowarn

Use in with block to suppress warnings inside that block.

### pixell.utils.dedup(a)

Removes consecutive equal values from a 1d array, returning the result. The
original is not modified.

### pixell.utils.interpol(arr, inds, out=None, mode='spline',
border='nearest', order=3, cval=0.0, epsilon=None, ip=None)

Given an array arr[{x},{y}] and a list of float indices into a,
inds[len(y),{z}], returns interpolated values at these positions as [{x},{z}].

The mode and order arguments control the interpolation type. These can be: *
mode==”nn” or (mode==”spline” and order==0): Nearest neighbor interpolation *
mode==”lin” or (mode==”spline” and order==1): Linear interpolation *
mode==”cub” or (mode==”spline” and order==3): Cubic interpolation *
mode==”fourier”: Non-uniform fourier interpolation

The border argument controls the boundary condition. This does not apply for
fourier interpolation, which always assumes periodic boundary. Valid values
are: * “nearest”: Indices outside the array use the value from the nearest

> point on the edge. * “wrap”: Periodic boundary conditions * “mirror”:
> Mirrored boundary conditions * “constant”: Use a constant value, given by
> the cval argument

Epsilon controls the target relative accuracy of the interpolation. Only
applies to fourier interpolation. Spline interpolation is overall much less
accurate (assuming a band-limited true signal), and its accuracy can’t be
controlled, but roughly corresponds to 1e-3. Defaults to 1e-6 for single
precision and 1e-15 for double precision arrays.

Compatibility notes: * mask_nan is no longer supported. You must implement
this yourself

> if you need it. Do this something like : mask = ~np.isfinite(arr) out =
> interpol(arr, inds, …) omask= interpol(mask, inds, mode=”nn”) out[omask!=0]
> = np.nan * prefilter is no longer supported. This argument let the
> interpolation skip a heavy prefiltering step if the array was already
> filtered. This was useful, but assumed that the precomputed array was the
> same shape and data type as the array to be implemented, which is not the
> case for fourier interpolation. This functionality was replaced by
> interpolator objects returned by utils.interpolator, which are what’s used
> to implement this function.

### pixell.utils.interpolator(arr, npre=0, mode='spline', border='nearest',
order=3, cval=0.0, epsilon=None)

Construct an interpolator object that can be used to quickly interpolate many
positions in some array arr. Wrapper for the underlying SplineInterpolator and
FourierInterpolator classes. Used to implement the interpolate function. See
it for argument details.

### _class_ pixell.utils.SplineInterpolator(arr, npre=0, mode='spline',
border='nearest', order=3, cval=0.0)

#### prefiltered _= True_

### _class_ pixell.utils.FourierInterpolator(arr, npre=0, epsilon=None,
precompute='plan')

### pixell.utils.interp(x, xp, fp, left=None, right=None, period=None)

Unlike utils.interpol, this is a simple wrapper around np.interp that extends
it to support fp[…,n] instead of just fp[n]. It does this by looping over the
other dimensions in python, and calling np.interp for each entry in the pre-
dimensions. So this function does not save any time over doing that looping
manually, but it avoid typing this annoying loop over and over.

### pixell.utils.bin_multi(pix, shape, weights=None)

Simple multidimensional binning. Not very fast. Given pix[{coords},:] where
coords are indices into an array with shape shape, count the number of hits in
each pixel, returning map[shape].

### pixell.utils.bincount(pix, weights=None, minlength=0)

Like numpy.bincount, but allows pre-dimensions, which must broadcast

### pixell.utils.grid(box, shape, endpoint=True, axis=0, flat=False)

Given a bounding box[{from,to},ndim] and shape[ndim] in each direction,
returns an array [ndim,shape[0],shape[1],…] array of evenly spaced numbers. If
endpoint is True (default), then the end point is included. Otherwise, the
last sample is one step away from the end of the box. For one dimension, this
is similar to linspace:

> linspace(0,1,4) => [0.0000, 0.3333, 0.6667, 1.0000] grid([[0],[1]],[4]) =>
> [[0,0000, 0.3333, 0.6667, 1.0000]]

### pixell.utils.cumsum(a, endpoint=False, axis=None)

As numpy.cumsum for a 1d array a, but starts from 0. If endpoint is True, the
result will have one more element than the input, and the last element will be
the sum of the array. Otherwise (the default), it will have the same length as
the array, and the last element will be the sum of the first n-1 elements.

### pixell.utils.pixwin_1d(f, order=0)

Calculate the 1D pixel window for the dimensionless frequncy f corresponding
to a pixel spacing of 1 (so the Nyquist frequncy is 0.5). The order argument
controls the interpolation order to assume in the mapmaker. order = 0
corresponds to standard nearest-neighbor mapmking. order = 1 corresponds to
linear interpolation. For a multidimensional (e.g. 2d) image, the full pixel
window will be the outer product of this pixel window along each axis.

### pixell.utils.nearest_product(n, factors, direction='below')

Compute the highest product of positive integer powers of the specified
factors that is lower than or equal to n. This is done using a simple, O(n)
brute-force algorithm.

### pixell.utils.mkdir(path)

### pixell.utils.symlink(src, dest)

### pixell.utils.decomp_basis(basis, vec)

### pixell.utils.find_period(d, axis=-1)

### pixell.utils.find_period_fourier(d, axis=-1)

This is a simple second-order estimate of the period of the assumed-periodic
signal d. It finds the frequency with the highest power using an fft, and
partially compensates for nonperiodicity by taking a weighted mean of the
position of the top.

### pixell.utils.find_period_exact(d, guess)

### pixell.utils.find_sweeps(az, tol=0.2)

Given an array “az” that sweeps up and down between approximately constant
minimum and maximum values, returns an array sweeps[:,{i1,i2}], which gives
the start and end index of each such sweep. For example, if az starts at 0 at
sample 0, increases to 1 at sample 1000 and then falls to -1 at sample 2000,
increase to 1 at sample 2500 and then falls to 0.5 at sample 3000 where it
ends, then the function will return
[[0,1000],[1000,2000],[2000,2500],[2500,3000]]. The tol parameter determines
how close to the extremum values of the array it will look for turnarounds. It
shouldn’t normally need to be ajusted.

### pixell.utils.equal_split(weights, nbin)

Split weights into nbin bins such that the total weight in each bin is as
close to equal as possible. Returns a list of indices for each bin.

### pixell.utils.range_sub(a, b, mapping=False)

Given a set of ranges a[:,{from,to}] and b[:,{from,to}], return a new set of
ranges c[:,{from,to}] which corresponds to the ranges in a with those in b
removed. This might split individual ranges into multiple ones. If
mapping=True, two extra objects are returned. The first is a mapping from each
output range to the position in a it comes from. The second is a corresponding
mapping from the set of cut a and b range to indices into a and b, with b
indices being encoded as -i-1. a and b are assumed to be internally non-
overlapping.

Example: utils.range_sub([[0,100],[200,1000]], [[1,2],[3,4],[8,999]],
mapping=True) (array([[ 0, 1],

> [ 2, 3], [ 4, 8], [ 999, 1000]]),

array([0, 0, 0, 1]), array([ 0, -1, 1, -2, 2, -3, 3]))

The last array can be interpreted as: Moving along the number line, we first
encounter [0,1], which is a part of range 0 in c. We then encounter range 0 in
b ([1,2]), before we hit [2,3] which is part of range 1 in c. Then comes range
1 in b ([3,4]) followed by [4,8] which is part of range 2 in c, followed by
range 2 in b ([8,999]) and finally [999,1000] which is part of range 3 in c.

The same call without mapping: utils.range_sub([[0,100],[200,1000]],
[[1,2],[3,4],[8,999]]) array([[ 0, 1],

> [ 2, 3], [ 4, 8], [ 999, 1000]])

### pixell.utils.range_union(a, mapping=False)

Given a set of ranges a[:,{from,to}], return a new set where all overlapping
ranges have been merged, where to >= from. If mapping=True, then the mapping
from old to new ranges is also returned.

### pixell.utils.range_normalize(a)

Given a set of ranges a[:,{from,to}], normalize the ranges such that no ranges
are empty, and all ranges go in increasing order. Decreasing ranges are
interpreted the same way as in a slice, e.g. empty.

### pixell.utils.range_cut(a, c)

Cut range list a at positions given by c. For example
range_cut([[0,10],[20,100]],[0,2,7,30,200]) ->
[[0,2],[2,7],[7,10],[20,30],[30,100]].

### pixell.utils.compress_beam(sigma, phi)

### pixell.utils.expand_beam(irads, return_V=False)

### pixell.utils.combine_beams(irads_array)

### pixell.utils.regularize_beam(beam, cutoff=0.01, nl=None, normalize=False)

Given a beam transfer function beam[…,nl], replace small values with an
extrapolation that has the property that the ratio of any pair of such
regularized beams is constant in the extrapolated region.

### pixell.utils.read_lines(fname, col=0)

Read lines from file fname, returning them as a list of strings. If fname ends
with :slice, then the specified slice will be applied to the list before
returning.

### pixell.utils.loadtxt(fname)

As numpy.loadtxt, but allows slice syntax.

### pixell.utils.atleast_3d(a)

### pixell.utils.atleast_Nd(a, n)

Prepend length-1 dimensions to array a to make it n-dimensional

### pixell.utils.to_Nd(a, n, axis=0, return_inverse=False)

### pixell.utils.preflat(a, n)

Flatten the first n dimensions of a. If n is negative, flatten all but the
last -n dimensions.

### pixell.utils.postflat(a, n)

Flatten the last n dimensions of a. If n is negative, flatten all but the last
-n dimensions.

### pixell.utils.between_angles(a, range, period=6.283185307179586)

### pixell.utils.hasoff(val, off, tol=1e-06)

Return True if val’s deviation from an integer value equals off to the given
tolerance (default: 1e-6). Example. hasoff(17.3, 0.3) == True

### pixell.utils.same_array(a, b)

Returns true if a and b are the same array

### pixell.utils.fix_zero_strides(a)

Given an array a, return the same array with any zero-stride along an axis
with length one, such as those introduced by None-indexing, replaced with an
equivalent value

### pixell.utils.greedy_split(data, n=2, costfun=, workfun=>)

Given a list of elements data, return indices that would split them it into n
subsets such that cost is approximately minimized. costfun specifies which
cost to minimize, with the default being the value of the data themselves.
workfun specifies how to combine multiple values. workfun(datum,workval) =>
workval. scorefun then operates on a list of the total workval for each group
score = scorefun([workval,workval,….]).

Example: greedy_split(range(10)) => [[9,6,5,2,1,0],[8,7,4,3]] :
greedy_split([1,10,100]) => [[2],[1,0]] greedy_split(“012345”,costfun=lambda
x:sum([xi**2 for xi in x]),  

> workfun=lambda w,x:0 if x is None else int(x)+w) => [[5,2,1,0],[4,3]]

### pixell.utils.greedy_split_simple(data, n=2)

Split array “data” into n lists such that each list has approximately the same
sum, using a greedy algorithm.

### pixell.utils.cov2corr(C)

Scale rows and columns of C such that its diagonal becomes one. This produces
a correlation matrix from a covariance matrix. Returns the scaled matrix and
the square root of the original diagonal.

### pixell.utils.corr2cov(corr, std)

Given a matrix “corr” and an array “std”, return a version of corr with each
row and column scaled by the corresponding entry in std. This is the reverse
of cov2corr.

### pixell.utils.eigsort(A, nmax=None, merged=False)

Return the eigenvalue decomposition of the real, symmetric matrix A. The
eigenvalues will be sorted from largest to smallest. If nmax is specified,
only the nmax largest eigenvalues (and corresponding vectors) will be
returned. If merged is specified, E and V will not be returned separately.
Instead, Q=VE**0.5 will be returned, such that QQ’ = VEV’.

### pixell.utils.nodiag(A)

Returns matrix A with its diagonal set to zero.

### pixell.utils.date2ctime(dstr)

### pixell.utils.bounding_box(boxes)

Compute bounding box for a set of boxes [:,2,:], or a set of points [:,2]

### pixell.utils.unpackbits(a)

### pixell.utils.box2corners(box)

Given a [{from,to},:] bounding box, returns [ncorner,:] coordinates of of all
its corners.

### pixell.utils.box2contour(box, nperedge=5)

Given a [{from,to},:] bounding box, returns [npoint,:] coordinates definiting
its edges. Nperedge is the number of samples per edge of the box to use. For
nperedge=2 this is equal to box2corners. Nperegege can be a list, in which
case the number indicates the number to use in each dimension.

### pixell.utils.box_slice(a, b)

Given two boxes/boxarrays of shape [{from,to},dims] or [:,{from,to},dims],
compute the bounds of the part of each b that overlaps with each a, relative
to the corner of a. For example box_slice([[2,5],[10,10]],[[0,0],[5,7]]) ->
[[0,0],[3,2]].

### pixell.utils.box_area(a)

Compute the area of a [{from,to},ndim] box, or an array of such boxes.

### pixell.utils.box_overlap(a, b)

Given two boxes/boxarrays, compute the overlap of each box with each other
box, returning the area of the overlaps. If a is [2,ndim] and b is [2,ndim],
the result will be a single number. if a is [n,2,ndim] and b is [2,ndim], the
result will be a shape [n] array. If a is [n,2,ndim] and b is [m,2,ndim], the
result will’ be [n,m] areas.

### pixell.utils.widen_box(box, margin=0.001, relative=True)

### pixell.utils.pad_box(box, padding)

How I should have implemented widen_box from the beginning. Simply pads a box
by an absolute amount. The only complication is the sign stuff that handles
descending axes in the box.

### pixell.utils.unwrap_range(range, nwrap=6.283185307179586)

Given a logically ordered range[{from,to},…] that may have been exposed to
wrapping with period nwrap, undo the wrapping so that range[1] > range[0] but
range[1]-range[0] is as small as possible. Also makes the range straddle 0 if
possible.

Unlike unwind and rewind, this function will not turn a very wide range into a
small one because it doesn’t assume that ranges are shorter than half the sky.
But it still shortens ranges that are longer than a whole wrapping period.

### pixell.utils.sum_by_id(a, ids, axis=0)

### pixell.utils.pole_wrap(pos)

Given pos[{lat,lon},…], normalize coordinates so that lat is always between
-pi/2 and pi/2. Coordinates outside this range are mirrored around the poles,
and for each mirroring a phase of pi is added to lon.

### pixell.utils.allreduce(a, comm, op=None)

Convenience wrapper for Allreduce that returns the result rather than needing
an output argument.

### pixell.utils.reduce(a, comm, root=0, op=None)

### pixell.utils.allgather(a, comm)

Convenience wrapper for Allgather that returns the result rather than needing
an output argument.

### pixell.utils.allgatherv(a, comm, axis=0)

Perform an mpi allgatherv along the specified axis of the array a, returning
an array with the individual process arrays concatenated along that dimension.
For example allgatherv([[1,2]],comm) on one task and
allgatherv([[3,4],[5,6]],comm) on another task results in [[1,2],[3,4],[5,6]]
for both tasks.

### pixell.utils.send(a, comm, dest=0, tag=0)

Faster version of comm.send for numpy arrays. Avoids slow pickling. Used with
recv below.

### pixell.utils.recv(comm, source=0, tag=0)

Faster version of comm.recv for numpy arrays. Avoids slow pickling. Used with
send above.

### pixell.utils.tuplify(a)

### pixell.utils.resize_array(arr, size, axis=None, val=0)

Return a new array equal to arr but with the given axis reshaped to the given
sizes. Inserted elements will be set to val.

### pixell.utils.redistribute(iarrs, iboxes, oboxes, comm, wrap=0)

Given the array iarrs[[{pre},{dims}]] which represents slices
garr[…,narr,ibox[0,0]:ibox[0,1]:ibox[0,2],ibox[1,0]:ibox[1,1]:ibox[1,2],etc]
of some larger, distributed array garr, returns a different slice of the
global array given by obox.

### pixell.utils.sbox_intersect(a, b, wrap=0)

Given two Nd sboxes a,b […,ndim,{start,end,step}] into the same array, compute
an sbox representing their intersection. The resulting sbox will have positive
step size. The result is a possibly empty list of sboxes - it is empty if
there is no overlap. If wrap is specified, then it should be a list of length
ndim of pixel wraps, each of which can be zero to disable wrapping in that
direction.

### pixell.utils.sbox_intersect_1d(a, b, wrap=0)

Given two 1d sboxes into the same array, compute an sbox representing their
intersecting area. The resulting sbox will have positive step size. The result
is a list of intersection sboxes. This can be empty if there is no
intersection, such as between [0,n,2] and [1,n,2]. If wrap is not 0, then it
should be an integer at which pixels repeat, so i and i+wrap would be
equivalent. This can lead to more intersections than one would usually get.

### pixell.utils.sbox_div(a, b, wrap=0)

Find c such that arr[a] = arr[b][c].

### pixell.utils.sbox_mul(a, b)

Find c such that arr[c] = arr[a][b]

### pixell.utils.sbox_flip(sbox)

### pixell.utils.sbox2slice(sbox)

### pixell.utils.sbox_size(sbox)

Return the size […,n] of an sbox […,{start,end,step}]. The end must be a whole
multiple of step away from start, like as with the other sbox functions.

### pixell.utils.sbox_fix0(sbox)

### pixell.utils.sbox_fix(sbox)

### pixell.utils.sbox_wrap(sbox, wrap=0, cap=0)

“Given a single sbox […,{from,to,step?}] representing a slice of an N-dim
array, wraps and caps the sbox, returning a list of sboxes for each contiguous
section of the slice.

The wrap argument, which can be scalar or a length N array-like, indicates the
wrapping length along each dimension. Boxes that extend beyond the wrapping
length will be split into two at the wrapping position, with the overshooting
part wrapping around to the beginning of the array. The speical value 0
disables wrapping for that dimension.

The cap argument, which can also be a scalar or length N array-like, indicates
the physical length of each array dimension. The sboxes will be truncated to
avoid accessing any data beyond this length, after wrapping has been taken
into account.

The function returns a list of the form [(ibox1,obox1),(ibox2,obox2)…], where
the iboxes are sboxes representing slices into the input array (the array the
original sbox refers to), while the oboxes represent slices into the output
array. These sboxes can be turned into actual slices using sbox2slice.

A typical example of the use of this function would be a sky map that wraps
horizontally after 360 degrees, where one wants to support extracting subsets
that straddle the wrapping point.

### pixell.utils.gcd(a, b)

Greatest common divisor of a and b

### pixell.utils.lcm(a, b)

Least common multiple of a and b

### pixell.utils.uncat(a, lens)

Undo a concatenation operation. If a = np.concatenate(b) and lens = [len(x)
for x in b], then uncat(a,lens) returns b.

### pixell.utils.ang2rect(angs, zenith=False, axis=0)

Convert a set of angles [{phi,theta},…] to cartesian coordinates [{x,y,z},…].
If zenith is True, the theta angle will be taken to go from 0 to pi, and
measure the angle from the z axis. If zenith is False, then theta goes from
-pi/2 to pi/2, and measures the angle up from the xy plane.

### pixell.utils.rect2ang(rect, zenith=False, axis=0, return_r=False)

The inverse of ang2rect.

### pixell.utils.angdist(a, b, zenith=False, axis=0)

Compute the angular distance between a[{ra,dec},…] and b[{ra,dec},…] using a
Vincenty formula that’s stable both for small and large angular separations. a
and b must broadcast correctly.

### pixell.utils.vec_angdist(v1, v2, axis=0)

Use Kahan’s version of Heron’s formula to compute a stable angular distance
between to vectors v1 and v2, which don’t have to be unit vectors. See
<https://scicomp.stackexchange.com/a/27694>

### pixell.utils.rotmatrix(ang, raxis, axis=-1, dtype=None)

Construct a 3d rotation matrix representing a rotation of ang degrees around
the specified rotation axis raxis, which can be “x”, “y”, “z” or 0, 1, 2. If
ang is a scalar, the result will be [3,3]. Otherwise, it will be
ang.shape[:axis] + (3,3) + ang.shape[axis:]. Negative axis is interpreted as
ang.ndim+1+axis, such that the (3,3) part ends at the end for axis=-1

### pixell.utils.label_unique(a, axes=(), rtol=1e-05, atol=1e-08)

Given an array of values, return an array of labels such that all entries in
the array with the same label will have approximately the same value. Labels
count contiguously from 0 and up. axes specifies which axes make up the
subarray that should be compared for equality. For scalars, use axes=().

### pixell.utils.transpose_inds(inds, nrow, ncol)

Given a set of flattened indices into an array of shape (nrow,ncol), return
the indices of the corresponding elemens in a transposed array.

### pixell.utils.rescale(a, range=[0, 1])

Rescale a such that min(a),max(a) -> range[0],range[1]

### pixell.utils.split_by_group(a, start, end)

Split string a into non-group and group sections, where a group is defined as
a set of characters from a start character to a corresponding end character.

### pixell.utils.split_outside(a, sep, start='([{', end=')]}')

Split string a at occurences of separator sep, except when it occurs inside
matching groups of start and end characters.

### pixell.utils.find_equal_groups(a, tol=0)

Given a[nsamp,…], return groups[ngroup][{ind,ind,ind,…}] of indices into a for
which all the values in the second index of a is the same.
find_equal_groups([[0,1],[1,2],[0,1]]) -> [[0,2],[1]].

### pixell.utils.find_equal_groups_fast(vals)

Group 1d array vals[n] into equal groups. Returns uvals, order, edges Using
these, group #i is made up of the values with index
order[edges[i]:edges[i+1]], and all these elements correspond to value
uvals[i]. Accomplishes the same basic task as find_equal_groups, but 1\. Only
works on 1d arrays 2\. Only works with exact quality, with no support for
approximate equality 3\. Returns 3 numpy arrays instead of a list of lists.

### pixell.utils.label_multi(valss)

Given the argument valss[:][n], which is a list of 1d arrays of the same
length n but potentially different data types, return a single 1d array
labels[n] of integers such that unique lables correspond to unique valss[:].
More precisely, valss[:][labels[i]] == valss[:][labels[j]] only if labels[i]
== labels[j]. The purpose of this is to go from having a heterogenous label
like (1, “foo”, 1.24) to having a single integer as the label.

Example: label_multi([[0,0,1,1,2],[“a”,”b”,”b”,”b”,”b”]]) → [0,1,2,2,3]

### pixell.utils.pathsplit(path)

Like os.path.split, but for all components, not just the last one. Why did I
have to write this function? It should have been in os already!

### pixell.utils.minmax(a, axis=None)

Shortcut for np.array([np.min(a),np.max(a)]), since I do this a lot.

### pixell.utils.broadcast_shape(*shapes, at=0)

Return the shape resulting from broadcasting arrays with the given shapes.
“at” controls how new axes are added. at=0 adds them at the beginning, which
matches how numpy broadcasting works. at=1 would add them after the first
element, etc. -1 adds them at the end.

### pixell.utils.broadcast_arrays(*arrays, npre=0, npost=0, at=0)

Like np.broadcast_arrays, but allows arrays to be None, in which case they are
passed just passed through as None without affecting the rest of the
broadcasting. The argument npre specifies the number of dimensions at the
beginning of the arrays to exempt from broadcasting. This can be either an
integer or a list of integers.

### pixell.utils.point_in_polygon(points, polys)

Given a points[…,2] and a set of polys[…,nvertex,2], return inside[…].
points[…,0] and polys[…,0,0] must broadcast correctly.

Examples: utils.point_in_polygon([0.5,0.5],[[0,0],[0,1],[1,1],[1,0]]) -> True
utils.point_in_polygon([[0.5,0.5],[2,1]],[[0,0],[0,1],[1,1],[1,0]]) -> [True,
False]

### pixell.utils.poly_edge_dist(points, polygons)

Given points […,2] and a set of polygons […,nvertex,2], return dists[…], which
represents the distance of the points from the edges of the corresponding
polygons. This means that the interior of the polygon will not be 0.
points[…,0] and polys[…,0,0] must broadcast correctly.

### pixell.utils.block_mean_filter(a, width)

Perform a binwise smoothing of a, where all samples in each bin of the given
width are replaced by the mean of the samples in that bin.

### pixell.utils.block_reduce(a, bsize, axis=-1, off=0, op=, inclusive=True)

Replace each block of length bsize along the given axis of a with an aggregate
value given by the operation op. op must accept op(array, axis), just like
np.sum or np.mean. a need not have a whole number of blocks. In that case, the
last block will have fewer than bsize samples in it. If off is specified, it
gives an offset from the start of the array for the start of the first block;
anything before that will be treated as an incomplete block, just like
anything left over at the end. Pass the same value of off to block_expand to
undo this.

### pixell.utils.block_expand(a, bsize, osize, axis=-1, off=0, op='nearest',
inclusive=True)

The opposite of block_reduce. Where block_reduce averages (by default) this
function duplicates (by default) to recover the original shape. If
op=”linear”, then linear interpolation will be done instead of duplication.
NOTE: Currently axis and orr are not supported for linear interpolation, which
will always be done along the last axis.

### pixell.utils.ctime2date(timestamp, tzone=0, fmt='%Y-%m-%d')

### pixell.utils.tofinite(arr, val=0)

Return arr with all non-finite values replaced with val.

### pixell.utils.parse_ints(s)

### pixell.utils.parse_floats(s)

### pixell.utils.parse_numbers(s, dtype=None)

### pixell.utils.parse_box(desc)

Given a string of the form from:to,from:to,from:to,… returns an array
[{from,to},:]

### pixell.utils.triangle_wave(x, period=1)

Return a triangle wave with amplitude 1 and the given period.

### pixell.utils.calc_beam_area(beam_profile)

Calculate the beam area in steradians given a beam profile[{r,b},npoint]. r is
in radians, b should have a peak of 1..

### pixell.utils.planck(f, T=2.72548)

Return the Planck spectrum at the frequency f and temperature T in Jy/sr

### pixell.utils.blackbody(f, T=2.72548)

Return the Planck spectrum at the frequency f and temperature T in Jy/sr

### pixell.utils.iplanck_T(f, I)

The inverse of planck with respect to temperature

### pixell.utils.dplanck(f, T=2.72548)

The derivative of the planck spectrum with respect to temperature, evaluated
at frequencies f and temperature T, in units of Jy/sr/K.

### pixell.utils.graybody(f, T=10, beta=1)

Return a graybody spectrum at the frequency f and temperature T in Jy/sr

### pixell.utils.tsz_spectrum(f, T=2.72548)

The increase in flux due to tsz in Jy/sr per unit of y. This is just the first
order approximation, but it’s good enough for realistic values of y, i.e. y <<
1

### pixell.utils.flux_factor(beam_area, freq, T0=2.72548)

Compute the factor A that when multiplied with a linearized temperature
increment dT around T0 (in K) at the given frequency freq in Hz and integrated
over the given beam_area in steradians, produces the corresponding flux =
A*dT. This is useful for converting between point source amplitudes and point
source fluxes.

For uK to mJy use flux_factor(beam_area, freq)/1e3

### pixell.utils.noise_flux_factor(beam_area, freq, T0=2.72548)

Compute the factor A that converts from white noise level in K sqrt(steradian)
to uncertainty in Jy for the given beam area in steradians and frequency in
Hz. This assumes white noise and a gaussian beam, so that the area of the
real-space squared beam is just half that of the normal beam area.

For uK arcmin to mJy, use noise_flux_factor(beam_area, freq)*arcmin/1e3

### pixell.utils.gnfw(x, xc, alpha, beta, gamma)

### pixell.utils.tsz_profile_raw(x, xc=0.497, alpha=1.0, beta=-4.65,
gamma=-0.3)

Dimensionless radial (3d) cluster thermal pressure profile from
arxiv:1109.3711. That article used a different definition of beta, beta’ =
4.35 such that beta=gamma-alpha*beta’. I’ve translated it to follow the
standard gnfw formula here. The numbers correspond to z=0, and M200 = 1e14
solar masses. They change slightly with mass and significantly with distance.
But the further away they are, the smaller they get and the less the shape
matters, so these should be good defaults.

The full dimensions are this number times P0*G*M200*200*rho_cr(z)*f_b/(2*R200)
where P0=18.1 at z=0 and M200=1e14. To get the dimensionful electron pressure,
further scale by (2+2*Xh)/(3+5*Xh), where Xh=0.76 is the hydrogen fraction.
But if one is working in units of y, then the dimensionless version is enough.

x = r/R200. That is, it is the distance from the cluster center in units of
the radius inside which the mean density is 200x as high as the critical
density rho_c.

### pixell.utils.tsz_profile_los(x, xc=0.497, alpha=1.0, beta=-4.65,
gamma=-0.3, zmax=100000.0, npoint=100, x1=1e-08, x2=10000.0, _a=8, cache=None)

Fast, highly accurate approximate version of tsz_profile_los_exact.
Interpolates the exact function in log-log space, and caches the interpolator.
With the default settings, it’s accurate to better than 1e-5 up to at least x
= 10000, and building the interpolator takes about 25 ms. After that, each
evaluation takes 50-100 ns per data point. This makes it about 10000x faster
than tsz_profile_los_exact. See tsz_profile_raw for the units.

### pixell.utils.tsz_profile_los_exact(x, xc=0.497, alpha=1.0, beta=-4.65,
gamma=-0.3, zmax=100000.0, _a=8)

Line-of-sight integral of the cluster_pressure_profile. See tsz_profile_raw
for the meaning of the arguments. Slow due to the use of quad and the manual
looping this requires. Takes about 1 ms per data point. The argument _a
controls a change of variable used to improve the speed and accuracy of the
integral, and should not be necessary to change from the default value of 8.

See tsz_profile_raw for the units and how to scale it to something physical.
Without scaling, the profile has a peak of about 0.5 and a FWHM of about 0.12
with the default parameters.

Instead of using this function directly, consider using tsz_profile_los
instead. It’s 10000x faster and more than accurate enough.

### pixell.utils.tsz_tform(r200=0.0002908882086657216, l=None, lmax=40000,
xc=0.497, alpha=1.0, beta=-4.65, gamma=-0.3, zmax=100000.0)

Return the radial spherical harmonic coefficients b(l) of the tSZ profile with
the parameters xc, alpha, beta, gamma. Scale controls the angular size of the
profile on the sky. r200 is the cluster’s angular R200 size, in radians
(default=1 arcmin).

If l (which can be multidimensional) is specified, the tsz coefficients will
be evaluated at these ls. Otherwise l = np.arange(lmax+1) will be used.

The 2d-but-radially-symmetric fourier integral and cuspy nature of the tSZ
profile are both handled via a fast hankel transform.

### pixell.utils.edges2bins(edges)

### pixell.utils.bins2edges(bins)

### pixell.utils.linbin(n, nbin=None, nmin=None, bsize=None)

Given a number of points to bin and the number of approximately equal-sized
bins to generate, returns [nbin_out,{from,to}]. nbin_out may be smaller than
nbin. The nmin argument specifies the minimum number of points per bin, but it
is not implemented yet. nbin defaults to the square root of n if not
specified.

### pixell.utils.expbin(n, nbin=None, nmin=8, nmax=0)

Given a number of points to bin and the number of exponentially spaced bins to
generate, returns [nbin_out,{from,to}]. nbin_out may be smaller than nbin. The
nmin argument specifies the minimum number of points per bin. nbin defaults to
n**0.5

### pixell.utils.bin_data(bins, d, op=)

Bin the data d into the specified bins along the last dimension. The result
has shape d.shape[:-1] + (nbin,).

### pixell.utils.bin_expand(bins, bdata)

### pixell.utils.is_int_valued(a)

### pixell.utils.solve(A, b, axes=[-2, -1], masked=False)

Solve the linear system Ax=b along the specified axes for A, and axes[0] for
b. If masked is True, then entries where A00 along the given axes is zero will
be skipped.

### pixell.utils.eigpow(A, e, axes=[-2, -1], rlim=None, alim=None)

Compute the e’th power of the matrix A (or the last two axes of A for higher-
dimensional A) by exponentiating the eigenvalues. A should be real and
symmetric.

When e is not a positive integer, negative eigenvalues could result in a
complex result. To avoid this, negative eigenvalues are set to zero in this
case.

Also, when e is not positive, tiny eigenvalues dominated by numerical errors
can be blown up enough to drown out the well-measured ones. To avoid this,
eigenvalues smaller than 1e-13 for float64 or 1e-4 for float32 of the largest
one (rlim), or with an absolute value less than 2e-304 for float64 or 1e-34
for float32 (alim) are set to zero for negative e. Set alim and rlim to 0 to
disable this behavior.

### pixell.utils.build_conditional(ps, inds, axes=[0, 1])

Given some covariance matrix ps[n,n] describing a set of n Gaussian
distributed variables, and a set of indices inds[m] specifying which of these
variables are already known, return matrices A[n-m,m], cov[m,m] such that the
conditional distribution for the unknown variables is x_unknown ~ normal(A
x_known, cov). If ps has more than 2 dimensions, then the axes argument
indicates which dimensions contain the matrix.

Example:

C = np.array([[10,2,1],[2,8,1],[1,1,5]]) vknown =
np.linalg.cholesky(C[:1,:1]).dot(np.random.standard_normal(1)) A, cov =
lensing.build_conditional(C, v0) vrest = A.dot(vknown) +
np.linalg.cholesky(cov).dot(np.random_standard_normal(2))

vtot = np.concatenate([vknown,vrest]) should have the same distribution as a
sample drawn directly from the full C.

### pixell.utils.nint(a)

Return a rounded to the nearest integer, as an integer.

### pixell.utils.ceil(a)

Return a rounded to the next integer, as an integer.

### pixell.utils.floor(a)

Return a rounded to the previous integer, as an integer.

### pixell.utils.format_to_glob(format)

Given a printf format, construct a glob pattern that will match its outputs.
However, since globs are not very powerful, the resulting glob will be much
more premissive than the input format, and you will probably want to filter
the results further.

### pixell.utils.format_to_regex(format)

Given a printf format, construct a regex that will match its outputs.

### _class_ pixell.utils.Printer(level=1, prefix='')

#### write(desc, level, exact=False, newline=True, prepend='')

#### push(desc)

#### time(desc, level, exact=False, newline=True)

### pixell.utils.ndigit(num)

Returns the number of digits in non-negative number num

### pixell.utils.contains_any(a, bs)

Returns true if any of the strings in list bs are found in the string a

### pixell.utils.build_legendre(x, nmax)

### pixell.utils.build_cossin(x, nmax)

### pixell.utils.uvec(n, i, dtype=)

Return a vector with length n with all elements equal to zero except for the
i’th. Useful for unit vector bashing

### pixell.utils.ubash(Afun, n, idtype=, odtype=None)

Find the matrix representation Amat of linear operator Afun by repeatedly
applying it unit vectors with length n.

### pixell.utils.load_ascii_table(fname, desc, sep=None, dsep=None)

Load an ascii table with heterogeneous columns. fname: Path to file desc: whitespace-separated list of name:typechar pairs, or | for columns that are to be ignored. desc must cover every column present in the file

### pixell.utils.count_variable_basis(bases)

Counts from 0 and up through a variable-basis number, where each digit has a
different basis. For example, count_variable_basis([2,3]) would yield [0,0],
[0,1], [0,2], [1,0], [1,1], [1,2].

### pixell.utils.list_combination_iter(ilist)

Given a list of lists of values, yields every combination of one value from
each list.

### pixell.utils.expand_slice(sel, n, nowrap=False)

Expands defaults and negatives in a slice to their implied values. After this,
all entries of the slice are guaranteed to be present in their final form.
Note, doing this twice may result in odd results, so don’t send the result of
this into functions that expect an unexpanded slice. Might be replacable with
slice.indices().

### pixell.utils.split_slice(sel, ndims)

Splits a numpy-compatible slice “sel” into sub-slices sub[:], such that a[sel]
= s[sub[0]][:,sub[1]][:,:,sub[2]][…], This is useful when implementing arrays
with heterogeneous indices. Ndims indicates the number of indices to allocate
to each split, starting from the left. Also expands all ellipsis.

### pixell.utils.split_slice_simple(sel, ndims)

Helper function for split_slice. Splits a slice in the absence of ellipsis.

### pixell.utils.parse_slice(desc)

### pixell.utils.slice_downgrade(d, s, axis=-1)

Slice array d along the specified axis using the Slice s, but interpret the
step part of the slice as downgrading rather than skipping.

### pixell.utils.outer_stack(arrays)

Example. outer_stack([[1,2,3],[10,20]]) ->
[[[1,1],[2,2],[3,3]],[[10,20],[10,20],[10,2]]]

### pixell.utils.tform_to_profile(bl, theta, normalize=False)

Given the transform b(l) of a beam, evaluate its real space angular profile at
the given radii theta.

### pixell.utils.beam_transform_to_profile(bl, theta, normalize=False)

Given the transform b(l) of a beam, evaluate its real space angular profile at
the given radii theta.

### _class_ pixell.utils.RadialFourierTransform(lrange=None, rrange=None,
n=512, pad=256)

#### real2harm(rprof)

Perform a forward (real -> harmonic) transform, taking us from the provided
real-space radial profile rprof(r) to a harmonic-space profile lprof(l). rprof
can take two forms: 1\. A function rprof(r) that can be called to evalute the
profile at

> arbitrary points. 1\. An array rprof[self.r] that provides the profile
> evaluated at the points given by this object’s .r member.

The transform is done along the last axis of the profile. Returns
lprof[self.l]. This includes padding, which can be removed using self.unpad

#### harm2real(lprof)

Perform a backward (harmonic -> real) transform, taking us from the provided
harmonic-space radial profile lprof(l) to a real-space profile rprof(r). lprof
can take two forms: 1\. A function lprof(l) that can be called to evalute the
profile at

> arbitrary points. 1\. An array lprof[self.l] that provides the profile
> evaluated at the points given by this object’s .l member.

The transform is done along the last axis of the profile. Returns
rprof[self.r]. This includes padding, which can be removed using self.unpad

#### unpad(*arrs)

Remove the padding from arrays used by this object. The values in the padded
areas of the output of the transform have unreliable values, but they’re not
cropped automatically to allow for round-trip transforms. Example:

> r = unpad(r_padded) r, l, vals = unpad(r_padded, l_padded, vals_padded)

#### lind(l)

#### rind(r)

### pixell.utils.profile_to_tform_hankel(profile_fun, lmin=0.1,
lmax=10000000.0, n=512, pad=256)

Transform a radial profile given by the function profile_fun(r) to sperical
harmonic coefficients b(l) using a Hankel transform. This approach is good at
handling cuspy distributions due to using logarithmically spaced points. n
points from 10**logrange[0] to 10**logrange[1] will be used. Returns l, bl. l
will not be equi-spaced, so you may want to interpolate the results. Note that
unlike other similar functions in this module and the curvedsky module, this
function uses the flat sky approximation, so it should only be used for
profiles up to a few degrees in size.

### _class_ pixell.utils.FFTLog(xrange=None, krange=None, n=512, pad=0,
bias=0)

#### fft(a)

Perform a forward fft along the last axis of a, which must be sampled at the
points self.x

#### ifft(fa)

Perform an inverse fft along the last axis of a, which must be sampled at the
points self.k

#### unpad(*arrs)

Remove the padding from arrays used by this object. The values in the padded
areas of the output of the transform have unreliable values, but they’re not
cropped automatically to allow for round-trip transforms. Example:

> r = unpad(r_padded) r, l, vals = unpad(r_padded, l_padded, vals_padded)

### pixell.utils.fix_dtype_mpi4py(dtype)

Work around mpi4py bug, where it refuses to accept dtypes with endian info

### pixell.utils.native_dtype(dtype)

Return the native version of dtype. E.g. if the input is big-endian float32,
returns plain float32

### pixell.utils.decode_array_if_necessary(arr)

Given an arbitrary numpy array arr, decode it if it is of type S and we’re in
a version of python that doesn’t like that

### pixell.utils.encode_array_if_necessary(arr)

Given an arbitrary numpy array arr, encode it if it is of type S and we’re in
a version of python that doesn’t like that

### pixell.utils.chararray_slice(a, sel)

### pixell.utils.to_sexa(x)

Given a number in decimal degrees x, returns (sign,deg,min,sec). Given this x
can be reconstructed as sign*(deg+min/60+sec/3600).

### pixell.utils.from_sexa(sign, deg, min, sec)

Reconstruct a decimal number from the sexagesimal representation.

### pixell.utils.format_sexa(x, fmt='%(deg)+03d:%(min)02d:%(sec)06.2f')

### pixell.utils.jname(ra, dec,
fmt='J%(ra_H)02d%(ra_M)02d%(ra_S)02d%(dec_d)+02d%(dec_m)02d%(dec_s)02d',
tag=None, sep=' ')

Build a systematic object name for the given ra/dec in degrees. The format is
specified using the format string fmt. The default format string is
‘J%(ra_H)02d%(ra_M)02d%(ra_S)02d%(dec_d)+02d%(dec_m)02d%(dec_s)02d’. This is
not fully compliant with the IAU specification, but it’s what is used in ACT.
Formatting uses standard python string interpolation. The available variables
are ra: right ascension in decimal degrees dec: declination in decimal degrees
ra_d, ra_m, ra_s: sexagesimal degrees, arcmins and arcsecs of right ascensions
dec_d, dec_m, dec_s: sexagesimal degrees, arcmins and arcsecs of declination
ra_H, ra_M, ra_S: hours, minutes and seconds of right ascension dec_H, rec_M,
dec_S: hours, minutes and seconds of declination (doesn’t make much sense)

tag is prefixed to the format, with sep as the separator. This lets one prefix
the survey name without needing to rewrite the whole format string.

### pixell.utils.ang2chord(ang)

Converts from the angle between two points on a circle to the length of the
chord between them

### pixell.utils.chord2ang(chord)

Inverse of ang2chord.

### pixell.utils.crossmatch(pos1, pos2, rmax, mode='closest', coords='auto')

Find close matches between positions given by pos1[:,ndim] and pos2[:,ndim],
up to a maximum distance of rmax (in the same units as the positions).

The argument “coords” controls how the coordinates are interpreted. If it is
“cartesian”, then they are assumed to be cartesian coordinates. If it is
“radec” or “phitheta”, then the coordinates are assumed to be angles in
radians, which will be transformed to cartesian coordinates internally before
being used. “radec” is equator-based while “phitheta” is zenith-based. The
default, “auto”, will assume “radec” if ndim == 2, and “cartesian” otherwise.

It’s possible that multiple objects from the catalogs are within rmax of each
other. The “mode” argument controls how this is handled. mode == “all”:

> Returns a list of pairs of indices into the two lists, one for each pair of
> objects that are close enough to each other, regardless of the presence of
> any other matches. Any given object can be mentioned multiple times in this
> list.

mode == “closest”: : Like “all”, but only the closest time an index appears in
a pair is kept, the others are discarded.

mode == “first”: : Like “all”, but only the first time an index appears in a
pair is kept, the others are discarted. This can be useful if some objects
should be given higher priority than others. For example, one could sort pos1
and pos2 by brightness and then use mode == “first” to prefer bright objects
in the match.

### pixell.utils.real_dtype(dtype)

Return the closest real (non-complex) dtype for the given dtype

### pixell.utils.complex_dtype(dtype)

Return the closest complex dtype for the given dtype

### pixell.utils.ascomplex(arr)

### pixell.utils.astuple(num_or_list)

### pixell.utils.default_M(x)

### pixell.utils.default_dot(a, b)

### _class_ pixell.utils.CG(A, b, x0=None, M=, dot=, destroy_b=False)

A simple Preconditioner Conjugate gradients solver. Solves the equation system
Ax=b.

This improves on the one in scipy in several ways. It allows one to specify
one’s own dot product operator, which is necessary for handling distributed
degrees of freedom, where each mpi task only stores parts of the full
solution. It is also reentrant, meaning that one can do nested CG if
necessary.

#### step()

Take a single step in the iteration. Results in .x, .i and .err being updated.
To solve the system, call step() in a loop until you are satisfied with the
accuracy. The result can then be read off from .x.

#### save(fname)

Save the volatile internal parameters to hdf file fname. Useful for later
restoring cg iteration

#### load(fname)

Load the volatile internal parameters from the hdf file fname. Useful for
restoring a saved cg state, after first initializing the object normally.

### _class_ pixell.utils.Minres(A, b, x0=None, dot=)

A simple Minres solver. Solves the equation system Ax=b.

#### step()

Take a single step in the iteration. Results in .x, .i and .err being updated.
To solve the system, call step() in a loop until you are satisfied with the
accuracy. The result can then be read off from .x.

### pixell.utils.nditer(shape, axes=None)

Iterate over all multidimensional indices into an array with the given shape.
If axes is specified, then it should be a list of the axes in shape to iterate
over. The remaining axes will not be indexed (the yielded multi-index will
have slice(None) for those axes). The order the entries in axes does not
matter.

### pixell.utils.without_inds(a, inds)

Return a as a tuple with the given inds removed. Not optimized for long arrays

### pixell.utils.only_inds(a, inds)

Return a as a tuple with only the given inds present. Not optimized for long
arrays

### pixell.utils.first_importable(*args)

Given a list of module names, return the name of the first one that can be
imported.

### pixell.utils.glob(desc)

Like glob.glob, but without nullglob turned on. This is useful for not just
silently throwing away arguments with spelling mistakes.

### pixell.utils.cache_get(cache, key, op)

### pixell.utils.replace(istr, ipat, repl)

### pixell.utils.regreplace(istr, ipat, repl, count=0, flags=0)

### pixell.utils.remove_nan(a)

Sets nans and infs to 0 in an array in-place. Should have no memory overhead.
Also returns the array for convenience.

### pixell.utils.without_nan(a)

Returns a copy of a with nans and infs set to 0. The original array is not
modified.

### pixell.utils.primes(n)

Simple prime factorization of the positive integer n. Uses the brute force
algorithm, but it’s quite fast even for huge numbers.

### pixell.utils.res2nside(res)

### pixell.utils.nside2res(nside)

### pixell.utils.split_esc(string, delim, esc='\\\')

Split string by the delimiter except when escaped by the given escape
character, which defaults to backslash. Consumes one level of escapes. Yields
the tokens one by one as an iterator.

### pixell.utils.getenv(name, default=None)

Return the value of the named environment variable, or default if it’s not set

### pixell.utils.setenv(name, value, keep=False)

Set the named environment variable to the given value. If keep==False (the
default), existing values are overwritten. If the value is None, then it’s
deleted from the environment. If keep==True, then this function does nothing
if the variable already has a value.

### pixell.utils.getaddr(a)

Get the address of the start of a

### pixell.utils.iscontig(a, naxes=None)

Return whether array a is C-contiguous. If naxes is specified, then only the
last naxes axes need to be contiguous, and axes before that are ignored.

### pixell.utils.zip2(*args)

Variant of python’s zip that calls next() the same number of times on all
arguments. This means that it doesn’t give up immediately after getting the
first StopIteration exception, but continues on until the end of the row. This
can be useful for iterators that want to do cleanup after hte last yield.

### pixell.utils.call_help(fun, *args, **kwargs)

### pixell.utils.arg_help(arg)

### pixell.utils.dicedist(N, D)

Calculate the distribution of the dice roll NdD

### pixell.utils.distpow(dist, N)

Given discrete probability distribution dist[:], calculate its N’th
convolution with itself

### pixell.utils.airy(x)

Dimensionless real-space representation of Airy beam, normalized to peak at 1.
To get the airy beam an angular distance r from the center for a telescope
with aperture diameter D at wavelength λ, use airy(sin(r)/2*(2*pi*D/λ)). This
beam has an FWHM in terms of x of 3.2326799. So for small beams, FWHM =
3.2326799 λ/(D*pi) radians. This works out to quite a bit smaller than our
beam, though. E.g. 1.17 arcmin where I expected 1.4 arcmin.

### pixell.utils.lairy(x)

This is the harmonic space representation of an Airy beam. To get the airy
beam at multipole l for a telescope with aperture diameter D at wavelength λ,
call lairy(l/(2*pi*D/λ)). Valid as long as the beam is small compared to the
curvature of the sky.

Multiply the result by airy_area(D,λ) if you want the harmonic space
representation of an Airy beam with a real-space peak of one.

### pixell.utils.airy_lmax(D, λ)

### pixell.utils.airy_area(D, λ)

Area (steradians) of airy beam for an aperture of size D and wavelength λ.
This is simply (2λ/D)²/π

### pixell.utils.disk_overlap(d, R)

Area of overlap between two disks with radius R and distance d between their
centers.

### pixell.utils.disk_overlap_curved(d, R, tol_flat=0.0001, tol_tiny=1e-10)

Solid angle of overlap between two disks with radius R and distance d between
their centers, on the sphere. I thought this would be useful for calculating
the curved-sky equivalent for the airy beam, but it seems it won’t. Oh well,
it was hard to calculate, so here it is anyway.

The actual curved-sky airy beam would start from

> airy(r) =
>
> `int_`
>
> -R^R dx √(R²-x²) exp(2πiux/λ)

where u = cos(θ) and θ is the angle from the center of the beam. This should
hold up to an angle of π/2 away from the center. After that the aperture is
mostly obscured, and a new expression will be needed, if it’s not zero.

I think this is actually what I’ve implemented in airy(x) above, as long as
one uses sin when calling it.

### pixell.utils.infer_bin_edges(centers, ref=1)

Given a list of bin centers[n], returns the corresponding bin edges[n+1] such
that centers=0.5*(edges[:-1]+edges[1:]). Since the system is underdetermined,
an extra assumption is needed. This function assumes that the two consecutive
bins starting at index “ref” have equal width. The default, 1, means that the
2nd and 3rd bins are assumed to have equal width. This was chosen because the
first bin often doesn’t follow the same pattern as the others.

## reproject - Map reprojection

### pixell.reproject.thumbnails(imap, coords, r=0.001454441043328608,
res=None, proj=None, apod=0.0005817764173314432, method='mixed', order=3,
oversample=4, pol=None, oshape=None, owcs=None, extensive=False,
verbose=False, filter=None, pixwin=False, pixwin_order=0)

Given an enmap […,ny,nx] and a set of coordinates in a numpy array coords with
shape (n,2) and ordering [n,{dec,ra}], extract a set of thumbnail images
[n,…,thumby,thumbx] centered on each set of coordinates, where n is the number
of images. When proj is ‘tan’, each of these thumbnail images is projected
onto a local tangent plane, removing the effect of size and shape distortions
in the input map.

If oshape, owcs are specified, then the thumbnails will have this geometry,
which should be centered on [0,0]. Otherwise, a geometry with the given
projection (defaults to “tan” = gnomonic projection) will be constructed,
going up to a maximum radius of r. FIXME: Defaults to “car” instead while
enmap.pixsizemap is buggy for non-cylindrical projections.

The reprojection involved in this operation implies interpolation. The default
is to use fft rescaling to oversample the input pixels by the given pixel, and
then use bicubic spline interpolation to read off the values at the output
pixel centers. The fft oversampling can be controlled with the oversample
argument. Values <= 1 turns this off. The other interpolation step is
controlled using the “order” argument. 0/1/3 corresponds to nearest neighbor,
bilinear and bicubic spline interpolation respectively.

If pol == True, then Q,U will be rotated to take into account the change in
the local northward direction impled in the reprojection. The default is to do
polarization rotation automatically if the input map has a compatible shape,
e.g. at least 3 axes and a length of 3 for the 3rd last one. TODO: I haven’t
tested this yet.

If extensive == True (not the default), then the map is assumed to contain an
extensive field rather than an intensive one. An extensive field is one where
the values in the pixels depend on the size of the pixel. For example, if the
inverse variance in the map is given per pixel, then this ivar map will be
extensive, but if it’s given in units of inverse variance per square arcmin
then it’s intensive.

For reprojecting inverse variance maps, consider using the wrapper
thumbnails_ivar, which makes it easier to avoid common pitfalls.

If pixwin is True, the pixel window will be deconvolved.

### pixell.reproject.thumbnails_ivar(imap, coords, r=0.001454441043328608,
res=None, proj=None, oshape=None, owcs=None, order=1, extensive=True,
verbose=False)

Like thumbnails, but for hitcounts, ivars, masks, and other quantities that
should stay positive and local. Remember to set extensive to True if you have
an extensive quantity, i.e. if the values in each pixel would go up if
multiple pixels combined. An example of this is a hitcount map or ivar per
pixel. Conversely, if you have an intensive quantity like ivar per arcmin you
should set extensive=False.

### pixell.reproject.map2healpix(imap, nside=None, lmax=None, out=None,
rot=None, spin=[0, 2], method='harm', order=1, extensive=False, bsize=100000,
nside_mode='pow2', boundary='constant', verbose=False, niter=0)

Reproject from an enmap to healpix, optionally including a rotation.

imap: The input enmap[…,ny,nx]. Stokes along the -3rd axis if : present.

nside: The nside of the healpix map to generate. Not used if : an output map
is passed. Otherwise defaults to the same resolution as the input map.

lmax: The highest multipole to use in any harmonic-space : operations.
Defaults to the input maps’ Nyquist limit.

out: An optional array […,npix] to write the output map to. : The … part must
match the input map, as must the data type.

rot: An optional coordinate rotation to apply. Either a string : “isys,osys”,
where isys is the system to transform from, and osys is the system to
transform to. Currently the values “cel”/”equ” and “gal” are recognized.
Alternatively, a tuple of 3 euler zyz euler angles can be passed, in the same
convention as healpy.rotate_alm.

spin: A description of the spin of the entries along the stokes : axis.
Defaults to [0,2], which means that the first entry is spin-0, followed by a
spin-2 pair (any non-zero spin covers a pair of entries). If the axis is
longer than what’s covered in the description, then it is repeated as
necessary. Pass spin=[0] to disable any special treatment of this axis.

method: How to interpolate between the input and output : pixelizations. Can
be “harm” (default) or “spline”. “harm” maps between them using spherical
harmonics transforms. This preserves the power spectrum (so no window function
is introduced), and averages noise down when the output pixels are larger than
the input pixels. However, it can suffer from ringing around very bright
features, and an all-positive input map may end up with small negative values.
“spline” instead uses spline interpolation to look up the value in the intput
map corresponding to each pixel center in the output map. The spline order is
controlled with the “order” argument. Overall “harm” is best suited for normal
sky maps, while “spline” with order = 0 or 1 is best suited for hitcount maps
and masks.

order: The spline order to use when method=”spline”. : 0 corresponds to
nearest neighbor interpolation. 1 corresponds to bilinear interpolation
(default) 3 corresponds to bicubic spline interpolation. 0 and 1 are local and
do not introduce values outside the input range, but introduce some aliasing
and loss of power. 3 has less power loss, but still non-zero, and is
vulnerable to ringing.

extensive: Whether the map represents an extensive (as opposed to : intensive)
quantity. Extensive quantities have values proportional to the pixel size,
unlike intensive quantities. Hitcount per pixel is an extensive quantity.
Hitcount per square degree is an intensive quantity, as is a temperature map.
Defaults to False.

bsize: The spline method operates on batches of pixels to save memory. : This
controls the batch size, in pixels. Defaults to 100000.

nside_mode: Controls which restrictions apply to nside in the case where : it
has to be inferred automatically. Can be “pow2”, “mul32” and “any”. “pow2”,
the default, results in nside being a power of two, as required by the healpix
standard. “mul32” relaxes this requirement, making a map where nside is a
multiple of 32. This is compatible with most healpix operations, but not with
ud_grade or the nest pixel ordering. “any” allows for any integer nside.

boundary: The boundary conditions assumed for the input map when :
method=”spline”. Defaults to “constant”, which assumes that anything outsize
the map has a constant value of 0. Another useful value is “wrap”, which
assumes that the right side wraps over to the left, and the top to the bottom.
See scipy.ndimage.distance_transform’s documentation for other, less useful
values. method=”harm” always assumes “constant” regardless of this setting.

verbose: Whether to print information about what it’s doing. : Defaults to
False, which doesn’t print anything.

Typical usage: * map_healpix = map2healpix(map, rot=”cel,gal”) * ivar_healpix
= map2healpix(ivar, rot=”cel,gal”, method=”spline”, spin=[0], extensive=True)

### pixell.reproject.healpix2map(iheal, shape=None, wcs=None, lmax=None,
out=None, rot=None, spin=[0, 2], method='harm', order=1, extensive=False,
bsize=100000, verbose=False, niter=0)

Reproject from healpix to an enmap, optionally including a rotation.

iheal: The input healpix map […,npix]. Stokes along the -2nd axis if :
present.

shape: The (…,ny,nx) shape of the output map. Only the last two entries : are
used, the rest of the dimensions are taken from iheal. Mandatory unless an
output map is passed.

wcs : Mandatory unless an output map is passed.

lmax: The highest multipole to use in any harmonic-space : operations.
Defaults to 3 times the nside of iheal.

out: An optional enmap […,ny,nx] to write the output map to. : The … part must
match iheal, as must the data type.

rot: An optional coordinate rotation to apply. Either a string : “isys,osys”,
where isys is the system to transform from, and osys is the system to
transform to. Currently the values “cel”/”equ” and “gal” are recognized.
Alternatively, a tuple of 3 euler zyz euler angles can be passed, in the same
convention as healpy.rotate_alm.

spin: A description of the spin of the entries along the stokes : axis.
Defaults to [0,2], which means that the first entry is spin-0, followed by a
spin-2 pair (any non-zero spin covers a pair of entries). If the axis is
longer than what’s covered in the description, then it is repeated as
necessary. Pass spin=[0] to disable any special treatment of this axis.

method: How to interpolate between the input and output : pixelizations. Can
be “harm” (default) or “spline”. “harm” maps between them using spherical
harmonics transforms. This preserves the power spectrum (so no window function
is introduced), and averages noise down when the output pixels are larger than
the input pixels. However, it can suffer from ringing around very bright
features, and an all-positive input map may end up with small negative values.
“spline” instead uses spline interpolation to look up the value in the intput
map corresponding to each pixel center in the output map. The spline order is
controlled with the “order” argument. Overall “harm” is best suited for normal
sky maps, while “spline” with order = 0 or 1 is best suited for hitcount maps
and masks.

order: The spline order to use when method=”spline”. : 0 corresponds to
nearest neighbor interpolation. 1 corresponds to bilinear interpolation
(default) Higher order interpolation is not supported - use method=”harm” for
that.

extensive: Whether the map represents an extensive (as opposed to : intensive)
quantity. Extensive quantities have values proportional to the pixel size,
unlike intensive quantities. Hitcount per pixel is an extensive quantity.
Hitcount per square degree is an intensive quantity, as is a temperature map.
Defaults to False.

bsize: The spline method operates on batches of pixels to save memory. : This
controls the batch size, in pixels. Defaults to 100000.

verbose: Whether to print information about what it’s doing. : Defaults to
False, which doesn’t print anything.

Typical usage: * map = healpix2map(map_healpix, shape, wcs, rot=”gal,cel”) *
ivar = healpix2map(ivar_healpix, shape, wcs, rot=”gal,cel”, method=”spline”,
spin=[0], extensive=True)

### pixell.reproject.rot2euler(rot)

Given a coordinate rotation description, return the [rotz,roty,rotz] euler
angles it corresponds to. The rotation desciption can either be those angles
directly, or a string of the form isys,osys

### pixell.reproject.inv_euler(euler)

### pixell.reproject.restrict_nside(nside, mode='mul32', round='ceil')

Given an arbitrary Healpix nside, return one that’s restricted in various ways
according to the “mode” argument:

“pow2”: Restrict to a power of 2. This is required for compatibility : with
the rarely used “nest” pixel ordering in Healpix, and is the standard in the
Healpix world.

“mul32”: Restrict to multiple of 32, unless 12*nside**2<=1024. : This is
enough to make the maps writable by healpy.

“any”: No restriction

The “round” argument controls how any rounding is done. This can be one of the
strings “ceil” (default), “round” or “floor”, or you can pass in a custom
function(nside) -> nside.

In all cases, the final nside is converted to an integer and capped to 1
below.

### pixell.reproject.centered_map(imap, res, box=None, pixbox=None,
proj='car', rpix=None, width=None, height=None, width_multiplier=1.0,
rotate_pol=True, **kwargs)

### pixell.reproject.healpix_from_enmap_interp(imap, **kwargs)

### pixell.reproject.healpix_from_enmap(imap, lmax, nside)

### pixell.reproject.enmap_from_healpix(hp_map, shape, wcs, ncomp=1, unit=1,
lmax=0, rot='gal,equ', first=0, is_alm=False, return_alm=False, f_ell=None)

### pixell.reproject.enmap_from_healpix_interp(hp_map, shape, wcs,
rot='gal,equ', interpolate=False)

### pixell.reproject.ivar_hp_to_cyl(hmap, shape, wcs, rot=False, do_mask=True,
extensive=True)

### pixell.reproject.gnomonic_pole_wcs(shape, res)

### pixell.reproject.gnomonic_pole_geometry(width, res, height=None)

### pixell.reproject.rotate_map(imap, shape_target=None, wcs_target=None,
shape_source=None, wcs_source=None, pix_target=None, **kwargs)

### pixell.reproject.get_rotated_pixels(shape_source, wcs_source,
shape_target, wcs_target, inverse=False, pos_target=None, center_target=None,
center_source=None)

### pixell.reproject.cutout(imap, width=None, ra=None, dec=None, pad=1,
corner=False, res=None, npix=None, return_slice=False, sindex=None)

### pixell.reproject.rect_box(width, center=(0.0, 0.0), height=None)

### pixell.reproject.get_pixsize_rect(shape, wcs)

### pixell.reproject.rect_geometry(width, res, height=None, center=(0.0, 0.0),
proj='car')

### pixell.reproject.distribute(N, nmax)

Distribute N things into cells as equally as possible such that no cell has
more than nmax things.

### pixell.reproject.populate(shape, wcs, ofunc, maxpixy=400, maxpixx=400)

Loop through tiles in a new map of geometry (shape,wcs) with tiles that have
maximum allowed shape (maxpixy,maxpixx) such that each tile is populated with
the result of ofunc(oshape,owcs) where oshape,owcs is the geometry of each
tile.

### pixell.reproject.postage_stamp(inmap, ra_deg, dec_deg, width_arcmin,
res_arcmin, proj='gnomonic', return_cutout=False, npad=3, rotate_pol=True,
**kwargs)

## resample - Map resampling

This module handles resampling of time-series and similar arrays.

### pixell.resample.resample(d, factors=[0.5], axes=None, method='fft')

### pixell.resample.resample_bin(d, factors=[0.5], axes=None)

### pixell.resample.downsample_bin(d, steps=[2], axes=None)

### pixell.resample.upsample_bin(d, steps=[2], axes=None)

### pixell.resample.resample_fft(d, n, axes=None)

Resample numpy array d via fourier-reshaping. Requires periodic data. n
indicates the desired output lengths of the axes that are to be resampled. By
default the last len(n) axes are resampled, but this can be controlled via the
axes argument.

### pixell.resample.resample_fft_simple(d, n, ngroup=100)

Resample 2d numpy array d via fourier-reshaping along last axis.

### pixell.resample.make_equispaced(d, t, quantile=0.1, order=3,
mask_nan=False)

Given an array d[…,nt] of data that has been sampled at times t[nt], return an
array that has been resampled to have a constant sampling rate.

## lensing - Lensing

### pixell.lensing.lens_map(imap, grad_phi, order=3, mode='spline',
border='cyclic', trans=False, deriv=False, h=1e-07)

Lens map imap[{pre},ny,nx] according to grad_phi[2,ny,nx], where phi is the
lensing potential, and grad_phi, which can be computed as enmap.grad(phi),
simply is the coordinate displacement for each pixel. order, mode and border
specify details of the interpolation used. See enlib.interpol.map_coordinates
for details. If trans is true, the transpose operation is performed. This is
NOT equivalent to delensing.

If the same lensing field needs to be reused repeatedly, then higher
efficiency can be gotten from calling displace_map directly with precomputed
pixel positions.

### pixell.lensing.delens_map(imap, grad_phi, nstep=3, order=3, mode='spline',
border='cyclic')

The inverse of lens_map, such that delens_map(lens_map(imap, dpos), dpos) =
imap for well-behaved fields. The inverse does not always exist, in which case
the equation above will only be approximately fulfilled. The inverse is
computed by iteration, with the number of steps in the iteration controllable
through the nstep parameter. See enlib.interpol.map_coordinates for details on
the other parameters.

### pixell.lensing.delens_grad(grad_phi, nstep=3, order=3, mode='spline',
border='cyclic')

Helper function for delens_map. Attempts to find the undisplaced gradient
given one that has been displaced by itself.

### pixell.lensing.displace_map(imap, pix, order=3, mode='spline',
border='cyclic', trans=False, deriv=False)

Displace map m[{pre},ny,nx] by pix[2,ny,nx], where pix indicates the location
in the input map each output pixel should get its value from (float). The
output is [{pre},ny,nx].

### pixell.lensing.lens_map_flat(cmb_map, phi_map)

### pixell.lensing.phi_to_kappa(phi_alm, phi_ainfo=None)

Convert lensing potential alms phi_alm to lensing convergence alms kappa_alm,
i.e. phi_alm * l * (l+1) / 2

  * **Parameters:**
  * **phi_alm** – (…,N) ndarray of spherical harmonic alms of lensing potential
  * **phi_ainfo** – If ainfo is provided, it is an alm_info describing the layout

of the input alm. Otherwise it will be inferred from the alm itself.

  * **Returns:** The filtered alms phi_alm * l * (l+1) / 2
  * **Return type:** kappa_alm

### pixell.lensing.kappa_to_phi(kappa_alm, kappa_ainfo=None)

Convert lensing convergence alms kappa_alm to lensing potential alms phi_alm,
i.e. kappa_alm / ( l * (l+1) / 2 )

  * **Parameters:**
  * **kappa_alm** – (…,N) ndarray of spherical harmonic alms of lensing convergence
  * **kappa_ainfo** – If ainfo is provided, it is an alm_info describing the layout

of the input alm. Otherwise it will be inferred from the alm itself.

  * **Returns:** The filtered alms kappa_alm / ( l * (l+1) / 2 )
  * **Return type:** phi_alm

### pixell.lensing.lens_map_curved(shape, wcs, phi_alm, cmb_alm,
phi_ainfo=None, maplmax=None, dtype=, spin=[0, 2], output='l', geodesic=True,
verbose=False, delta_theta=None)

Lenses a CMB map given the lensing potential harmonic transform and the CMB
harmonic transform. By default, T,E,B spherical harmonic coefficients are
accepted and the returned maps are T, Q, U. Parameters: ———– shape : tuple

> Shape of the output map.

wcs : World Coordinate System object describing the map projection.

phi_alm : Spherical harmonic coefficients of the lensing potential.

cmb_alm : Spherical harmonic coefficients of the CMB. If (3,nelem) shaped, the
coeffients are assumed to be in the form of [T,E,B] in that order.

phi_ainfo : alm_info object containing information about the alm layout.
Default: standard triangular layout.

maplmax : Maximum multipole to use in the map.

dtype : Data type of the output maps. Default is np.float64.

spin : List of spins. These describe how to handle the [ncomp] axis in
cmb_alm. 0: scalar transform. Consumes one element in the component axis not
0: spin transform. Consumes two elements from the component axis. For example,
if you have a TEB alm [3,nelem] and want to transform it to a TQU map
[3,ny,nx], you would use spin=[0,2] to perform a scalar transform for the T
component and a spin-2 transform for the Q,U components. Another example. If
you had an alm [5,nelem] and map [5,ny,nx] and the first element was scalar,
the next pair spin-1 and the next pair spin-2, you woudl use spin=[0,1,2].
default:[0,2]

output : String which specifies which maps to output, e.g. “lu”. Default is
“l”. “l” - lensed CMB map “u” - unlensed CMB map “p” - lensing potential map
“k” - convergence map “a” - deflection angle maps

geodesic : Properly parallel transport on the sphere (default). If False, a
much faster approximation is used, which is still very accurate unless one is
close to the poles.

verbose : If True, prints progress information. Default is False.

delta_theta : Step size for the theta coordinate.

### Returns:

tuple : A tuple containing the requested output maps in the order specified by
the output parameter.

### pixell.lensing.rand_alm(ps_lensinput, lmax=None, dtype=, seed=None,
phi_seed=None, verbose=False, ncomp=None)

### pixell.lensing.rand_map(shape, wcs, ps_lensinput, lmax=None, maplmax=None,
dtype=, seed=None, phi_seed=None, spin=[0, 2], output='l', geodesic=True,
verbose=False, delta_theta=None)

### pixell.lensing.offset_by_grad(ipos, grad, geodesic=True, pol=None)

Given a set of coordinates ipos[{dec,ra},…] and a gradient
grad[{ddec,dphi/cos(dec)},…] (as returned by curvedsky.alm2map(deriv=True)),
returns opos = ipos + grad, while properly parallel transporting on the
sphere. If geodesic=False is specified, then an much faster approximation is
used, which is still very accurate unless one is close to the poles.

### pixell.lensing.offset_by_grad_helper(ipos, grad, pol)

Find the new position and induced rotation from offseting the input positions
ipos[2,nsamp] by grad[2,nsamp].

### pixell.lensing.pole_wrap(pos)

Handle pole wraparound.

## pointsrcs - Point Sources

Point source parameter I/O. In order to simulate a point source as it appears
on the sky, we need to know its position, amplitude and local beam shape
(which can also absorb an extendes size for the source, as long as it’s
gaussian). While other properties may be nice to know, those are the only ones
that matter for simulating it. This module provides functions for reading
these minimal parameters from various data files.

The standard parameters are [nsrc,nparam]: : dec (radians) ra (radians)
[T,Q,U] amplitude at center of gaussian (uK) beam sigma (wide axis) (radians)
beam sigma (short axis) (radians) beam orientation (wide axis from dec axis)
(radians)

What do I really need to simulate a source?

  1. Physical source on the sky (pos,amps,shape)
  2. Telescope response (beam in focalplane)

For a point source 1.shape would be a point. But clusters and nearby galaxies
can have other shapes. In general many profiles are possible. Parametrizing
them in a standard format may be difficult.

### pixell.pointsrcs.sim_objects(shape, wcs, poss, amps, profile,
prof_ids=None, omap=None, vmin=None, rmax=None, op='add', pixwin=False,
pixwin_order=0, separable='auto', transpose=False, prof_equi='auto',
cache=None, return_times=False)

Simulate radially symmetric objects with arbitrary profiles and amplitudes.
Arguments: * shape, wcs: The geometry of the patch to simulate. Only
shape[-2:]

> is used. amps determines the pre-dimensions * poss: The positions of the
> objects. [{dec,ra},nobj] in radians. * amps: The central amplitudes of the
> objects. […,nobj]. Not the same as the flux. * profile: The profiles to use.
> Either [{r,b(r)},nsamp] (with shape (2,nsamp)) or a list of such, where
> nsamp is the size of r and b(r). If providing a list for nobj objects, the
> shape of the array passed is (nobj,2,nsamp) and prof_ids should be
> np.arange(nobj).

Optional arguments: * prof_ids: Which profile to use for each source. Defaults
to use

> the first profile for all. Only necessary to specify if you want to simulate
> objects with varying profiles. If specified, it should be [nobj] indices
> into the profile list. * omap: Update this map instead of constructing a new
> one. MUST BE float32 AND C CONTIGUOUS and have shape […,ny,nx] where …
> matches amps. * vmin: The lowest values to bother simulating. To avoid being
> terribly slow, profiles aren’t evaluated out to infinite distance, but only
> once they drop down to a sufficiently low level, given by vmin. This takes
> into account the peak amplitud of each object, so it should be in map units.
> For example, it might be reasonable to have a vmin a few times lower than
> the noise level of the map, e.g. 0.1 µK. If not specified, then it defaults
> to min(abs(amps))*1e-3. * rmax: The maximum radius to use, in radians. Acts
> as a cap on the radius calculated from vmin. Not applied if None or 0. * op:
> What operation to use when combining the input map with each object. “add”:
> Add linearly [default] “max”: Keep the max value in each pixel “min”: Keep
> the min value in each pixel * pixwin: Whether to apply a pixel window after
> simulating the objects. This assumes periodic boundary consitions, so
> objects at the very edge will be wrong. * separable: Whether the coordinate
> system’s coordinate axes are indpendent, such that one only needs to know y
> in order to calculate dec, and x to calculate ra. This allows for much
> faster calculation of the pixel coordinates. Default “auto”: True for
> cylindrical coordinates, False otherwise. * cache: Dictionary to use for
> caching pixel coordinates. Can be useful if you’re doing repeated
> simulations on the same geometry with non-separable geometry, to avoid
> having to recalculate the pixel coordinates all the time.

Returns the resulting map. If omap was specified, then the same object will be
returned (after being updated of course). In this case, the simulated sources
will have been added (or maxed etc. depending on op) into the map. Otherwise,
the only signal in the map will be the objects.

### pixell.pointsrcs.is_equi(r)

Estimate whether the values r[:] = arange(n)*delta, allowing for fast index
calculations. This is just a heuristic, but it is hopefully reliable enough.

### pixell.pointsrcs.radial_sum(map, poss, bins, oprofs=None,
separable='auto', prof_equi='auto', cache=None, return_times=False)

Sum the signal in map into radial bins around a set of objects, returning one
radial sum-profile per object. Arguments: * map: The map to read data from.
[…,ny,nx] * poss: The positions of the objects. [{dec,ra},nobj] in radians. *
bins: The bin edges. [nbin+1]. Faster if equi-spaced with first at 0

Optional arguments: * oprofs: [obj,…,nbin] array to write result to. MUST BE
float32 AND C CONTIGUOUS * separable: Whether the coordinate system’s
coordinate axes are indpendent,

> such that one only needs to know y in order to calculate dec, and x to
> calculate ra. This allows for much faster calculation of the pixel
> coordinates. Default “auto”: True for cylindrical coordinates, False
> otherwise. * cache: Dictionary to use for caching pixel coordinates. Can be
> useful if you’re doing repeated simulations on the same geometry with non-
> separable geometry, to avoid having to recalculate the pixel coordinates all
> the time.

Returns the resulting profiles. If oprof was specified, then the same object
will be returned (after being updated of course).

### pixell.pointsrcs.radial_bin(map, poss, bins, weights=None,
separable='auto', prof_equi='auto', cache=None, return_times=False)

Average the signal in map into radial bins for a set of objects, returning a
radial profile for each object. Arguments: * map: The map to read data from.
[…,ny,nx] * poss: The positions of the objects. [{dec,ra},nobj] in radians. *
bins: The bin edges. [nbin+1]. Faster if equi-spaced with first at 0

Optional arguments: * oprofs: [obj,…,nbin] array to write result to. MUST BE
float32 AND C CONTIGUOUS * separable: Whether the coordinate system’s
coordinate axes are indpendent,

> such that one only needs to know y in order to calculate dec, and x to
> calculate ra. This allows for much faster calculation of the pixel
> coordinates. Default “auto”: True for cylindrical coordinates, False
> otherwise. * cache: Dictionary to use for caching pixel coordinates. Can be
> useful if you’re doing repeated simulations on the same geometry with non-
> separable geometry, to avoid having to recalculate the pixel coordinates all
> the time.

Returns the resulting profiles. If oprof was specified, then the same object
will be returned (after being updated of course).

### pixell.pointsrcs.sim_srcs(shape, wcs, srcs, beam, omap=None, dtype=None,
nsigma=5, rmax=None, vmin=None, smul=1, return_padded=False, pixwin=False,
pixwin_order=0, op=, wrap='auto', verbose=False, cache=None, separable='auto',
method='c')

Backwards compatibility wrapper that exposes the speed of the new sim_objects
function using the old sim_srcs interface. For most users this should result
in a transparent speedup of O(10x), but sim_objects does not implement 100% of
the sim_srcs functionality, so the old python method is also available by
specifying method = “python”.

Limitations of the new version: * only float32, C-contiguous maps supported *
smul not supported * padding not supported, which impacts objects at the very
edge of the map if

> pixwin is used * only add, max and min supported for ‘op’

Unlike sim_srcs, sim_objects supports simulating objects with multiple
different profiles at once, but this functionality isn’t available through the
sim_srcs interface.

I recommend using sim_objects directly instead of relying on this wrapper in
most cases.

### pixell.pointsrcs.sim_srcs_python(shape, wcs, srcs, beam, omap=None,
dtype=None, nsigma=5, rmax=None, smul=1, return_padded=False, pixwin=False,
pixwin_order=0, op=, wrap='auto', verbose=False, cache=None, separable='auto')

Simulate a point source map in the geometry given by shape, wcs for the given
srcs[nsrc,{dec,ra,T…}], using the beam[{r,val},npoint], which must be
equispaced. If omap is specified, the sources will be added to it in place.
All angles are in radians. The beam is only evaluated up to the point where it
reaches exp(-0.5*nsigma**2) unless rmax is specified, in which case this gives
the maximum radius. smul gives a factor to multiply the resulting source model
by. This is mostly useful in conction with omap.

The source simulation is sped up by using a source lookup grid.

### pixell.pointsrcs.eval_srcs_loop(posmap, poss, amps, beam, cres, nhit,
cell_srcs, dtype=, op=, verbose=False)

### pixell.pointsrcs.sim_srcs_dist_transform(shape, wcs, srcs, beam,
omap=None, dtype=None, nsigma=4, rmax=None, smul=1, pixwin=False,
ignore_outside=False, op=, verbose=False)

Simulate a point source map in the geometry given by shape, wcs for the given
srcs[nsrc,{dec,ra,T…}], using the beam[{r,val},npoint], which must be
equispaced. Unlike sim_srcs, overalpping point sources are not supported. If
omap is specified, the sources will be added to it in place. All angles are in
radians. The beam is only evaluated up to the point where it reaches
exp(-0.5*nsigma**2) unless rmax is specified, in which case this gives the
maximum radius. smul gives a factor to multiply the resulting source model by.
This is mostly useful in conction with omap.

### pixell.pointsrcs.expand_beam(beam, nsigma=5, rmax=None, nper=400)

### pixell.pointsrcs.nsigma2rmax(beam, nsigma)

### pixell.pointsrcs.build_src_cells(cbox, srcpos, cres, unwind=False,
wrap=None)

### pixell.pointsrcs.build_src_cells_helper(cbox, cshape, cres, srcpos,
nmax=0, wrap=None)

### pixell.pointsrcs.cellify(map, res)

Given a map […,ny,nx] and a cell resolution [ry,rx], return map reshaped into
a cell grid […,ncelly,ncellx,ry,rx]. The map will be truncated if necessary

### pixell.pointsrcs.uncellify(cmap)

### pixell.pointsrcs.crossmatch(srcs1, srcs2, tol=0.0002908882086657216,
safety=4)

Cross-match two source catalogs based on position. Each source in one catalog
is associated with the closest source in the other catalog, as long as the
distance between them is less than the tolerance. The catalogs must be
[:,{ra,dec,…}] in radians. Returns [nmatch,2], with the last index giving the
index in the first and second catalog for each match.

### pixell.pointsrcs.read(fname, format='auto')

### pixell.pointsrcs.read_nemo(fname)

Reads the nemo ascii catalog format, and returns it as a recarray.

### pixell.pointsrcs.read_simple(fname)

### pixell.pointsrcs.read_dory_fits(fname, hdu=1)

### pixell.pointsrcs.read_dory_txt(fname)

### pixell.pointsrcs.read_fits(fname, hdu=1, fix=True)

### pixell.pointsrcs.format_sauron(cat)

### pixell.pointsrcs.write_sauron(ofile, cat)

### pixell.pointsrcs.read_sauron(ifile)

### pixell.pointsrcs.write_sauron_fits(ofile, cat)

### pixell.pointsrcs.read_sauron_fits(fname)

### pixell.pointsrcs.write_sauron_txt(ofile, cat)

### pixell.pointsrcs.read_sauron_txt(ifile, ncomp=3)

### pixell.pointsrcs.translate_dtype_keys(d, translation)

### pixell.pointsrcs.src2param(srcs)

Translate recarray srcs into the source fromat used for tod-level point source
operations.

## interpol - Interpolation

### pixell.interpol.map_coordinates(idata, points, odata=None, mode='spline',
order=3, border='cyclic', trans=False, deriv=False, prefilter=True)

An alternative implementation of scipy.ndimage.map_coordinates. It is slightly
slower (20-30%), but more general. Basic usage is

> odata[{pre},{pdims}] = map_coordinates(idata[{pre},{dims}],
> points[ndim,{pdims}])

where {foo} means a (possibly empty) shape. For example, if idata has shape
(10,20) and points has shape (2,100), then the result will have shape (100,),
and if idata has shape (10,20,30,40) and points has shape (3,1,2,3,4), then
the result will have shape (10,1,2,3,4). Except for the presence of {pre},
this is the same as how map_coordinates works.

It is also possible to pass the output array as an argument (odata), which
must have the same data type as idata in that case.

The function differs from ndimage in the meaning of the optional arguments.
mode specifies the interpolation scheme to use: “conv”, “spline” or “lanczos”.
“conv” is polynomial convolution, which is commonly used in image processing.
“spline” is spline interpolation, which is what ndimage uses. “lanczos”
convolutes with a lanczos kernerl, which approximates the optimal sinc kernel.
This is slow, and the quality is not much better than spline.

order specifies the interpolation order, its exact meaning differs based on
mode.

border specifies the handling of boundary conditions. It can be “zero”,
“nearest”, “cyclic” or “mirror”/”reflect”. The latter corresponds to ndimage’s
“reflect”. The others do not match ndimage due to ndimage’s inconsistent
treatment of boundary conditions in spline_filter vs. map_coordiantes.

trans specifies whether to perform the transpose operation or not. The
interpolation performed by map_coordinates is a linear operation, and can
hence be expressed as out = A*data, where A is a matrix. If trans is true,
then what will instead be performed is data = A.T*in. For this to work, the
odata argument must be specified. This will be read from, while idata will be
written to.

Normally idata is read and odata is written to, but when trans=True, idata is
written to and odata is read from.

If deriv is True, then the function will compute the derivative of the
interpolation operation with respect to the position, resulting in
odata[ndim,{pre},{pdims}]

### pixell.interpol.spline_filter(data, order=3, border='cyclic', ndim=None,
trans=False)

Apply a spline filter to the given array. This is normally done on-the-fly
internally in map_coordinates when using spline interpolation of order > 1,
but since it’s an operation that applies to the whole input array, it can be a
big overhead to do this for every call if only a small number of points are to
be interpolated. This overhead can be avoided by manually filtering the array
once, and then passing in the filtered array to map_coordinates with
prefilter=False to turn off the internal filtering.

### pixell.interpol.get_core(dtype)

### pixell.interpol.build(func, interpolator, box, errlim, maxsize=None,
maxtime=None, return_obox=False, return_status=False, verbose=False,
nstart=None, *args, **kwargs)

Given a function func([nin,…]) => [nout,…] and an interpolator class
interpolator(box,[nout,…]), (where the input array is regularly spaced in each
direction), which provides __call__([nin,…]) => [nout,…], automatically polls
func and constructs an interpolator object that has the required accuracy
inside the provided bounding box.

### _class_ pixell.interpol.Interpolator(box, y, *args, **kwargs)

### _class_ pixell.interpol.ip_ndimage(box, y, *args, **kwargs)

### _class_ pixell.interpol.ip_linear(box, y, *args, **kwargs)

### _class_ pixell.interpol.ip_grad(box, y, *args, **kwargs)

Gradient interpolation. Faster but less accurate than bilinear

### pixell.interpol.lin_derivs_forward(y, npre=0)

Given an array y with npre leading dimensions and n following dimensions,
compute all combinations of the 0th and 1st derivatives along the n last
dimensions, returning an array of shape (2,)*n+(:,)*npre+(:-1,)*n. That is, it
is one shorter in each direction along which the derivative is taken.
Derivatives are computed using forward difference.

### pixell.interpol.grad_forward(y, npre=0)

Given an array y with npre leading dimensions and n following dimensions, the
gradient along the n last dimensions, returning an array of shape
(n,)+y.shape. Derivatives are computed using forward difference.

## coordinates - Coordinate Transformation

### _class_ pixell.coordinates.default_site

#### lat _= -22.9585_

#### lon _= -67.7876_

#### alt _= 5188.0_

#### T _= 273.15_

#### P _= 550.0_

#### hum _= 0.2_

#### freq _= 150.0_

#### lapse _= 0.0065_

#### base_tilt _= 0.0107693_

#### base_az _= -114.9733961_

### pixell.coordinates.transform(from_sys, to_sys, coords, time=55500, site=,
pol=None, mag=None, bore=None)

Transforms coords[2,…] from system from_sys to system to_sys, where systems
can be “hor”, “cel” or “gal”. For transformations involving “hor”, the
optional arguments time (in modified julian days) and site (which must contain
.lat (rad), .lon (rad), .P (pressure, mBar), .T (temperature, K), .hum
(humidity, 0.2 by default), .alt (altitude, m)). Returns an array with the
same shape as the input. The coordinates are in ra,dec-ordering.

### pixell.coordinates.transform_meta(transfun, coords, fields=['ang', 'mag'],
offset=5e-07)

Computes metadata for the coordinate transformation functor transfun applied
to the coordinate array coords[2,…], such as the induced rotation,
magnification.

Currently assumes that input and output coordinates are in non-zenith polar
coordinates. Might generalize this later.

### pixell.coordinates.transform_raw(from_sys, to_sys, coords, time=None,
site=, bore=None)

Transforms coords[2,…] from system from_sys to system to_sys, where systems
can be “hor”, “cel” or “gal”. For transformations involving “hor”, the
optional arguments time (in modified julian days) and site (which must contain
.lat (rad), .lon (rad), .P (pressure, mBar), .T (temperature, K), .hum
(humidity, 0.2 by default), .alt (altitude, m)). Returns an array with the
same shape as the input. The coordinates are in ra,dec-ordering.

coords and time will be broadcast such that the result has the same shape as
coords*time[None].

### pixell.coordinates.transform_astropy(from_sys, to_sys, coords)

As transform, but only handles the systems supported by astropy.

### pixell.coordinates.transform_euler(euler, coords, pol=None, mag=None)

Like transform, but for a set of zyz euler angles instead

### pixell.coordinates.hor2cel(coord, time, site, copy=True)

### pixell.coordinates.cel2hor(coord, time, site, copy=True)

### pixell.coordinates.tele2hor(coord, site, copy=True)

### pixell.coordinates.hor2tele(coord, site, copy=True)

### pixell.coordinates.tele2bore(coord, bore, copy=True)

Transforms coordinates [{ra,dec},…] to boresight-relative coordinates given by
the boresight pointing [{ra,dec},…] with the same shape as coords. After the
rotation, the boresight will be at the zenith; things above the boresight will
be at ‘ra’=180 and things below will be ‘ra’=0.

### pixell.coordinates.bore2tele(coord, bore, copy=True)

Transforms coordinates [{ra,dec},…] from boresight-relative coordinates given
by the boresight pointing [{ra,dec},…] with the same shape as coords. After
the rotation, the coordinates will be in telescope coordinates, which are
similar to horizontal coordinates.

### pixell.coordinates.euler_mat(euler_angles, kind='zyz')

Defines the rotation matrix M for a ABC euler rotation, such that M =
A(alpha)B(beta)C(gamma), where euler_angles = [alpha,beta,gamma]. The default
kind is ABC=ZYZ.

### pixell.coordinates.euler_rot(euler_angles, coords, kind='zyz')

### pixell.coordinates.recenter(angs, center, restore=False)

Recenter coordinates “angs” (as ra,dec) on the location given by “center”,
such that center moves to the north pole.

### pixell.coordinates.decenter(angs, center, restore=False)

Inverse operation of recenter.

### pixell.coordinates.nohor(sys)

### pixell.coordinates.getsys(sys)

### pixell.coordinates.get_handedness(sys)

Return the handedness of the coordinate system sys, as seen from inside the
celestial sphere, in the standard IAU convention.

### pixell.coordinates.getsys_full(sys, time=None, site=, bore=None)

Handles our expanded coordinate system syntax: base[:ref[:refsys]]. This
allows a system to be recentered on a given position or object. The argument
can either be a string of the above format (with [] indicating optional
parts), or a list of [base, ref, refsys]. Returns a parsed and expanded
version, where the systems have been replaced by full system objects (or
None), and the reference point has been expanded into coordinates (or None),
and rotated into the base system. Coordinates are separated by _.

Example: Horizontal-based coordinates with the Moon centered at [0,0] would be
hor:Moon/0_0.

Example: Put celestial coordinates ra=10, dec=20 at horizontal coordinates
az=0, el=0: hor:10_20:cel/0_0:hor. Yes, this is horrible.

Used to be sys:center_on/center_at:sys_of_center_coordinates. But much more
flexible to do sys:center_on:sys/center_at:sys. This syntax would be backwards
compatible, though it’s starting to get a bit clunky.

Big hack: If the system is “sidelobe”, then we will use sidelobe-oriented
centering instead of object-oriented centering. This will result in a
coordinate system where the boresight has the zenith-mirrored position of what
the object would have in zenith-relative coordinates.

### pixell.coordinates.ephem_pos(name, mjd)

Given the name of an ephemeris object from pyephem and a time in modified
julian date, return its position in ra, dec in radians in equatorial
coordinates.

### pixell.coordinates.interpol_pos(from_sys, to_sys, name_or_pos, mjd, site=,
dt=10)

Given the name of an ephemeris object or a [ra,dec]-type position in radians
in from_sys, compute its position in the specified coordinate system for each
mjd. The mjds are assumed to be sampled densely enough that interpolation will
work. For ephemeris objects, positions are computed in steps of 10 seconds by
default (controlled by the dt argument).

### pixell.coordinates.make_mapping(dict)

## wcsutils - World Coordinate Sytem utilities

This module defines shortcuts for generating WCS instances and working with
them. The bounding boxes and shapes used in this module all use the same
ordering as WCS, i.e. column major (so {ra,dec} rather than {dec,ra}).
Coordinates are assigned to pixel centers, as WCS does natively, but bounding
boxes include the whole pixels, not just their centers, which is where the 0.5
stuff comes from.

### pixell.wcsutils.streq(x, s)

### pixell.wcsutils.projection(system, crval=None)

Generate a pixelization-agnostic wcs

### pixell.wcsutils.pixelization(pwcs, shape=None, res=None, variant=None)

Add pixel information to a wcs, returning a full-sky geometry, or as close to
that as the projection allows.

### pixell.wcsutils.explicit(naxis=2, **args)

### pixell.wcsutils.expand_res(res, signs=None, flip=False)

If res is not None, expand it to length 2. If it wasn’t already length 2, the
RA sign will be inverted. If flip is True, the res order will be flipped
before expanding

### pixell.wcsutils.describe(wcs)

Since astropy.wcs.WCS objects do not have a useful str implementation, this
function provides a relpacement.

### pixell.wcsutils.equal(wcs1, wcs2, flags=1, tol=1e-14)

### pixell.wcsutils.nobcheck(wcs)

### pixell.wcsutils.is_compatible(wcs1, wcs2, tol=0.001)

Checks whether two world coordinate systems represent (shifted) versions of
the same pixelizations, such that every pixel center in wcs1 correspond to a
pixel center in wcs2. For now, they also have to have the pixels going in the
same direction.

### pixell.wcsutils.is_plain(wcs)

Determines whether the given wcs represents plain, non-specific, non-wrapping
coordinates or some angular coordiante system.

### pixell.wcsutils.is_cyl(wcs)

Returns True if the wcs represents a cylindrical coordinate system

### pixell.wcsutils.is_separable(wcs)

### pixell.wcsutils.get_proj(wcs)

### pixell.wcsutils.parse_system(system, variant=None)

### pixell.wcsutils.scale(wcs, scale=1, rowmajor=False, corner=True)

Scales the linear pixel density of a wcs by the given factor, which can be
specified per axis. This is the same as dividing the pixel size by the same
numberr corner controls which area is scaled. With corner=True (the default),
then the area from the start of the first pixel to the end of the lats pixel
will be scaled by this factor. If corner=False, then the area from the center
of the first pixel to the center of the last pixel will be scaled. Usually the
former makes most sense.

### pixell.wcsutils.is_azimuthal(system)

### pixell.wcsutils.default_crval(system)

### pixell.wcsutils.default_extent(system)

Return the horizontal and vertical extent of the full sky in degrees, and the
prefered value of lonpole (or None if it should be left alone). For some
systems the full sky is not representable, in which case a reasonable
compromise is returned

### pixell.wcsutils.default_variant(system)

### pixell.wcsutils.extent2bounds(extent)

### pixell.wcsutils.is_periodic(system)

### pixell.wcsutils.parse_variant(name)

### _exception_ pixell.wcsutils.PixelizationError

### pixell.wcsutils.pixelize_1d(w, n=None, res=None, offs=None,
periodic=False, adjust=False, sign=1, tol=1e-06, eps=1e-06)

Figure out how to align pixels along an interval w long such that there are
either n pixels or the resolution is res, and with the given pixel offsets
from the edges. Returns the coordinates of the center of the first and last
pixel.

### pixell.wcsutils.recenter_cyl_x(wcs, x)

Given a cylindrical wcs with the reference point already on the equator, move
the reference point along the equator to the given x (counting from 1)
returning a new wcs.

### pixell.wcsutils.recenter_cyl_ra(wcs, ra)

### pixell.wcsutils.plain(pos, res=None, shape=None, rowmajor=False, ref=None)

Set up a plain coordinate system (non-cyclical)

### pixell.wcsutils.car(pos, res=None, shape=None, rowmajor=False, ref=None)

Set up a plate carree system. See the build function for details.

### pixell.wcsutils.cea(pos, res=None, shape=None, rowmajor=False, lam=None,
ref=None)

Set up a cylindrical equal area system. See the build function for details.

### pixell.wcsutils.mer(pos, res=None, shape=None, rowmajor=False, ref=None)

Set up a mercator system. See the build function for details.

### pixell.wcsutils.arc(pos, res=None, shape=None, rowmajor=False, ref=None)

Setups up a zenithal equidistant projection. See the build function for
details.

### pixell.wcsutils.sin(pos, res=None, shape=None, rowmajor=False, ref=None)

Setups up an orthographic projection. See the build function for details.

### pixell.wcsutils.zea(pos, res=None, shape=None, rowmajor=False, ref=None)

Setups up an oblate Lambert’s azimuthal equal area system. See the build
function for details. Don’t use this if you want a polar projection.

### pixell.wcsutils.air(pos, res=None, shape=None, rowmajor=False, rad=None,
ref=None)

Setups up an Airy system. See the build function for details.

### pixell.wcsutils.tan(pos, res=None, shape=None, rowmajor=False, ref=None)

Set up a gnomonic (tangent plane) system. See the build function for details.

### pixell.wcsutils.build(pos, res=None, shape=None, rowmajor=False,
system='cea', ref=None, **kwargs)

Set up the WCS system named by the “system” argument. pos can be either a [2]
center position or a [{from,to},2] bounding box. At least one of res or shape
must be specified. If res is specified, it must either be a number, in which
the same resolution is used in each direction, or [2]. If shape is specified,
it must be [2]. All angles are given in degrees.

### pixell.wcsutils.validate(pos, res, shape, rowmajor=False, default_dirs=[1,
-1])

### pixell.wcsutils.finalize(w, pos, res, shape, ref=None)

Common logic for the various wcs builders. Fills in the reference pixel and
resolution.

### pixell.wcsutils.angdist(lon1, lat1, lon2, lat2)

### pixell.wcsutils.fix_wcs(wcs, axis=0, n=None)

Returns a new WCS object which has had the reference pixel moved to the middle
of the possible pixel space.

### pixell.wcsutils.fix_cdelt(wcs)

Return a new wcs with pc and cd replaced by cdelt

## powspec - CMB power spectra utilities

### pixell.powspec.sym_compress(mat, which=None, n=None, scheme=None, axes=[0,
1], combined=False)

Extract the unique elements of a symmetric matrix, and return them as a flat
array. For multidimensional arrays, the extra dimensions keep their shape. The
optional argument ‘which’ indicates the compression scheme, as returned by
compressed_order. The optional argument ‘n’ indicates the number of elements
to keep (the default is to keep all unique elements). The ‘axes’ argument
indicates which axes to operate on.

### pixell.powspec.sym_expand(mat, which=None, ncomp=None, scheme=None,
axis=0, combined=False)

The inverse of sym_compress. Expands a flat array of numbers into a symmetric
matrix with ncomp components using the given mapping which (or construct one
using the given scheme).

### pixell.powspec.sym_expand_camb_full_lens(a)

### pixell.powspec.compressed_order(n, scheme=None)

Surmise the order in which the unique elements of a symmetric matrix are
stored, based on the number of such elements. Three different schemes are
supported. The best one is the “stable” scheme because it can be truncated
without the entries changing their meaning. However, the default in healpy is
“diag”, so that is the default here too.

stable: : 00 00 11 00 11 01 00 11 01 22 00 11 01 22 02 00 11 01 22 02 12 …

diag: : 00 00 11 00 11 01 00 11 22 01 00 11 22 01 12 00 11 22 01 12 02 …

row: : 00 00 11 00 01 11 00 01 11 22 00 01 02 11 22 00 01 02 11 12 22 …

### pixell.powspec.expand_inds(x, y)

### pixell.powspec.scale_spectrum(a, direction, extra=0, l=None)

### pixell.powspec.scale_camb_scalar_phi(a, direction, l=None)

### pixell.powspec.read_spectrum(fname, inds=True, scale=True, expand='diag',
ncol=None, ncomp=None)

Read a power spectrum from disk and return a dense array cl[nspec,lmax+1].
Unless scale=False, the spectrum will be multiplied by 2pi/l/(l+1) when being
read. Unless inds=False, the first column in the file is assumed to be the
indices. If expand!=None, it can be one of the valid expansion schemes from
compressed_order, and will cause the returned array to be
cl[ncomp,ncomp,lmax+1] instead.

### pixell.powspec.read_phi_spectrum(fname, coloff=0, inds=True, scale=True,
expand='diag')

### pixell.powspec.read_camb_scalar(fname, inds=True, scale=True, expand=True,
ncmb=3)

Read the information in the camb scalar outputs. This contains the cmb and
lensing power spectra, but not their correlation. They are therefore returned
as two separate arrays.

### pixell.powspec.read_camb_full_lens(fname, inds=True, scale=True,
expand=True, ncmb=3)

Reads the CAMB lens_potential_output spectra, which contain l TT EE BB TE dd
dT dE. These are rescaled appropriately is scale is True, and returned as
[d,T,E,B] if expand is True.

### pixell.powspec.write_spectrum(fname, spec, inds=True, scale=True,
expand='diag')

### pixell.powspec.spec2corr(spec, pos, iscos=False, symmetric=True)

Compute the correlation function sum(2l+1)/4pi Cl Pl(cos(theta)) corresponding
to the given power spectrum at the given positions.

## enplot - Producing plots from ndmaps

### _class_ pixell.enplot.Printer(level=1, prefix='')

#### write(desc, level, exact=False, newline=True, prepend='')

#### push(desc)

#### time(desc, level, exact=False, newline=True)

### pixell.enplot.plot(*arglist, **args)

The main plotting function in this module. Plots the given maps/files,
returning them as a list of plots, one for each separate image. This function
has two equivalent interfaces: 1\. A command-line like interface, where
plotting options are specified with strings like “-r 500:50 -m 0 -t 2”. 2\. A
python-like interface, where plotting options are specified with keyword
arguments, like range=”500:50”, mask=0, ticks=2. These interfaces can be mixed
and matched.

Input maps are specified either as part of the option strings, as separate
file names, or as enmaps passed to the function. Here are some examples:

plot(mapobj): : Plots the given enmap object mapobj. If mapobj is a scalar
map, the a length-1 list containing a single plot will be returned. If mapobj
is e.g. a 3-component TQU map, then a length-3 list of plots will be returned.

plot((mapobj,”foo”)): : > If a tuple is given, the second element specifies
the name tag to

> use. This tag will be used to populate the plot.name attribute for each
> output plot, which can be useful when plotting and writing the maps.  
>  plot(“file.fits”): : Reads a map from file.fits, and plots it. This sets
> the tag to “file”, so that the result can easily be written to “file.png”
> (or “file_0.png” etc).  
>  plot([“a.fits”,”b.fits”,(mapobj,”c”),(mapobj,”d.fits”)]) : Reads a.fits and
> plots it to a.png, reads b.fits and plots it to b.png, plots the first
> mapobj to c.png and the second one to d.png (yes, the extension in the
> filename specified in the tuple is ignored. This is because that filename
> actually supplies the _input_ filename that the output filename should be
> computed from).  
>  plot(“foo*.fits”) : Reads and plots every file matching the glob foo*.fits.  
>  plot(“a.fits -r 500:50 -m 0 -d 4 -t 4”) : Reads and plots the file a.fits
> to a.png, using a color range of +-500 for the first field in the map
> (typically the total intensity), and +-50 for the remaining fields
> (typically Q and U). The maps are downsampled by a factor of 4, and plotted
> with a grid spacing of 4.

Here is a list of the individual options plot recognizes. The short and long
ones are recognized when used in the argument string syntax, while the long
ones (with - replaced by _) also work as keyword arguments.

See plot_iterator for an iterator version of this function.

> –tile-dims TILE_DIMS -S, –symmetric Treat the non-pixel axes as being
> asymmetric matrix,
>

>> and only plot a non-redundant triangle of this matrix.

### pixell.enplot.pshow(*arglist, method='auto', **args)

Convenience function to both build plots and show them. pshow(…) is equivalent
to show(plot(…)).

### pixell.enplot.get_plots(*arglist, **args)

This function is identical to enplot.plot

### pixell.enplot.plot_iterator(*arglist, **kwargs)

Iterator that yields the plots for each input map/file. Each yield will be a
plot object, with fields .type: The type of the plot. Can be “pil” or “mpl”.
Usually “pil”. .img: The plot image object, of the given .type. .name:
Suggested file name These plots objects can be written to disk using
enplot.write. See the plot function documentation for a description of the
arguments

### pixell.enplot.write(fname, plot)

Write the given plot or plots to file. If plot is a single plot, then it will
simply be written to the specified filename. If plot is a list of plots, then
it fname will be interpreted as a prefix, and the plots will be written to
prefix + plot.name for each individual plot. If name was specified during
plotting, then plot.name will either be “.png” for scalar maps or “_0.png”,
“_1.png”, etc. for vector maps. It’s also possible to pass in plain images
(either PIL or matplotlib), which will be written to the given filename.

### pixell.enplot.define_arg_parser(nodefault=False)

### pixell.enplot.parse_args(args=['-b', 'markdown', '-c',
'/var/folders/v4/74kzp9yj7ljfhzn7hs8nfwf00000gn/T/patched_src_o_mvk8yh/docs',
'/var/folders/v4/74kzp9yj7ljfhzn7hs8nfwf00000gn/T/patched_src_o_mvk8yh/docs',
'/var/folders/v4/74kzp9yj7ljfhzn7hs8nfwf00000gn/T/sphinx_build_czd9600j'],
noglob=False, nodef=False)

### pixell.enplot.extract_arg(args, name, default)

### pixell.enplot.check_args(kwargs)

### pixell.enplot.get_map(ifile, args, return_info=False, name=None)

Read the specified map, and massage it according to the options in args.
Relevant ones are sub, autocrop, slice, op, downgrade, scale, mask. Retuns
with shape [:,ny,nx], where any extra dimensions have been flattened into a
single one.

### pixell.enplot.extract_stamps(map, args)

Given a map, extract a set of identically sized postage stamps based on
args.stamps. Returns a new map consisting of a stack of these stamps, along
with a list of each of these’ wcs object.

### pixell.enplot.get_cache(cache, key, fun)

### pixell.enplot.draw_map_field(map, args, crange=None, return_layers=False,
return_info=False, printer=, cache=None)

Draw a single map field, resulting in a single image. Adds a coordinate grid
and lables as specified by args. If return_layers is True, an array will be
returned instead of an image, wich each entry being a component of the image,
such as the base image, the coordinate grid, the labels, etc. If return_bounds
is True, then the

### pixell.enplot.draw_colorbar(crange, width, args)

### pixell.enplot.draw_map_field_mpl(map, args, crange=None, printer=)

Render a map field using matplotlib. Less tested and maintained than
draw_map_field, and supports fewer features. Returns an object one can call
savefig on to draw.

### pixell.enplot.parse_range(desc, n)

### pixell.enplot.parse_list(desc, dtype=, sep=', ')

### pixell.enplot.get_color_range(map, args)

Compute an appropriate color bare range from map[:,ny,nx] given the args.
Relevant members are range, min, max, quantile.

### pixell.enplot.get_num_digits(n)

### pixell.enplot.split_file_name(fname)

Split a file name into directory, base name and extension, such that fname =
dirname + “/” + basename + “.” + ext.

### pixell.enplot.map_to_color(map, crange, args)

Compute an [{R,G,B},ny,nx] color map based on a map[1 or 3, ny,nx] map and a
corresponding color range crange[{min,max}]. Relevant args fields: color,
method, rgb. If rgb is not true, only the first element of the input map will
be used. Otherwise 3 will be used.

### pixell.enplot.calc_gridinfo(shape, wcs, args)

Compute the points making up the grid lines for the given map. Depends on
args.ticks and args.nstep.

### pixell.enplot.draw_grid(ginfo, args)

Return a grid based on gridinfo. args.grid_color controls the color the grid
will be drawn with.

### pixell.enplot.draw_grid_labels(ginfo, args)

Return an image with a coordinate grid, along with abounds of this image
relative to the coordinate shape stored in ginfo. Depends on the following
args members: args.font, args.font_size, args.font_color

### pixell.enplot.calc_contours(crange, args)

Returns a list of values at which to place contours based on the valure range
of the map crange[{from,to}] and the contour specification in args.

Contour specifications: : base:step or val,val,val…

base: number step: number (explicit), -number (relative)

### pixell.enplot.draw_contours(map, contours, args)

### pixell.enplot.parse_annotations(afile)

### pixell.enplot.draw_annotations(map, annots, args)

Draw a set of annotations on the map. These are specified as a list of
[“type”,param,param,…]. The recognized formats are:

> c[ircle] lat lon dy dx [rad [width [color]]] t[ext] lat lon dy dx text [size
> [color]] l[ine] lat lon dy dx lat lon dy dx [width [color]] r[ect] lat lon
> dy dx lat lon dy dx [width [color]]

dy and dx are pixel-unit offsets from the specified lat/lon. This is useful
for e.g. placing text next to circles.

### pixell.enplot.standardize_images(tuples)

Given a list of (img,bounds), composite them on top of each other (first at
the bottom), and return the total image and its new bounds.

### pixell.enplot.merge_images(images)

Stack all images into an alpha composite. Images must all have consistent
extent before this. Use standardize_images to achieve this.

### pixell.enplot.merge_plots(plots)

### pixell.enplot.prepare_map_field(map, args, crange=None, printer=)

### pixell.enplot.makefoot(n)

### pixell.enplot.contour_widen(cmap, width)

### pixell.enplot.draw_ellipse(image, bounds, width=1, outline='white',
antialias=1)

Improved ellipse drawing function, based on PIL.ImageDraw. Improved from
<http://stackoverflow.com/questions/32504246/draw-ellipse-in-python-pil-with-
line-thickness>

### pixell.enplot.hwexpand(m, nrow=-1, ncol=-1, transpose=False, dims=None)

Stack the maps in mflat[n,ny,nx] into a single flat map mflat[nrow,ncol,ny,nx]

### pixell.enplot.hwstack(mexp)

### _exception_ pixell.enplot.BackendError

### pixell.enplot.show(img, title=None, method='auto')

### pixell.enplot.show_ipython(img, title=None)

### pixell.enplot.show_tk(img, title=None)

### pixell.enplot.show_wx(img, title=None)

### pixell.enplot.show_qt(img, title=None)

## tilemap - Tiled maps where only some tiles are stored

### pixell.tilemap.zeros(tile_geom, dtype=)

Construct a zero-initialized TileMap with the given TileGeometry and data type

### pixell.tilemap.empty(tile_geom, dtype=)

Construct a zero-initialized TileMap with the given TileGeometry and data type

### pixell.tilemap.full(tile_geom, val, dtype=)

Construct a zero-initialized TileMap with the given TileGeometry and data type

### pixell.tilemap.from_tiles(tiles, tile_geom)

Construct a TileMap from a set of a full list of tiles, both active and
inactive. Inactive tiles are indicated with None entries. The active
information in tile_geom is ignored, as is the non-pixel part of
tile_geom.shape, which is instead inferred from the tiles.

### pixell.tilemap.from_active_tiles(tiles, tile_geom)

Construct a TileMap from a list of active tiles that should match the active
list in the provided tile geometry. The non-pixel part of tile_geom is
ignored, and is instead inferred from the tile shapes.

### _class_ pixell.tilemap.TileMap(arr, tile_geom)

Implements a sparse tiled map, as described by a TileGeometry. This is
effectively a large enmap that has been split into tiles, of which only a
subset is stored. This is implemented as a subclass of ndarray instead of a
list of tiles to allow us to transparently perform math operations on it. The
maps are stored stored as a single array with all tiles concatenated along a
flattened pixel dimension, in the same order as in tile_geom.active.

Example: A TileMap covering a logical area with shape (3,100,100) with (10,10)
tiles and active tiles [7,5] will have a shape of (3,200=10*10*2) when
accessed directly. When accessed through the .tiles view, .tiles[5] will
return a view of an (3,10,10) enmap, as will .tiles[7]. For all other indices,
.tiles[x] will return None. The same two tiles can be accessed as
.active_tiles[1] and .active_tiles[0] respecitvely.

Slicing the TileMap using the [] operator works. For all but the last axis,
this does what you would expect. E.g. for the above example,
tile_map[0].tiles[5] would return a view of a (10,10) enmap (so the first axis
is gone). If the last axis, which represents a flattened view of the pixels
and tiles, is sliced, then the returned object will be a plain numpy array.

#### contig()

#### _property_ pre

#### copy(order='C')

Return a copy of the array.

  * **Parameters:** **order** ( _{'C'_ _,_ _'F'_ _,_ _'A'_ _,_ _'K'}_ _,_ _optional_) – Controls the memory layout of the copy. ‘C’ means C-order, ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous, ‘C’ otherwise. ‘K’ means match the layout of a as closely as possible. (Note that this function and `numpy.copy()` are very similar but have different default values for their order= arguments, and this function always passes sub-classes through.)

#### SEE ALSO

`numpy.copy` : Similar function with different default behavior

`numpy.copyto`

### Notes

This function is the preferred method for creating an array copy. The function
`numpy.copy()` is similar, but it defaults to using order ‘K’, and will not
pass sub-classes through by default.

### Examples

```pycon

> > > import numpy as np x = np.array([[1,2,3],[4,5,6]], order='F') ```

```pycon

> > > y = x.copy() ```

```pycon

> > > x.fill(0) ```

```pycon

> > > x array([[0, 0, 0], [0, 0, 0]]) ```

```pycon

> > > y array([[1, 2, 3], [4, 5, 6]]) ```

```pycon

> > > y.flags['C_CONTIGUOUS'] True ```

For arrays containing Python objects (e.g. dtype=object), the copy is a
shallow one. The new array will contain the same object which may lead to
surprises if that object can be modified (is mutable):

```pycon

> > > a = np.array([1, 'm', [2, 3, 4]], dtype=object) b = a.copy() b[2][0] =
> 10 a array([1, 'm', list([10, 3, 4])], dtype=object) ```

To ensure all elements within an `object` array are copied, use copy.deepcopy:

```pycon

> > > import copy a = np.array([1, 'm', [2, 3, 4]], dtype=object) c =
> copy.deepcopy(a) c[2][0] = 10 c array([1, 'm', list([10, 3, 4])],
> dtype=object) a array([1, 'm', list([2, 3, 4])], dtype=object) ```

#### _property_ tiles

#### _property_ active_tiles

#### with_tiles(other, strict=False)

If a and b are TileMaps with the same overall tiling but different active tile
sets, then c = a.with_tiles(b) will make c a TileMap with the union of the
active tiles of a and b and the data from a (new tiles are zero-initialized).

If strict==True, then c will have exactly the active tiles of b, in exactly
that order. Binary operations on strictly compatible arrays should be
considerably faster.

#### _property_ active

#### _property_ lookup

#### _property_ nactive

#### _property_ ntile

#### _property_ tile_shape

#### insert(imap, op=>)

### _class_ pixell.tilemap.TileView(tile_map, active=True)

Helper class used to implement access to the individual tiles that make up a
TileMap object

#### _property_ ndim

#### _property_ shape

### pixell.tilemap.make_binop(op, is_inplace=False)

### pixell.tilemap.insert(omap, imap, op=>)

Insert imap into omap, returning the result. Equivalent to enmap.insert, but
with the following important differences: * omap is not modified. Use the
result is returned. (enmap both modifies and returns) * The maps must have the
same geometry, only differing by the active tiles. This may be generalized in
the future.

### pixell.tilemap.map_mul(mat, vec)

Elementwise matrix multiplication mat*vec. Result will have the same shape as
vec. Multiplication happens along the last non-pixel indices.

### pixell.tilemap.samegeo(arr, *args)

Returns arr with the same geometry information as the first tilemap among
args. If no matches are found, arr is returned as is. Will reference, rather
than copy, the underlying array data whenever possible.

### pixell.tilemap.geometry(shape, wcs, tile_shape=(500, 500), active=[])

TileGeometry constructor. shape, wcs: The enmap geometry of the full space the
tiling covers. tile_shape: The (ny,nx) vertical and horizontal tile shape in
pixels. active: The list of active tile indices.

### _class_ pixell.tilemap.TileGeometry(shape, wcs, tile_shape, grid_shape,
tile_shapes, npixs, active, lookup)

#### grid2ind(ty, tx)

Get the index of the tile wiht grid coordinates ty,tx in the full tiling

#### ind2grid(i)

Get the tile grid coordinates ty, tx for tile #i in the full tiling

#### copy(pre=None, active=None, add_active=None)

#### _property_ pre

#### _property_ nactive

#### _property_ size

#### _property_ tiles

Allow us to get the enmap geometry of tile #i by writing tile_geom.tiles[i]

#### compatible(other)

Return our compatibility with binary operations with other. The return value
can be 2, 1 or 0: 2: Strictly compatible. Both the logical geometry (shape,
wcs), tile shape

> and active tiles match. This allows for direct numpy operations without any
> manual looping over tiles.

1: Loosely compatible. The logical and tile geometry match, but not the active
tiles. 0\. Not compatible.

### pixell.tilemap.to_enmap(tile_map)

### pixell.tilemap.redistribute(imap, comm, active=None, omap=None)

Redistirbute the data in the mpi-distributed tiles in imap into the active
tiles in omap, using the given communicator. If a tile is active in multiple
tasks in imap, it will be reduced. If it is active in multiple tiles in omap,
it will be duplicated.

### pixell.tilemap.tree_reduce(imap, comm, plan=None)

Given a tilemap imap that’s distributed over the communicator comm, and where
each tile is potentially present in multiple tasks, sum the duplicate tiles
and assign them to a single task, such that in the end each tile is present in
at most one task. Exactly which tiles end up in which tasks is determined
automatically but deterministically based on the tile ownership pattern in
imap.

### pixell.tilemap.get_active_distributed(tile_map, comm)

### pixell.tilemap.reduce(tile_map, comm, root=0)

Given a distributed TileMap tile_map, collect all the tiles on the task with
rank root (default is rank 0), and return it. Multiply owned tiles are
reduced. Returns a TileMap with no active tiles for other tasks than root.

### pixell.tilemap.write_map(fname, tile_map, comm, extra={})

Write a distributed tile_map to disk as a single enmap. Collects all the data
on a single task before writing.

* * *

## contributing

* * *

## authors

* * *

## history

# - Complete Documentation | pixell_tutorials -



---

# Pixell Part 1.md

---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Tutorial: CMB map analysis with ``pixell``


This tutorial will show you how to manipulate and analyze CMB maps. We'll work with a real map of the microwave sky obtained by the Atacama Cosmology Telescope and publicly released in 2014. That release included maps of many regions of the sky in both temperature and polarization. We will just work with the temperature map in a small but deep region of the sky, referred to by ACT as "Deep6".

You can download this map from the following Dropbox link:
https://www.dropbox.com/sh/6uzpsyb6a38811d/AAA0VkI6Ro1hTWnkQ1CSDrEta?dl=0

If you want to run this notebook, please place the map in the same directory as this notebook.

Most of the map manipulation functions are in ``pixell.enmap``, so let's load that along with ``numpy`` and ``matplotlib``.

```python
from __future__ import print_function
%load_ext autoreload
%autoreload 2
from pixell import enmap,utils
import numpy as np
import matplotlib.pyplot as plt
```

## Reading in a map and inspecting it

```python
filename = "actpol_deep6_temperature_car.fits" 
imap = enmap.read_map(filename,)
print(imap.shape, imap.dtype)

```

```python
print(imap.wcs)
enmap.box(imap.shape,imap.wcs)/utils.degree
```

```python
print(np.rad2deg(imap.box()))
# Y,X = (dec, ra)
# [[decfrom,rafrom],[[decto,rato]]
```

```python
plt.imshow(imap)
```

```python
plt.imshow(imap,vmin=-300,vmax=300)
```

## Visualizing maps with ``pixell.enplot``

```python
from pixell import enplot
plots = enplot.plot(imap,range=300,mask=0)
enplot.write("plots_example",plots)

def eshow(x,**kwargs): enplot.show(enplot.plot(x,**kwargs))
eshow(imap)
```

## Selecting regions of the map

```python
# [[decfrom,rafrom],[[decto,rato]]
dec,ra = np.deg2rad(np.array((-2.38,33.92)))
width = np.deg2rad(20./60.)
box = np.array([[dec-width/2.,ra-width/2.],[dec+width/2.,ra+width/2.]])
stamp = imap.submap(box)
plt.imshow(stamp)
plt.colorbar()

eshow(enmap.upgrade(stamp,5),grid=False, colorbar=True,color='gray')
```

```python
modrmap = stamp.modrmap()
plt.imshow(modrmap)
plt.colorbar()
```

```python
radius = np.deg2rad(2./60.)
flux_in = stamp[modrmap<radius].mean()
flux_out = stamp[modrmap>=radius].mean()
print(flux_out,flux_in)
```

## Slicing and downgrading

```python
smap = enmap.downgrade(imap[400:-300,900:-1200],4)
eshow(smap,range=300)
```

## Apodizing

```python
apod_pix=40
taper = enmap.apod(smap*0+1,apod_pix)
eshow(taper)
```

```python
eshow(smap*taper,range=300)
```

## Fourier transforms and filtering

```python
kmap = enmap.fft(smap*taper,normalize="phys")
print(kmap.shape)
print(kmap.wcs)
print(kmap.dtype)
```

```python
"""
A simple filter
"""

ells = np.arange(0,20000,1)
ell0 = 4500
ellsig = 500
fl = np.exp(-(ells-ell0)**2./2./ellsig**2.)

plt.plot(ells,fl)
plt.show()

modlmap = enmap.modlmap(smap.shape,smap.wcs)
modlmap = smap.modlmap()

plt.imshow(modlmap)
plt.show()
plt.imshow(np.fft.fftshift(modlmap))
plt.show()

```

```python
from scipy.interpolate import interp1d

fl2d = interp1d(ells,fl,bounds_error=False,fill_value=0)(modlmap)
plt.imshow(np.fft.fftshift(fl2d))
```

```python
kfiltered = kmap*fl2d
filtered = enmap.ifft(kfiltered,normalize="phys").real

eshow(filtered)
```

## Fourier transforms and naive power spectra

```python
power = (kmap*np.conj(kmap)).real
shifted_power = enmap.samewcs(np.fft.fftshift(np.log10(power)),smap)
eshow(shifted_power,grid=False)
```

## Binned power spectrum

```python
modlmap = smap.modlmap()
plt.imshow(np.fft.fftshift(modlmap))
plt.colorbar()
```

```python
def bin(data,modlmap,bin_edges):
    digitized = np.digitize(np.ndarray.flatten(modlmap), bin_edges,right=True)
    return np.bincount(digitized,(data).reshape(-1))[1:-1]/np.bincount(digitized)[1:-1]

bin_edges = np.arange(0,6000,40)
centers = (bin_edges[1:] + bin_edges[:-1])/2.
w2 = np.mean(taper**2.)
binned_power = bin(power/w2,modlmap,bin_edges)

plt.plot(centers,centers**2*binned_power,marker="o",ls="none")
plt.yscale('log')
plt.xlabel('$\\ell$')
plt.ylabel('$D_{\\ell}$')
plt.show()
```

## Comparing with theory

```python
from pixell import powspec
camb_theory = powspec.read_spectrum("camb_theory.dat")
cltt = camb_theory[0,0,:3000]
ls = np.arange(cltt.size)

plt.plot(ls,cltt*ls**2.,lw=3,color='k')
plt.plot(centers,centers**2*binned_power,marker="o",ls="none")
plt.yscale('log')
plt.xlabel('$\\ell$')
plt.ylabel('$D_{\\ell}$')
plt.show()

```

## Reprojecting a healpix map


NOTE: This section onwards requires you to have a compiled version of pixell.

```python
from pixell import reproject
pmap = reproject.enmap_from_healpix("planck_353.fits", smap.shape, smap.wcs, ncomp=1, unit=1, lmax=6000,rot="gal,equ")
```

```python
eshow(pmap)
```

## Cross-correlating Planck with ACT

```python
kmap2 = enmap.fft(pmap*taper*1e6,normalize="phys")
cross_power = (kmap*np.conj(kmap2)).real
binned_cross_power = bin(cross_power/w2,modlmap,bin_edges)

plt.plot(ls,cltt*ls**2.,lw=3,color='k')
plt.plot(centers,centers**2*binned_power,marker="o",ls="none")
plt.plot(centers,centers**2*binned_cross_power,marker="o",ls="none")
plt.yscale('log')
plt.xlabel('$\\ell$')
plt.ylabel('$D_{\\ell}$')
plt.show()
```

## Stacking

```python
from astropy.io import fits
# Download the cluster catalog from https://lambda.gsfc.nasa.gov/data/suborbital/ACT/actpol_2016_lensing/E-D56Clusters.fits
hdu = fits.open('E-D56Clusters.fits')
ras = hdu[1].data['RADeg']
decs = hdu[1].data['DECDeg']

# Write code to get stack
```

```python

```

```python

```


---

# Pixell Part 2.md

---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```python
%load_ext autoreload
%autoreload 2
from pixell import enmap,utils
import numpy as np
import matplotlib.pyplot as plt
```

## Understanding map geometeries


You can create a geometry for a given pixel width (resolution) centered at the origin of a CAR projection with 1024 pixels across as follows.

```python
shape,wcs = enmap.geometry(shape=(1024,1024),res=np.deg2rad(0.5/60.),pos=(0,0))
```

```python
print(shape)
print(wcs)
```

```python
posmap = enmap.posmap(shape,wcs)
print(posmap.shape)
```

```python
dec,ra = np.rad2deg(posmap)
plt.imshow(dec)
plt.colorbar()
plt.show()
plt.imshow(ra)
plt.colorbar()
plt.show()

```

```python
modrmap = enmap.modrmap(shape,wcs)
plt.imshow(np.rad2deg(modrmap))
plt.colorbar()
plt.show()
```

```python
pixmap = enmap.pixmap(shape,wcs)
py,px = pixmap
plt.imshow(py)
plt.colorbar()
plt.show()
plt.imshow(px)
plt.colorbar()
plt.show()
```

## Understanding 2D Fourier space

```python
ells = np.arange(0,4000,1)
ps = 1/ells**2.5
ps[:2] = 0
imap = enmap.rand_map(shape,wcs,ps[None,None])
plt.imshow(imap)
plt.show()
```

```python
kmap = enmap.fft(imap,normalize="phys")
print(kmap.shape)
print(kmap.dtype)
```

```python
lmap = enmap.lmap(shape,wcs)
print(lmap.shape)
lymap,lxmap = lmap
plt.imshow(lymap)
plt.colorbar()
plt.show()
plt.imshow(lxmap)
plt.colorbar()
plt.show()
```

```python
ly,lx = enmap.laxes(shape,wcs)
print(ly.shape,lx.shape)
print(ly)
print(lx)
```

```python
modlmap = enmap.modlmap(shape,wcs)
plt.imshow(modlmap)
plt.colorbar()
plt.show()
```

```python
plt.imshow(np.fft.fftshift(modlmap))
plt.colorbar()
plt.show()
```

```python
p2d = np.real(kmap * kmap.conj())
plt.imshow(p2d)
```


---

# PixellIntroduction.md

---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# CMB map analysis with ``pixell``
## An introduction


This tutorial will show you how to manipulate and analyze CMB maps. We'll work with a real map of the microwave sky obtained by the Atacama Cosmology Telescope and publicly released in 2014. That release included maps of many regions of the sky in both temperature and polarization. We will just work with the temperature map in a small but deep region of the sky, referred to by ACT as "Deep6".

If you want to run this notebook, please place the map in the same directory as this notebook.

Most of the map manipulation functions are in ``pixell.enmap``, so let's load that along with ``numpy`` and ``matplotlib``.

```python
from __future__ import print_function
%load_ext autoreload
%autoreload 2
from pixell import enmap,utils
import numpy as np
import matplotlib.pyplot as plt
import os,sys
import urllib.request
```

```python
# Download some files for the tutorial if they don't already exist.
# This might take a while.
# Couple 100 megabytes at most
deep6_file_name = "ACTPol_148_D6_PA1_S1_1way_I.fits"
catalog_name = "E-D56Clusters.fits"
links = [[deep6_file_name,f"https://lambda.gsfc.nasa.gov/data/suborbital/ACT/actpol_2016_maps/{deep6_file_name}"],
         [catalog_name,"https://lambda.gsfc.nasa.gov/data/suborbital/ACT/actpol_2016_lensing/{catalog_name}"]]
for fname,link in links: 
    urllib.request.urlretrieve(link, fname) if not(os.path.exists(fname)) else None

    
"""
Also download this 2GB file in a terminal in the background
wget https://irsa.ipac.caltech.edu/data/Planck/release_2/all-sky-maps/maps/HFI_SkyMap_143_2048_R2.02_full.fits
"""
planck_file_name = "HFI_SkyMap_143_2048_R2.02_full.fits"
```

## Reading in a map and inspecting it


In pixell, a map is encapsulated in an `ndmap`, which combines two objects: a numpy array (of at least two dimensions) whose two trailing dimensions correspond to two coordinate axes of the map, and a `wcs` object that specifies the World Coordinate System. The `wcs` component is an instance of Astropy’s `astropy.wcs.wcs.WCS class`. The combination of the `wcs` and the `shape` of the numpy array completely specifies the footprint of a map of the sky, and is called the geometry. pixell helps with manipulation of ndmap objects in ways that are aware of and preserve the validity of the `wcs` information.

pixell can read in rectangular pixelization maps stored with WCS info from either FITS files or HDF files. You are most likely to encounter FITS files. Either of these can be opened with the `read_map` function in the `pixell.enmap` module. Once loaded, you can inspect the usual properties that `numpy` arrays have:

```python
imap = enmap.read_map(deep6_file_name)
print(imap.shape, imap.dtype)

```

An ndmap must have at least two dimensions. The two right-most axes represent celestial coordinates (typically Declination and Right Ascension). Maps can have arbitrary number of leading dimensions, but many of the pixell CMB-related tools interpret 3D arrays with shape (ncomp,Ny,Nx) as representing Ny x Nx maps of intensity, polarization Q and U Stokes parameters, in that order.

The map we just loaded in is a CMB temperature/intensity map, so it is single component. It has shape (1505,3521) which means it has 1505 pixels in the Y-direction (which is declination, since the coordinate system used by ACT and most ground-based experiments is Equatorial) and 3521 pixels in the X-direction (which is right ascension in the Equatorial coordinate system).

But as an extension of numpy arrays, `ndmap` objects also contain the WCS object which you can inspect:

```python
print(imap.wcs)
```

You'll typically not need to worry about what those WCS keys mean; that's what pixell is here for! But it's  useful to know that the wcs information describes the correspondence between celestial coordinates (typically the Right Ascension and Declination in the Equatorial system) and the pixel indices in the two right-most axes. In some projections, such as CEA or CAR, rows (and columns) of the pixel grid will often follow lines of constant Declination (and Right Ascension). In other projections, this will not be the case.

ACT maps have been in CEA in the past and will be in CAR in the future. Again, pixell lets you be agnostic to the minor differences between these projections.

pixell.enmap contains many functions for manipulating and getting information on these maps. pixell.utils contains miscellaneous utilities. Here's an example of how to obtain the bounding box of a map and convert it to degrees (all units in pixell are by default in radians).

```python
enmap.box(imap.shape,imap.wcs)/utils.degree
```

You can also convert radians to degrees with:

```python
print(np.rad2deg(imap.box()))
```

Interpreting the above requires us to know some conventions pixell uses. The above is a coordinate bounding box. Since pixell orders coordinates as

Y,X <-> (dec, ra)

The bounding box has convention,
[[dec_from,ra_from],[[dec_to,ra_to]]

Later we will encounter pixel boxes, which specify bounding boxes in pixel index units. These have a similar convention.

## Visualizing maps with ``pixell.enplot``

One way to visualize maps is using matplotlib.imshow

```python
plt.imshow(imap)
```

Ok, so it didn't automatically learn the color scale very well. Let's explicitly specify it since the map is in microKelvin units and the CMB has fluctuations ~300 muK

```python
plt.imshow(imap,vmin=-300,vmax=300)
```

matplotlib does some interpolation and downgrading which doesn't make the plot very pretty or useful. pixell has a module called enplot which uses the Python Image Library (PIL) to improve the situation. You will need to do

```
pip install Pillow --user
```

to have the following work.

We first import the enplot module and create a `plots` object from the map we just loaded. We set the range to 300 muK and ask enplot to mask zero values in the map.

```python
from pixell import enplot
plots = enplot.plot(imap,range=300,mask=0)
```

Ok, that made the plots object. Now I can either "show" it here, or save it to disk as a PNG file. Let's first show it inline in the Jupyter notebook. 

```python
enplot.show(plots)
```

That's better!

Jupyter notebooks can be limiting though, so what I like to do is to save the image to disk as a PNG file, and use a very nice lightweight Linux tool called `feh` to open it.

```python
enplot.write("plots_example",plots)
# Note: no need to specify the file extension. Also, the plots image can be made from a stack of maps, i.e. maps that have additional leading dimensions.

# Optional
os.system("feh plots_example.png")
```

With feh, you can zoom in and pan around the image in a very intutitive manner, and freeze locations of different map images (with identical footprint) relative to each other. I don't know of a good equivalent of `feh` on Mac OS X, so feel free to drop recommendations on the Issues page.


## Selecting regions of the map
**Because your astronomer friend told you dec=-2.38 deg, ra = 33.92 deg has a little surprise**

Suppose you are interested in an object at 
dec=-2.38 deg, ra = 33.92 deg

and you want to look at a stamp around this location with width 20 arcminutes.

```python
dec,ra = np.deg2rad([-2.38,33.92])
width = np.deg2rad(20./60.)

```

You can construct a coordinate box for this region using the convention we saw earlier,
[[dec_from,ra_from],[[dec_to,ra_to]]
and use the submap function to create a new ndmap from the orginal full map that extracts this region

```python
box = [[dec-width/2.,ra-width/2.],[dec+width/2.,ra+width/2.]]
stamp = imap.submap(box)
```

Note that unlike vanilla numpy arrays, ndmaps have additional member functions like submap.

Instead of accessing these functions from the object with the dot operator, they can usually be accessed from the module itself. For example, the above is identical to

```
stamp = enmap.submap(imap,box)
```

Let's plot the stamp with matplotlib

```python
plt.imshow(stamp)
plt.colorbar()
```

So there was something mildly interesting there after all, a point source! We can also plot it using enplot:

```python
print(stamp.shape,stamp.wcs)
enplot.show(enplot.plot(stamp,grid=False, color='gray'))
```

Ok, so that's a bit small. That's because enplot by default displays the map *as is*, and does not try to upscale or downgrade it. Let's upgrade the stamp by a factor of 5 to display it.

```python
enplot.show(enplot.plot(enmap.upgrade(stamp,5),grid=False, colorbar=True,color='gray'))
```

To start to get some information out of this source, it would be good to have some handle on the geometry in a way that I don't have to think about things like pixel size. pixell has a ton of utilities for this. For example, I can quickly create a "map of distances from the center" on the same geometry as this stamp with the enmap.modrmap function or equivalently the member function modrmap of the stamp ndmap object.

```python
modrmap = stamp.modrmap() #1
# which is the same as
shape,wcs = stamp.shape, stamp.wcs
modrmap = enmap.modrmap(shape,wcs) #2
# Notice how you can do these calculations either with an existing map (#1) or with a geometry pair shape,wcs (#2) when you don't actually have a map in hand

```

The map of distances from the center looks like what you might have expected it to

```python
plt.imshow(modrmap)
plt.colorbar()
modrmap.wcs
```

But this handy map now lets us make quantitive assesments of the original map. For example, I can calculate the mean pixel value within a radius of 2 arcminutes and compare it to the value beyond 2 arcminutes.

```python
radius = np.deg2rad(2./60.)
flux_in = stamp[modrmap<radius].mean()
flux_out = stamp[modrmap>=radius].mean()
print(flux_out,flux_in)
```

## Slicing and downgrading


Pretty much any indexing trick you love doing on a numpy array, you can do on an ndmap as well. Most importantly, *the WCS automatically adjusts to it*. Here is an example where we trim off some of the edges of the map.

```python
smap = imap[400:-300,900:-1200]
print(imap.shape,imap.wcs)
print(smap.shape,smap.wcs)
```

Not only did you get a trimmed map, you also had its WCS updated in the process. Let's plot the trimmed map:


```python
enplot.show(enplot.plot(smap))
```

Let's downgrade the map by a factor of four. This is done internally through pixel averaging.
*WARNING*: Such operations generally introduce a pixel window function and change the power spectrum of the map, so you'll have to be careful about that when doing precision analysis.

```python
smap = enmap.downgrade(smap,4)
print(smap.shape,smap.wcs)
enplot.show(enplot.plot(smap,range=300))
```

It's worth reiterating this: the wcs information is correctly adjusted when the array is sliced or downgraded (any numpy index based operation and any pixell function will preserve and adjust wcs correctly ); for example the object returned by imap[:50,:50] is a view into the imap data attached to a new wcs object that correctly describes the footprint of the extracted pixels.

Many functions that act on numpy arrays (e.g. ufuncs) will also apply their operation on the numpy data within the ndmap and return back an ndmap with the same wcs. *Some* functions however (in particular, functions that do a np.asarray(x) on the input array x as opposed to a np.asanyarray(x) ) will destroy/detach the WCS information. In such cases, you can attach the original wcs information back on to the array in one of several ways.

```python
tmap = smap.copy() # let's test it out on a copy of the previous map
print(tmap.shape,tmap.wcs)
```

That map has WCS, good. Now let's pass it through a function which acts on numpy arrays and returns a numpy array but sadly destroys the WCS because internally it does a np.asarray(x) on the input array x instead of a np.asanyarray(x).

```python
nmap = np.fft.fftshift(tmap) # This is just an example function that clobbers WCS, don't pay attention to it specifically
print(nmap.shape)
print(nmap.wcs)
```

Ok, so you can see I lost my WCS info from that map. But not to worry, there are a couple of ways I can attach it back:

```python
nmap = enmap.samewcs(nmap,tmap)
print(nmap.shape,nmap.wcs)
# or like this
wcs = tmap.wcs
nmap = enmap.ndmap(nmap,wcs)
print(nmap.shape,nmap.wcs)
# or equivalently
nmap = enmap.enmap(nmap,wcs)
print(nmap.shape,nmap.wcs)
# Note that the names ndmap and enmap are used somewhat interchangeably within pixell.
```

## Apodizing


You will probably know that if we want to do any sort of harmonic analysis (up next), we require periodic boundary conditions. We can prepare an edge taper map on the same footprint as our map of interest smap using the pixell.enmap.apod function.

```python
apod_pix=40 # number of pixels at the edge to apodize
taper = enmap.apod(smap*0+1,apod_pix) # I pass in an array of ones the same shape,wcs as smap
enplot.show(enplot.plot(taper))
```

Applying this to my CMB map makes it have a nice zeroed edge:

```python
enplot.show(enplot.plot(smap*taper,range=300))
```

## Fourier transforms and filtering


Now that I have a map that has been prepared for harmonic analysis, I can take harmonic transforms of it that can be used to filter the map or calculate its power spectra. I'll first demonstrate "flat-sky" FFTs, since this patch is fairly close to the equator and not very large. These are much faster and still very accurate. They are also very convenient for applying 2-dimensional filters (e.g. if you wanted to mask out noisy modes that are horizontal or vertical in the map, as would be seen in ground-based CMB experiments).

We first calcualte the FFT of the tapered map, which will return an ndmap which is complex but has the same WCS. One can leave the FFT normalization to the default value as long as later IFFT operations also do so. However, it is very convenient to use the *physical* normalization convention designated within pixell (this is not the default) by passing "phys" to the normalize argument. This ensures that pixel area factors are applied such that the square of the FFT is the power spectrum in units of steradians, such that you don't have to think about pixel area factors when calculating the power. If you use this normalization, just make sure you use it again in any subsequent IFFT operations.

```python
kmap = enmap.fft(smap*taper,normalize="phys")
print(kmap.shape)
print(kmap.wcs)
print(kmap.dtype)
print(kmap)
```

This provides a 2D map of the same shape and wcs as the original real space map, but now the numpy data is a complex 2D array that contains the complex FFT. Each pixel in this map corresponds to a Fourier pixel in the 2D Fourier space.

Great, now that we have the FFT, we can apply a simple filter by multiplying the FFT by a 2D function of our choice. But first we need to know what Fourier frequency values correspond to each Fourier pixel. Just like a real space map would have declination and right ascension values for each pixel, each Fourier pixel will have a corresponding `ly` and `lx` Fourier pixel frequency value. We can obtain this using the `enmap.lmap` function which wraps knowledge of the physical extent of the map around numpy's `np.fft.fftfreq`.



```python
lymap,lxmap = smap.lmap()
plt.imshow(lymap)
plt.show()
plt.imshow(lxmap)
plt.show()
```

Remember, these are maps of the `ly` and `lx` Fourier frequency in each Fourier pixel of the map.
If you're used to working with FFTs, you'll notice the convention is such that the positive frequencies come first, followed by increasing negative frequencies. You can show these in the more intuitive zero-centered form by using np.fft.fftshift (which as we saw earlier, destroys WCS information, so watch out for that).

```python
plt.imshow(np.fft.fftshift(lymap)) ; plt.show()
plt.imshow(np.fft.fftshift(lxmap)) ; plt.show()
```

While Fourier frequencies are better visualized zero-centered (so that fftshift is applied just before and only for plotting), we don't recommend actually ever storing such Fourier frequencies arrays in their shifted form, since that breaks convention and is also just unnecessary as long as you use maps like these to index the Fourier pixels of interest.

Most often you will want to apply *isotropic* operations, which do not distinguish `ly` and `lx`, so for these a map of the magnitude of the distance in Fourier space from zero is useful, which is just the sum of squares of the above. There is a convenience function for this that is very commonly used.

```python
modlmap = smap.modlmap()
plt.imshow(np.fft.fftshift(modlmap)) ; plt.colorbar() ; plt.show()
```

Ok, let's build a simple isotropic filter that tries to mimic a point source finder. We want to downweight large scales dominated by CMB and downweight small scales dominated by instrument noise to find objects that are roughly a few arcminutes in size.

```python
"""
I make my simple filter centered on ell of 4500 with a spread of 500
"""

ells = np.arange(0,20000,1)
ell0 = 4500
ellsig = 500
fl = np.exp(-(ells-ell0)**2./2./ellsig**2.)

# I plot the 1d filter

plt.plot(ells,fl)
plt.show()


```

I can now interpolate this 1D filter on to the 2D grid using the Fourier distances modlmap.

```python
from scipy.interpolate import interp1d

fl2d = interp1d(ells,fl,bounds_error=False,fill_value=0)(modlmap)
plt.imshow(np.fft.fftshift(fl2d))
```

As desired, this is an isotropic ring that isolates all Fourier modes of rough magnitude around 4500. Now I filter the map by multiplying it's Fourier tranform by this 2D filter, and then inverse FFTing it back with the same normalization I used before.

```python
kfiltered = kmap*fl2d
filtered = enmap.ifft(kfiltered,normalize="phys").real

enplot.show(enplot.plot(filtered))
```

That kind of worked? I seem to have found some regions where point sources live! We can do much better with a proper matched filter, but that's beyond the scope of this tutorial.


## Fourier transforms and naive power spectra


I can calculate the 2D power spectrum by squaring the Fourier transform. Since the normalization was "physical", I don't have to worry about any pixel area scaling factors.

```python
power = (kmap*np.conj(kmap)).real
# I'll FFT shift and log transform the power to visualize it
shifted_power = enmap.samewcs(np.fft.fftshift(np.log10(power)),smap)

plt.imshow(shifted_power) ; plt.show()
#enplot.show(enplot.plot(shifted_power,grid=False))
```

You are looking at the power spectrum of the map. It looks fairly isotropic. This is what you would expect of most things in the map (like the CMB, some part of the instrument noise, extragalactic foregrounds, but not for Galactic foregrounds or for anisotropic instrument noise, ground pickup).

To compare this to theoretical expectations, we have to bin the 2D power spectrum in annuli.


## Binned power spectrum

```python
# This is a simple binning function that finds the mean in annular bins defined by bin_edges
def bin(data,modlmap,bin_edges):
    digitized = np.digitize(np.ndarray.flatten(modlmap), bin_edges,right=True)
    return np.bincount(digitized,(data).reshape(-1))[1:-1]/np.bincount(digitized)[1:-1]

bin_edges = np.arange(0,6000,40)
centers = (bin_edges[1:] + bin_edges[:-1])/2.
binned_power = bin(power,modlmap,bin_edges)

plt.plot(centers,centers**2*binned_power,marker="o",ls="none")
plt.yscale('log')
plt.xlabel('$\\ell$')
plt.ylabel('$D_{\\ell}$')
plt.show()
```

That's looking pretty good! You should be able to see a hint of acoustic oscillations from the CMB itself. Let's compare this to theory.


## Comparing with theory


pixell's powspec module has utilities to facilitate loading theory C_ells from CAMB outputs. We plot our measurement against it.

```python
from pixell import powspec
camb_theory = powspec.read_spectrum("camb_theory.dat")
cltt = camb_theory[0,0,:3000]
ls = np.arange(cltt.size)

plt.plot(ls,cltt*ls**2.,lw=3,color='k')
plt.plot(centers,centers**2*binned_power,marker="o",ls="none")
plt.yscale('log')
plt.xlabel('$\\ell$')
plt.ylabel('$D_{\\ell}$')
plt.show()

```

This looks a bit low. The reason for that is that we have forgotten that we applied a taper to facilitate the Fourier transform. This taper zeroes out a fraction of the map, which means it lowers the average power spectrum of the map. The proper full treatment of this is to also account for the fact that the mask couples different Fourier modes. Knowledge of the mask allows us to decouple this. pixell does not have code to do that; but codes like `namaster`, `pspy` and `pitas` are designed to properly do this, so check those out!

We can however get an approximate correction. Since the power spectrum squares the map, an approximate accounting for the loss in power is:

```python
w2 = np.mean(taper**2.)
#enmap.map2harm(imap) #(3,100,100)
#curvedsky.map2alm
```

Dividing the raw power by this factor gets us much better agreement:

```python

plt.plot(ls,cltt*ls**2.,lw=3,color='k')
plt.plot(centers,centers**2*binned_power / w2,marker="o",ls="none")
plt.yscale('log')
plt.xlabel('$\\ell$')
plt.ylabel('$D_{\\ell}$')
plt.show()
```

We only recommend such an approach for quick diagnostic power spectra for debugging or exploration, or for applications to situations where the underlying power spectrum is not so red (rapidly falling). For precision analysis, a mask deconvolution algorithm like that in `namaster`, `pspy` or `pitas` should be used.

<!-- #region -->
## Spherical harmonic analysis
NOTE: This section onwards requires you to have a compiled version of pixell.


We'll do this live if there's time.
<!-- #endregion -->

```python
from pixell import curvedsky
import healpy as hp
from pixell import enmap

# libsharp does not have ring weights for the old ACT CEA pixelization
# so we reproject to the new ACT CAR pixelization

shape,wcs = enmap.geometry(pos=smap.box(),res=np.deg2rad(0.5/60.),proj='car')
pmap = enmap.project(smap,shape,wcs,order=3)

```

```python
alms = curvedsky.map2alm(pmap,lmax=6000)

```

```python
print(alms)
```

```python
cls = hp.alm2cl(alms)
lcls = np.arange(cls.size)

# Area correction ; this should actually be a taper-weighted area calculation
w2f = enmap.area(smap.shape,smap.wcs) / 4. / np.pi

plt.plot(ls,cltt*ls**2.,lw=3,color='k')
plt.plot(lcls,cls*lcls**2./w2f,lw=3,color='red')
plt.plot(centers,centers**2*binned_power / w2,marker="o",ls="none")
plt.yscale('log')
plt.xlabel('$\\ell$')
plt.ylabel('$D_{\\ell}$')
plt.show()
```

## Reprojecting a healpix map


A simple way to reproject a healpix map to the same geometry of the rectangular pixel map you are working with is to :
1. spherical harmonic transform the healpix map to alm's
2. inverse spherical harmonic transform the alm's to the rectangular pixel map geometry

The pixell.reproject module has a function that does this. You can also apply a rotation of the coordinate system from Galactic to Equatorial.

```python
from pixell import reproject
pmap = reproject.enmap_from_healpix(planck_file_name, smap.shape, smap.wcs, ncomp=1, unit=1, lmax=6000,rot="gal,equ")
```

```python
#enplot.show(enplot.plot(pmap))

enplot.write("planck_map",enplot.plot(pmap))

```

```python
enplot.write("act_map",enplot.plot(smap))

```

## Cross-correlating Planck with ACT


We can now cross-correlate this map with the ACT map on the same footprint. 

```python
kmap2 = enmap.fft(pmap*taper*1e6,normalize="phys")
cross_power = (kmap*np.conj(kmap2)).real
binned_cross_power = bin(cross_power/w2,modlmap,bin_edges)

plt.plot(ls,cltt*ls**2.,lw=3,color='k')
plt.plot(centers,centers**2*binned_power,marker="o",ls="none")
plt.plot(centers,centers**2*binned_cross_power,marker="o",ls="none")
plt.yscale('log')
plt.xlabel('$\\ell$')
plt.ylabel('$D_{\\ell}$')
plt.show()
```

Can you guess why the orange points are so different from the blue points?


## Stacking


We have a nice deep CMB map, and we have a catalog of SZ clusters. Why don't we stack on the location of these clusters to see the average signal?

```python
from astropy.io import fits

hdu = fits.open('E-D56Clusters.fits')
ras = hdu[1].data['RADeg']
decs = hdu[1].data['DECDeg']

# Write code to get stack
N = len(ras)
print(N)
print(smap.shape)
stack = 0
for i in range(N):
    # Extract stamps by reprojecting to a tangent plane projection
    stamp = reproject.postage_stamp(smap,ras[i],decs[i],20.,0.5)
    if stamp is None: continue 
    stack += stamp[0]
    
stack /= N

```

```python
plt.imshow(stack) ; plt.show()
```

## Masking


Mask from source locations

```python
r = np.deg2rad(5./60.)
srcs = np.deg2rad([decs,ras])
dmap = enmap.downgrade(imap,2)
mask = enmap.distance_from(dmap.shape,dmap.wcs,srcs, rmax=r) >= r

enplot.write('imap',enplot.plot(dmap,range=200))
enplot.write('mask',enplot.plot(mask))
enplot.show(enplot.plot(mask))

```

Binary mask from thresholding

```python
mask = dmap.copy()
mask[np.abs(mask)<1e-3] = 0
mask[np.abs(mask)>1e-3] = 1
plt.imshow(mask) ; plt.show()
```

```python

```


---

# PixellSoapackSymlens.md

---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```python
%load_ext autoreload
%autoreload 2
from pixell import enmap,enplot
import numpy as np
import symlens
import soapack.interfaces as sints
```

pixell : https://github.com/simonsobs/pixell/

soapack : https://github.com/simonsobs/soapack

symlens : https://github.com/simonsobs/symlens


# pixell + soapack + symlens demo


## Loading an ACT map with soapack

```python
mask = sints.get_act_mr3_crosslinked_mask('deep6',version="180323")
dm = sints.ACTc7v5(region=mask)
imap = dm.get_coadd("S1","D6","PA1",ncomp=1)
```

## Plotting an ACT map with pixell

```python
enplot.show(enplot.plot(imap,downgrade=4,colorbar=True))
enplot.show(enplot.plot(mask,downgrade=4,colorbar=True))
```

```python
tmap = imap*mask
enplot.show(enplot.plot(tmap,downgrade=4,colorbar=True))
```

## Map manipulation with pixell + lensing reconstruction with symlens

```python
# Get geometry and fourier info
shape,wcs = tmap.shape,tmap.wcs
modlmap = enmap.modlmap(shape,wcs)

# Build a beam
fwhm = 1.4
kbeam = np.exp(-(np.deg2rad(fwhm / 60.)**2.)*(modlmap**2.) / (16.*np.log(2.)))

# Get theory spectrum
ells,cltt = np.loadtxt("cltt.txt",unpack=True)

# Build interpolated 2D Fourier CMB theory
ucltt2d = np.interp(modlmap,ells,cltt)
# And total noise power for filters
tcltt2d = ucltt2d + np.nan_to_num((10.*np.pi/180./60.)**2./kbeam**2.)

# Build a Fourier space mask
kmask = modlmap*0+1
kmask[modlmap<500] = 0
kmask[modlmap>3000] = 0

# Get beam deconvolved fourier map
kmap = np.nan_to_num(enmap.fft(tmap,normalize="phys")/kbeam)

# Build symlens dictionary
feed_dict = {
    'uC_T_T' : ucltt2d,
    'tC_T_T' : tcltt2d,
    'X' : kmap,
    'Y' : kmap,
}

# Ask for reconstruction in Fourier space
krecon = symlens.reconstruct(shape, wcs, feed_dict, estimator="hu_ok", XY="TT", xmask=kmask, ymask=kmask, kmask=kmask,pixel_units=False)
```

```python
# Transform to real space and plot
kappa = enmap.ifft(krecon,normalize="phys").real
enplot.show(enplot.plot(enmap.downgrade(kappa,4),colorbar=True))
```

```python

```


---

# Sims.md

---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Tutorial: Simulating the CMB with ``pixell``


This tutorial will show you how to simulate CMB temperature and polarization both on the flat and full skies. 

```python
from __future__ import print_function
from pixell import enmap,curvedsky,utils,powspec,enplot
import numpy as np
import matplotlib.pyplot as plt
```

## Full sky geometry

```python
ps,_ = powspec.read_camb_scalar("test_scalCls.dat")
shape,wcs = enmap.fullsky_geometry(res=np.deg2rad(20./60.))
shape = (3,) + shape
```

```python
omap = curvedsky.rand_map(shape,wcs,ps=ps,lmax=1000,spin=[0,2])
```

```python
enplot.show(enplot.plot(omap[1],color='gray'))
```

## Cut-sky FFT based sim

```python
shape,wcs = enmap.geometry(shape=(500,500),pos=(0,0),res=np.deg2rad(20./60.))
shape = (3,) + shape
print(shape,ps.shape)
omap = enmap.rand_map(shape,wcs,cov=ps)
print(omap.shape)
```

```python
print(omap.shape)
enplot.show(enplot.plot(omap[1],color='gray'))
enplot.show(enplot.plot(omap[2],color='gray'))
```

```python

```


---

# pixell_fourier_space_operations.md

---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3
    name: python3
---

<!-- #region id="bnfTRYooztmN" -->
# Fourier Operations with pixell

*Written by the ACT Collaboration*

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/simonsobs/pixell_tutorials/blob/master/pixell_fourier_space_operations.ipynb)


---

This notebook, and the accompanying notebooks included in this set, are designed to help users who are new to working with [`pixell`](https://github.com/simonsobs/pixell/) get started with the package. As a set these notebooks will guide users through examples of how to read in and display maps, how to perform spherical harmonic transform and calculate simple spectra, how to transform the maps and how to study point sources in the maps.

The `pixell` library allows users to load,
manipulate and analyze maps stored in rectangular pixelization. It is
mainly targeted for use with maps of the sky (e.g. CMB intensity and polarization maps, stacks of 21 cm intensity maps, binned galaxy positions or shear) in cylindrical projection.


In this notebook, we walk through common Fourier-space operations in `pixell`. A similar set of exercises is available in [this](https://github.com/ACTCollaboration/DR4_DR5_Notebooks/blob/master/Notebooks/Section_7_power_spectra_part_1.ipynb) ACT DR4/DR5 notebook.
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/"} id="GPzMLmYO98my" outputId="0563e047-18fa-48b4-9a46-ca5a0e691e4f"
# Download the data needed for the notebook
!wget -O act_planck_dr5.01_s08s18_AA_f150_night_map_d56.fits https://phy-act1.princeton.edu/public/zatkins/act_planck_dr5.01_s08s18_AA_f150_night_map_d56.fits
```

```python colab={"base_uri": "https://localhost:8080/"} id="kDFKT4bz89Ra" outputId="596d0504-6039-4509-99ba-f1e270ee7751"
# Install neccesary packages
!pip install pixell
```

<!-- #region id="d8VPWKGMLNCu" -->
In this notebook, we will again work with a (cutout of) the ACT DR5+Planck coadd map, in the "deep 56" region. We import the `enmap` module as before, which has most of what we'll need, but we'll also take a peak under-the-hood at some low-level Fourier transform-related code in the `fft` module. Let's import packages and take a look at the map:
<!-- #endregion -->

```python id="s3We41ht94xX"
# Import packages
from pixell import enmap, fft, enplot
import numpy as np
import matplotlib.pyplot as plt
```

```python colab={"base_uri": "https://localhost:8080/"} id="NX2A3eIk-y0J" outputId="8e3966f0-5f40-4c26-90f0-dae9cf641397"
# Code to read and plot maps
imap = enmap.read_map("act_planck_dr5.01_s08s18_AA_f150_night_map_d56.fits")

print(imap.geometry, imap.dtype)
```

<!-- #region id="DqdIuVpdMRlS" -->
We see there are 3 components in this data. Following convention, this means this map is *polarized*, with intensity (I), and polarization (Q and U). Let's plot the polarized components. Do this in a for loop over components so that the colorbar is automatically adjusted for each component separately:
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 1000} id="HENNNeioMO-d" outputId="cf3ac4d6-e5f8-493c-a43c-41cd23a56b2d"
for i in range(3):
  enplot.pshow(imap[i], downgrade=4, colorbar=True)
```

<!-- #region id="BZS6JX6qOL52" -->
Cool! We saw the intensity map in a previous notebook. What interests you about the polarization components, Q and U? Anyway, we'll get to them later and deal with intensity only for now:
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 389} id="0lEEld9MOXBP" outputId="9e269fbf-3a15-43b1-e2fa-d4039fb903b2"
imap_I = imap[0] # get the intensity component of the map for now

enplot.pshow(imap_I, downgrade=4, colorbar=True)
```

<!-- #region id="Rj46bvfSzsTm" -->
By now, you should have a little experience with fourier transforms, especially 2d transforms, on numpy arrays (if not, you should refresh yourself by walking through [this CMB school notebook](https://github.com/jeffmcm1977/CMBAnalysis_SummerSchool/blob/master/CMB_School_FFT_intro.ipynb)). Remember, an `ndmap` is just a numpy array with a `wcs` object attached! So everything we learned there about conventions carries over here.

`pixell` has its own Fourier-transform functions that we'll want to use instead of numpy's. One reason is that it will preserve the `wcs`, but also because `pixell` makes available some additional features that will be useful to us as cosmologists.

Let's start by taking a simple 2d fft. It is commonly the case that we will have a map that has some "hard edge" or is does not have continuous boundary conditions like a fullsky map does. In this case, it is very important that we "apodize" the map by applying a smooth taper to it, to give it continuous boundary conditions:
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 742} id="OIrPPHoS7jyi" outputId="491195cd-8a66-47a3-9b0f-eb64b80a270f"
# get an apodized mask that smoothly tapers the edge of the map
# we use a taper width of 100 pixels -- what is the size of that in
# arcminutes?
taper_mask = enmap.apod(enmap.ones(imap_I.shape, imap_I.wcs), width=100)

enplot.pshow(taper_mask, downgrade=4, colorbar=True)

# we can also taper the map we want directly
imap_I_apod = imap_I.apod(width=100)

enplot.pshow(imap_I_apod, downgrade=4, colorbar=True)
```

<!-- #region id="aY_rRxR_bk2k" -->
Now take the fft:
<!-- #endregion -->

```python colab={"background_save": true, "base_uri": "https://localhost:8080/", "height": 709} id="15029jNEbmpv" outputId="1098f96f-c063-4f95-8686-6f8b2f680895"
# Take a simple fourier transform first.
# normalize='phys' means the fft normalization accounts for the
# physical pixel size, unlike numpy which just normalizes by the
# number of pixels. this is one of pixell's key features for
# cosmology vs numpy!
kmap = enmap.fft(imap_I_apod, normalize='phys')

# remember, fft's have real and imaginary components
enplot.pshow(kmap.real, downgrade=4)
enplot.pshow(kmap.imag, downgrade=4)
```

<!-- #region id="rW-kaGZCWxU_" -->
There are a couple things here which don't make immediate sense with the 2d fft.

First: it looks like all the "action" is in the corners of Fourier space. Remember, this was a quirk of the numpy fft convention! Low frequency modes are at the edges of the Fourier transform, and high frequency modes are in the middle. We can make sense of this using `pixell`. Let's first make a plot of the 2d Fourier coordinates themselves:
<!-- #endregion -->

```python colab={"background_save": true, "base_uri": "https://localhost:8080/", "height": 691} id="TsU6MAQuTt2d" outputId="87e6bec6-e1d9-464d-e48e-4cf8215e1583"
# get the coordinates of the map in Fourier space
ly, lx = imap.lmap()

enplot.pshow(ly, downgrade=4, colorbar=True, grid=False)
enplot.pshow(lx, downgrade=4, colorbar=True, grid=False)
```

<!-- #region id="LVdCuqJlyv9r" -->
The first map is the "y" Fourier component; it varies as you move up and down but not left and right. The second map is the "x" component; it varies as you move left and right but not up and down. The "origin" -- the (0, 0) coordinate -- of Fourier space is in the corner, just like in the CMB school FFT notebook, and the biggest value is in the middle. We can use `pixell` to make a map of the distance from 0 in Fourier space too. Bigger numbers mean *smaller* angular scales, and smaller numbers mean *larger* angular scales:
<!-- #endregion -->

```python colab={"background_save": true, "base_uri": "https://localhost:8080/", "height": 389} id="C5ashsJpzvI7" outputId="ba0efe1b-f3ad-469a-8f39-3d867a552b1b"
# this is equivalent to sqrt(lx**2 + ly**2)
modl = imap.modlmap()

enplot.pshow(modl, downgrade=4, colorbar=True)
```

<!-- #region id="-ZMGTJFTkGFN" -->
Second, we are in Fourier space: what's the deal with the gridlines? They are the same as the original map -- telling us about dec and RA -- but Fourier space is, well, not map space! This is because `enmap.fft` preserves the `wcs` of the input. Mainly as a plotting convenience, we can get the "`wcs`" of Fourier space too, so that the gridlines correspond to Fourier modes. We can also do the "fftshift" so that the origin of Fourier space gets shifted to the map center. Both of these features are really most convenient for plotting, we don't really need to worry about this so long as we respect the numpy convention:
<!-- #endregion -->

```python colab={"background_save": true, "base_uri": "https://localhost:8080/", "height": 1000} id="1p54OOm2Zfud" outputId="8a66abde-2a1e-40bf-f80d-d4849bf14b85"
kwcs = enmap.lwcs(kmap.shape, kmap.wcs)

# reassign the wcs of kmap to be kwcs
kmap_for_plotting = enmap.ndmap(kmap, kwcs)
kmap_for_plotting = enmap.fftshift(kmap_for_plotting)

modl_for_plotting = enmap.ndmap(modl, kwcs)
modl_for_plotting = enmap.fftshift(modl_for_plotting)

enplot.pshow(kmap_for_plotting.real, downgrade=4, colorbar=True, ticks=3000)
enplot.pshow(kmap_for_plotting.imag, downgrade=4, colorbar=True, ticks=3000)
enplot.pshow(modl_for_plotting, downgrade=4, colorbar=True, ticks=3000)
```

<!-- #region id="neNUIFCq1uHM" -->
So most of the information in the ACT DR5 maps -- where the big noisy blue and red blob is in the first two plots -- corresponds to large angular scales -- small numbers in the 3rd map.

## Power spectrum

Let's use `pixell` to make a power spectrum. A power spectrum tells us "how pronounced features in the map are as a function of their size."

We will bin the power of the Fourier transformed CMB map (the squared amplitude) in rings of constant angular scales. For this we can use the `enmap.lbin` function:
<!-- #endregion -->

<!-- #region id="tRk_HWUS457m" -->

<!-- #endregion -->

```python id="2x5l8qSD2q72"
power_spectrum, ell_b = enmap.lbin(abs(kmap)**2, bsize=40) # bin width of 40 in ell

# The taper we applied earlier affects the power spectrum.
# Pixell can't fully account for how the taper modifies the power spectrum
# But we can get an approximate correction by dividing out the following term
w2 = np.mean(taper_mask**2)
power_spectrum /= w2
```

```python colab={"base_uri": "https://localhost:8080/", "height": 475} id="8CwujwRl3318" outputId="03f1bfb5-bf2b-4c27-c001-c070c415089e"
# the ell*(ell+1)/2pi factor is just another cosmology convention
plt.semilogy(ell_b, power_spectrum * ell_b*(ell_b+1) / 2 / np.pi, marker='.', ls='none')
plt.xlim(0, 3500)
plt.ylim(1e2, 1e4)
```

<!-- #region id="_RoDs_A0F0Kh" -->
Cool! This means that as the Fourier coordinates get farther from 0 -- as we move from *larger to smaller angular scales in the map* -- generally the amount of features goes down. Large scale features are more pronounced than small scale features. Does this seem true when you look back at the plots at the beginning of the notebook? What else stands out about the power spectrum from scales of ~0 to ~1500?

At a certain point, around 1500, the power spectrum turns upwards again -- what does this mean? What could be driving that feature?

## Polarization

What about the Q and U maps? We need a special kind of Fourier transform to understand their cosmological information. Once we get their Fourier transforms, we need to turn their Q and U modes into what are called "E" and "B" modes. You can explore more about the relationship between Q, U, E, and B in [this notebook](https://github.com/jeffmcm1977/CMBAnalysis_SummerSchool/blob/master/CMB_School_Part_07.ipynb).

Fortunately, `pixell` does that for us. Instead of using `enmap.fft`, we'll use a different function:
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/"} id="EyZH7NfpHJ4x" outputId="353f541b-3fbf-451f-ab8c-e3c61b74fcf1"
imap_apod = imap.apod(width=100)

# use enmap.map2harm
kmap_polarized = enmap.map2harm(imap_apod, normalize='phys')

# now we have a *polarized* Fourier transform, check out the shape
print(kmap_polarized.shape)

# we can get the power spectrum of each polarization
# intensity will be the same, but we will also get E*E and B*B
power_spectra = []
for i in range(3):
  power_spectrum, ell_b = enmap.lbin(abs(kmap_polarized[i])**2, bsize=40)
  power_spectra.append(power_spectrum)
```

```python colab={"base_uri": "https://localhost:8080/", "height": 475} id="zMCP7L8bH2WV" outputId="a0853983-515f-4cd4-f93d-ae5b521ed148"
for i in range(3):
  plt.semilogy(ell_b, power_spectra[i] * ell_b*(ell_b+1) / 2 / np.pi, marker='.', ls='none', label=['TT', 'EE', 'BB'][i])
plt.xlim(0, 3500)
plt.ylim(1e-1, 1e4)
plt.legend()
```

<!-- #region id="_harQed7IIIc" -->
The blue line is the same as the first power spectrum plot we made. What do you notice about the EE and BB power spectra?

## Exercise

In ACT, we often remove some Fourier modes from the maps -- ie, set their values to 0 -- before calculating the power spectrum. In particular, we set the Fourier modes where |lx| < 90 and |ly| < 50 to 0. This is because we think these modes are contaminated by picking up the signal from the ground near the telescope.

Adapt the code above to do this, and remeasure the polarized power spectra. Does the way they have changed make sense? Can you write more code that will correct for the change?
<!-- #endregion -->

```python id="6kw1NaHIKA6g"

```


---

# pixell_map_manipulation.md

---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3
    name: python3
---

<!-- #region id="view-in-github" colab_type="text" -->
<a href="https://colab.research.google.com/github/simonsobs/pixell_tutorials/blob/master/pixell_map_manipulation.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>
<!-- #endregion -->

<!-- #region id="yPF5lzLN9DJB" -->
# Map Manipulation with pixell


*Written by the ACT Collaboration*

---

This  notebook, and the accompanying notebooks included in this set, are designed to help users who are new to working with [`pixell`](https://github.com/simonsobs/pixell/) get started with the package. As a set these notebooks will guide users through examples of how to read in and display maps, how to perform spherical harmonic transform and calculate simple spectra, how to transform the maps and how to study point sources in the maps.

The `pixell` library allows users to load,
manipulate and analyze maps stored in rectangular pixelization. It is
mainly targeted for use with maps of the sky (e.g. CMB intensity and polarization maps, stacks of 21 cm intensity maps, binned galaxy positions or shear) in cylindrical projection.

In this introductory notebook we will explain the basis for the sky maps used in `pixell` and walk through examples of how to read in CMB maps and inspect them. We'll also explain how to relate the pixels to locations on the sky and how to inspect smaller patches of the sky.
<!-- #endregion -->

```python id="GPzMLmYO98my"
# Download the data needed for the notebook
!wget -O act_planck_dr5.01_s08s18_AA_f150_night_map_d56_I.fits https://phy-act1.princeton.edu/public/zatkins/act_planck_dr5.01_s08s18_AA_f150_night_map_d56_I.fits
```

```python id="kDFKT4bz89Ra"
# Install neccesary packages
!pip install pixell
```

```python id="s3We41ht94xX"
# Import packages
from pixell import enmap, utils, enplot
import numpy as np
```

<!-- #region id="RFGNWqMC9yb5" -->
## About `pixell` and `ndmap` objects

The `pixell` library supports manipulation of sky maps that are represented as 2-dimensional grids of rectangular pixels. The supported projection and pixelization schemes are a subset of the schemes supported by FITS conventions. In addition, we provide support for a *plain* coordinate system, corresponding to a Cartesian plane with identically shaped pixels (useful for true flat-sky calculations).

In `pixell`, a map is encapsulated in an `ndmap`, which combines two objects: a numpy array (of at least two dimensions) whose two trailing dimensions correspond to two coordinate axes of the map, and a `wcs` object that specifies the World Coordinate System. The `wcs` component is an instance of Astropy’s `astropy.wcs.wcs.WCS` class. The combination of the wcs and the shape of the numpy array completely specifies the footprint of a map of the sky, and is called the `geometry`. This library helps with manipulation of `ndmap` objects in ways that are aware of and preserve the validity of the wcs information.

The `wcs` information describes the correspondence between celestial coordinates (typically the Right Ascension, or RA, in the Equatorial system) and the pixel indices in the two right-most axes. In some projections, such as CEA or CAR, rows (and columns) of the pixel grid will often follow lines of constant declination (and RA). In other projections, this will not be the case.

The WCS system is very flexible in how celestial coordinates may be associated with the pixel array. By observing certain conventions, we can make life easier for users of our maps. We recommend the following:

The first pixel, index [0,0], should be the one that you would normally display (on a monitor or printed figure) in the lower left-hand corner of the image. The pixel indexed by [0,1] should appear to the right of [0,0], and pixel [1,0] should be above pixel [0,0]. (This recommendation originates in FITS standards documentation.)
When working with large maps that are not near the celestial poles, RA should be roughly horizontal and declination should be roughly vertical. (It should go without saying that you should also present information “as it would appear on the sky”, i.e. with RA increasing to the left!)
The examples in the rest of this document are designed to respect these two conventions.
<!-- #endregion -->

<!-- #region id="a34eVMiNhajB" -->
### Creating an `ndmap`

We can define an `ndmap` by using `pixell` to specify a geometry. For example, if we want to create an empty map we would do the following:


<!-- #endregion -->

```python id="fKrkMasI2tCN"
# Define area of map using numpy
# pixell wants the box in the following format:
# [[dec_from, RA_from], [dec_to, RA_to]]
# Note RA goes "from" left "to" right!
box = np.array([[-5, 10], [5, -10]]) * utils.degree

# Define a map geometry
# the width and height of each pixel will be .5 arcmin
shape, wcs = enmap.geometry(pos=box, res=0.5 * utils.arcmin, proj='car')

# Create an empty ndmap
empty_map = enmap.zeros((3,) + shape, wcs=wcs)
```

<!-- #region id="Q3g5_r_shIAl" -->
## Inspecting maps

The `ndmap` class extends the `numpy.ndarray` class, and thus has all of the usual attributes (`.shape`, `.dtype`, etc.) of an `ndarray`. It is likely that an `ndmap` object can be used in any functions that usually operate on an ndarray; this includes the usual numpy array arithmetic, slicing, broadcasting, etc.

An `ndmap` must have at least two dimensions. The two right-most axes represent celestial coordinates (typically declination and RA, respectively). Maps can have arbitrary number of leading dimensions, but many of the `pixell` CMB-related tools interpret 3D arrays with shape `(ncomp,Ny,Nx)` as representing `Ny` x `Nx` maps of intensity, polarization Q and U Stokes parameters, in that order.
<!-- #endregion -->

```python id="5XRFJaPKokI0"
# Check out the ndmap
# does the shape make sense given the bounding box and resolution?
print(empty_map.shape)
print(empty_map.dtype)
print(empty_map + np.pi)
print(empty_map[0, 10:15, 90:95] == 0)
```

<!-- #region id="uFKarnbjor6r" -->
The `ndmap` also has a new attribute, the `wcs`:
<!-- #endregion -->

```python id="8sb4i_JahHPd"
print(empty_map.wcs)
```

<!-- #region id="6ccUogf63Vn1" -->
It has everything we need to map pixels to and from the sky: the cylindrical projection we are using (`car`), the size of the pixels (in degrees), the location on the sky of a reference pixel (in degrees) and the location in the array of the reference pixel.

NOTE: the `ndmap` data contains declination in the second-to-last axis and RA in the last axis, because this corresponds to the varying rows and columns of the array. But in the `wcs`, which is built by `astropy` outside of `pixell`, information is stored in the opposite order: RA first, then declination. Note the size of the pixels in RA is negative: the RA of pixels farther to the right in the array is *less*.

We can also add a wcs to a numpy array. Sometimes this is necessary after performing a numpy operation on a ndmap as it might remove the `wcs`:
<!-- #endregion -->

```python id="qxAtK54Ll672"
stacked_map = np.concatenate([empty_map, empty_map])

print(stacked_map.shape)
print(stacked_map.wcs)
```

<!-- #region id="gz67xNgbl9ef" -->
Let's fix this:
<!-- #endregion -->

```python id="ZxuSKXvu3WxV"
# Let's add a wcs to this data by doing this
omap = enmap.ndmap(stacked_map, wcs)

# Or this
omap = enmap.samewcs(stacked_map, empty_map)

# This does the same thing, but force-copies the data array.
omap = enmap.enmap(stacked_map, wcs)
```

<!-- #region id="NvfzcZqb5XRZ" -->
Note that `ndmap` and `samewcs` will not copy the underlying data array if they don’t have to; the returned object will reference the same memory used by the input array (as though you had done `numpy.asarray`). In contrast, `enmap.enmap` will always create a copy of the input data.
<!-- #endregion -->

<!-- #region id="1h_7mdbC5BvZ" -->
## Reading a map from disk

An entire map in `FITS` or `HDF` format can be loaded using `read_map`, which is found in the module `pixell.enmap`. The `enmap` module contains the majority of map manipulation functions.
<!-- #endregion -->

```python id="NX2A3eIk-y0J"
imap = enmap.read_map('act_planck_dr5.01_s08s18_AA_f150_night_map_d56_I.fits')
```

<!-- #region id="vJp2SxIT59iD" -->
Alternatively, one can select a rectangular region specified through its bounds using the box argument,
<!-- #endregion -->

```python id="VAJKp6aj6AqH"
dec_min = -7 ; ra_min = 5 ; dec_max = 3 ; ra_max = -5

# All coordinates in pixell are specified in radians
box = np.array([[dec_min, ra_min], [dec_max, ra_max]]) * utils.degree

imap_box = enmap.read_map("act_planck_dr5.01_s08s18_AA_f150_night_map_d56_I.fits", box=box)
```

<!-- #region id="POgT0x9Dp6nh" -->
We can perform computations on the array like any other array:
<!-- #endregion -->

```python id="zQ1LqS_W-8Ul"
print(np.mean(imap))
```

<!-- #region id="3XcvCCF6J9dq" -->
## Visualizing maps

We can use the `pixell.enplot` functions to visualize ndmaps. For example, if we want to plot this imap_box we first create the plot and then show it. This can also be done with a saved map on the command line (i.e. `enplot map_name.fits`). There are several plotting options built-in to the `enplot` function. They are listed in the documentation here: https://pixell.readthedocs.io/en/latest/reference.html#module-pixell.enplot
<!-- #endregion -->

```python id="EllLz41SKCoA"
# Code to plot maps
enplot.pshow(imap_box, colorbar=True, downgrade=2)
```

<!-- #region id="8PaE13yJIgDB" -->
### Selecting regions of the sky
<!-- #endregion -->

<!-- #region id="trBrnei7vkVm" -->
We may select a region of this map using array slicing. Note that wcs information is correctly adjusted when the array is sliced; for example the object returned by `imap[:50,:50]` is a view into the `imap` data attached to a new `wcs` object that correctly describes the footprint of the extracted pixels. BUT be cautious when assigning an extracted map to a new variable as operations on that variable will also affect the original map.

<!-- #endregion -->

```python id="ELOz2zvDgwkc"
# view one section of the map. Note that wcs is updated
print(f'Original Shape: {imap.shape}, Original WCS: {imap.wcs}')
imap_extract = imap[50:100,50:100]
print(f'New Shape: {imap_extract.shape}, New WCS: {imap_extract.wcs} \n')

# Visualize the map cut out
plot = enplot.plot(imap_extract)
enplot.show(plot)

# note that opperations on imap_extract also affects imap
print(f'Original Mean: {np.mean(imap)}')
imap_extract *= 1e6
print(f'Mean after modification: {np.mean(imap)}')

# Let's get the imap back to it's original state
imap = enmap.read_map('act_planck_dr5.01_s08s18_AA_f150_night_map_d56_I.fits')
```

<!-- #region id="D_qX8KTsv9T0" -->
Alternatively, We can select a coordinate box to creat a subplot around by defining the bottom left and top right coordinates. This opperation will also output the correct wcs for the submap. For example, if we want to create a 0.5x0.5 deg submap around the coordinates a RA of 5 and a DEC of -1 we would use the code below. Note that changing the submap will not affect the original map.
<!-- #endregion -->

```python id="UmhBZaNcIlWT"
# First we need to define our coordinates and radius in radians (utils.degree converts degrees to radians)
ra = 5. * utils.degree
dec = -1. * utils.degree
radius = 0.5 * utils.degree

# Next we create our submap by defining a box in coordinate space
imap_sub = imap.submap([[dec - radius, ra - radius], [dec + radius, ra + radius]])

# Visualize the map corner
plot = enplot.plot(imap_extract)
enplot.show(plot)

# Note that the shape and wcs are updated
print(imap.shape, imap.wcs)
print(imap_sub.shape, imap_sub.wcs, '\n')

# Opperations on the submap do not affect the mean map
print(np.mean(imap))
imap_sub *= 1e6
print(np.mean(imap))
```

<!-- #region id="6FkNv0VuKQLE" -->
## Downgrading

`enmap.downgrade` downgrades maps by an integer factor by averaging pixels. We can also downgrade by different integer factors in either direction.
<!-- #endregion -->

```python id="Oi6iv-1gItXo"
# Using enmap.downgrade, careful with quadrature
# TODO: What do you mean careful with qudrature?

# Downgrade both directions by a factor of 2
imap_downgrade = imap.downgrade(2)
print(imap_downgrade.shape)

# Downgrade in y by 2 and in x by 3
imap_downgrade = imap.downgrade((2, 3))
print(imap_downgrade.shape)
```

<!-- #region id="IvQMAk-rIo9C" -->
## Relating pixels to the sky

The geometry specified through `shape` and `wcs` contains all the information to get properties of the map related to the sky. `pixell` always specifies the Y coordinate first. So a sky position is often in the form `(dec,ra)` where `dec` could be the declination and `ra` could be the RA in radians in the equatorial coordinate system.

The pixel corresponding to ra=8, dec=2 can be obtained like
<!-- #endregion -->

```python id="92wV1owtKXEJ"
dec = 2
ra = 8
coords = np.deg2rad(np.array((dec,ra)))
ypix, xpix = enmap.sky2pix(imap.shape, imap.wcs, coords)
print(ypix, xpix)
```

<!-- #region id="90yyD1nZktXC" -->
We can also use the map directly to perform this calculation:
<!-- #endregion -->

```python id="lDYISOgskqbA"
ypix, xpix = imap.sky2pix(coords)
print(ypix, xpix)
```

<!-- #region id="LK5QxpA4lFUo" -->
We can pass a large number of coordinates for a vectorized conversion. In this case coords should have the shape (2,Ncoords), where Ncoords is the number of coordinates you want to convert, with the first row containing declination and the second row containing RA. For instance,
<!-- #endregion -->

```python id="U9d_4ifwk3s1"
dec = np.array([-5, 0, 3])
ra = np.array([5, 0, -5])

coords = np.deg2rad(np.array((dec,ra)))
print(coords.shape, '\n')

ypix, xpix = imap.sky2pix(coords)
print(ypix, xpix)
```

<!-- #region id="ifEDGvPIl_GR" -->
Let's find the values of the map at these positions. Most of the work is done, but we must convert each position to an integer value as the returned pixel coordinates are in general fractional.
<!-- #endregion -->

```python id="0WqNmYoBlmDG"
ypix = ypix.astype(int)
xpix = xpix.astype(int)
imap[ypix, xpix]
```

<!-- #region id="ThFxPh8knRa4" -->
Similarly, pixel coordinates can be converted to sky coordinates
<!-- #endregion -->

```python id="sRfCrBaZmU6O"
ypix = 100
xpix = 100
pixes = np.array([ypix, xpix])
dec, ra = np.rad2deg(imap.pix2sky(pixes)) # pix2sky, sky2pix work in radians
print(dec, ra)
```

<!-- #region id="jTBpsryuoBfA" -->
Using the `enmap.posmap` function, you can get a map of shape `(2,Ny,Nx)` containing the coordinate positions in radians of each pixel of the map.
<!-- #endregion -->

```python id="GodVmtwLoE3I"
posmap = imap.posmap()
dec = posmap[0] # dec in radians
ra = posmap[1] # ra in radians
print(dec[0][0], ra[0][0])
```

<!-- #region id="KPcFKt39nwL3" -->
Using the `enmap.pixmap` function, you can get a map of shape `(2,Ny,Nx)` containing the integer pixel coordinates of each pixel of the map.
<!-- #endregion -->

```python id="McXDQIFUnjo_"
pixmap = imap.pixmap()
pixy = pixmap[0]
pixx = pixmap[1]
print(pixy[1][0], pixx[0][1])
```

<!-- #region id="m9nZ3yyCmDn4" -->
## Exercise: stacking on clusters (based on [this notebook](https://github.com/ACTCollaboration/DR4_DR5_Notebooks/blob/master/Notebooks/Section_4_visualize_objects.ipynb); see also [this notebook](https://github.com/ACTCollaboration/DR6_Notebooks/blob/main/ACT_DR6_ymap_stacking.ipynb) later in the course!)

We will apply what we've learned to do a common analysis technique with our ACT data: stacking maps on galaxy clusters. We might want to do this in order to learn about the gas distribution in and around clusters, or to tease out their mass from weak lensing. To do this we will need a catalogue of cluster locations and more ACT data:
<!-- #endregion -->

```python id="1vklQ3KLG5h-"
# this is a full ACT DR5 map, downgraded so that it doesn't take up too much
# memory
!wget -O act_planck_dr5.01_s08s18_AA_f150_night_map_dg_I.fits https://phy-act1.princeton.edu/public/zatkins/act_planck_dr5.01_s08s18_AA_f150_night_map_dg_I.fits

# this is the ACT DR5 tSZ cluster catalogue...how did we make it??
!wget https://astro.ukzn.ac.za/~mjh/ACTDR5/v1.0b3/DR5_cluster-catalog_v1.0b3.fits
```

```python id="djNK_VWUfQaA"
import astropy.table as atpy

# get the map
imap = enmap.read_map('act_planck_dr5.01_s08s18_AA_f150_night_map_dg_I.fits')

# Read in ras and decs from a cluster catalog
tab = atpy.Table().read('DR5_cluster-catalog_v1.0b3.fits', format='fits')

# convert them to radians
ras = tab['RADeg'] * utils.degree
decs = tab['decDeg'] * utils.degree

print(ras.shape, decs.shape)
```

<!-- #region id="UBO_lOV9MZhF" -->
What does the full ACT DR5 + Planck data look like? Here we are only using the temperature data, not polarization:
<!-- #endregion -->

```python id="f4wVEUXBMffv"
enplot.pshow(imap, downgrade=8, colorbar=True, ticks=15, range=300)
```

<!-- #region id="Yx4RrgTDMPU5" -->
Notice the bright band of the milky way galaxy cutting across the edge of the map. It's not on the equator because the ACT data is natively in celestial coordinates (we can play around with this later). The rest of the blobby pattern, with blobs that are about a degree in size, is the CMB!

Let's cut out a pixel of size .5 degrees around a random cluster and take a look:
<!-- #endregion -->

```python id="B3LG8I5fMXfm"
# try this for a bunch of different cluster indexes!
n = 128
radius = 0.5 * utils.degree

imap_sub = imap.submap([[decs[n] - radius, ras[n] - radius], [decs[n] + radius, ras[n] + radius]])

enplot.pshow(imap_sub, upgrade=16, colorbar=True, grid=False)
```

<!-- #region id="rftIfgozQb0a" -->
Not a whole lot there? This is why a stack makes sense: if clusters generally look similar in the map, but their signal is very faint, we can average their locations and try to beat-down the noise. What is the source of "noise" in this case?
<!-- #endregion -->

<!-- #region id="vys_pqMxNd31" -->

<!-- #endregion -->

```python id="LL7jxTqoG_YR"
stack = 0
num = 0
for n in range(len(decs)):
  stack += imap.submap([[decs[n] - radius, ras[n] - radius], [decs[n] + radius, ras[n] + radius]])
  num += 1

  if n % 500 == 0: print(f'We have done {n} clusters')
```

```python id="WFKzvLFpR8kb"
enplot.pshow(stack/num, upgrade=16, colorbar=True, grid=False)
```

<!-- #region id="L0aP2HylR_1J" -->
Nice! Clusters do kind of look the same in the map: they look like a cold spot. Why?

Notice anything else weird about the average cluster, maybe about it's shape? Does this make sense to you? Why or why not?
<!-- #endregion -->


---

# pixell_matched_filtering.md

---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3
    name: python3
---

<!-- #region id="yPF5lzLN9DJB" -->
# Matched Filtering with pixell

*Written by the ACT Collaboration*

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/simonsobs/pixell_tutorials/blob/master/pixell_matched_filtering.ipynb)

---

This notebook, and the accompanying notebooks included in this set, are designed to help users who are new to working with [`pixell`](https://github.com/simonsobs/pixell/) get started with the package. As a set these notebooks will guide users through examples of how to read in and display maps, how to perform spherical harmonic transform and calculate simple spectra, how to transform the maps and how to study point sources in the maps.

The `pixell` library allows users to load,
manipulate and analyze maps stored in rectangular pixelization. It is
mainly targeted for use with maps of the sky (e.g. CMB intensity and polarization maps, stacks of 21 cm intensity maps, binned galaxy positions or shear) in cylindrical projection.

This notebook will explain the basics of matched filtering a map, and how to perform a flux measurement of point sources in that map.

We will make fake random catalogs, so we don't need any extra data.
<!-- #endregion -->

```python id="kDFKT4bz89Ra" colab={"base_uri": "https://localhost:8080/"} outputId="bbf2f184-090e-421e-c1a8-7360a4a21444"
!pip install pixell
```

```python id="s3We41ht94xX"
# Import packages
import numpy as np
from pixell import enmap, utils, uharm, analysis, curvedsky, enplot, reproject
import matplotlib.pyplot as pl
import healpy as hp
```

```python id="EcxQr34cSae-"
def eshow(x,**kwargs):
    ''' Define a function to help us plot the maps neatly '''
    plots = enplot.get_plots(x, **kwargs)
    enplot.show(plots, method = "ipython")
```

<!-- #region id="RFGNWqMC9yb5" -->
**Reading maps from disk**

For more details on how to use maps in `pixell` take a look at the [map manipulation notebook](https://github.com/simonsobs/pixell_tutorials/blob/master/Pixell_map_manipulation.ipynb)!
<!-- #endregion -->

<!-- #region id="_vJ5OYvI9yjp" -->
**Matched filtering** is used to detect point sources in astronomical images by correlating the point source profile with the image. The matched filter output at each pixel gives an estimate of the flux density $F$ and $S/N$ of a point source at that location:

\begin{align}
    F & =\frac{\rho}{\kappa}=\frac{B^{T}U^{-1}\hat{m}}{diag(B^{T}U^{-1}B)}\\
    S/N&=\frac{\rho}{\sqrt{\kappa}}=\frac{B^{T}U^{-1}\hat{m}}{\sqrt{diag(B^{T}U^{-1}B)}}
\end{align}

where $\kappa$ and $\rho$ are respectively the inverse variance and inverse variance weighted flux density. $B$ is the response matrix that takes a single pixel in flux density unit to beam-convolved structures in CMB temperature unit. $U$ is the covariance matrix of noise $u$ in $\hat{m}$, $u$ considered here is everything that is not a point source, including instrumental and atmospheric noise, clusters and CMB signals.

<!-- #endregion -->

<!-- #region id="5Nv6TT7iLRrz" -->
**First example** Our first example will be to create a small sky map, put a point source in the center, add different noise models, and measure the flux.
<!-- #endregion -->

```python id="zQ1LqS_W-8Ul" colab={"base_uri": "https://localhost:8080/", "height": 334} outputId="e130ee92-d53f-45fb-df94-87f384488b3e"
# We set up a map with a given geometry (a 2x2 square degrees stamp with 0.5 arcmin pixels)
shape, wcs = enmap.geometry(np.array([[-1,1],[1,-1]])*utils.degree, res=0.5*utils.arcmin)
pixarea    = enmap.pixsizemap(shape, wcs)

# Our experiment will have a Gaussian beam with FWHM=2.2 arcmin
#Omega_b is the beam solid angle for a Gaussian beam in sr
bsigma     = 2.2*utils.fwhm*utils.arcmin
Omega_b    = (np.pi / 4 / np.log(2)) * (2.2*utils.arcmin)**2

# We will put a source at the center of the map (ra=0 deg, dec=0 deg) with a flux density of 10 mJy
# signal is a map with the profile of the point source in mJy/sr
pos        = [0.0,0.0]
signal     = (10/Omega_b) * np.exp(-0.5*enmap.modrmap(shape, wcs, pos)**2/bsigma**2)

# We define a Unified Harmonic Transform (uht) object, that will take care of the
#map<->harmonic transformations for us under the hood, either using FFT or SHT.
uht        = uharm.UHT(shape, wcs)

# This is the harmonic transform of the beam in 2D (since it is Gaussian we assume symmetry around the axis)
beam       = np.exp(-0.5*uht.l**2*bsigma**2)

# We need a conversion factor between temperature units (K) and spectral radiance (Jy/sr). We assume we are observing at 90 GHz
fconv      = utils.dplanck(90e9, utils.T_cmb)/1e3 # uK -> mJy/sr

# we need to transform our signal map which is in mJy/sr to uK using the conversion factor.
signal /= fconv # this will leave our map in uK units

#Let's see the signal only map
eshow(signal,**{"range":10, "colorbar":True})
```

<!-- #region id="seeg2E3xNzBe" -->
**White noise** Let's simulate white noise of 10 uK*arcmin
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/"} id="G02yaPgDNqBv" outputId="0a4175f4-9a37-43e0-99e6-4056313d12c0"
# This is the inverse variance, which is constant across pixels
ivar       = 10**-2*pixarea/utils.arcmin**2
noise      = enmap.rand_gauss(shape, wcs) * np.sqrt(1/ivar)

# we add the noise to the signal. Remember that signal is already in uK units from above
map        = signal + noise

# The analysis module contains many matched filter calculators
# In this case we use a fuction that receives a map of inverse covariances
rho, kappa = analysis.matched_filter_white(map*fconv, beam, ivar/fconv**2, uht)
flux  = rho/kappa
dflux = kappa**-0.5

print('Our measured flux is %.3f +- %.3f mJy'%(flux.at(pos)[0],dflux.at(pos)[0]))
```

```python id="vH8L7rWXSBvr" colab={"base_uri": "https://localhost:8080/", "height": 631} outputId="3e1fe43e-23b7-42ff-ef32-75c2b874bf4b"
# we plot our flux map, and our signal/noise map
eshow(flux, **{"range":10, "colorbar":True})
eshow(flux/dflux, **{"range":15, "colorbar":True})
```

<!-- #region id="d3oYGVeQYA_E" -->
**Using a noise spectrum instead of a noise map**
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/"} id="LX5dOfg4Sj4T" outputId="e9daf4fa-11be-469e-a2e3-990c2ba3f9e1"
# Now we define a noise spectrum instead of inputting a map. In this case we
# will still simulate white noise, so this iN spectrum is a constant value
iN = 10**-2/utils.arcmin**2

# This matched filter function receives a noise spectra as input
rho, kappa = analysis.matched_filter_constcov(map*fconv, beam, iN/fconv**2, uht)
flux  = rho/kappa # kappa just a number in this case, and hence the errorbar will also be a single number
dflux = kappa**-0.5

print('Our measured flux is %.3f +- %.3f mJy'%(flux.at(pos)[0],dflux))
```

<!-- #region id="SLg1BZ4FZ314" -->
**Using both a noise map and noise spectrum** This method supports a noise model given by $N^{-1} = \sqrt{\rm{(ivar)}} C^{-1} \sqrt{\rm{(ivar)}}$, where $\rm{(ivar)}$ is the inverse variance and $C^{-1}$ is the inverse of the noise spectrum. This represents correlated noise described by iC that's modulated spatially by ivar.
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/"} id="TvFmARLwZdtm" outputId="d6c3d361-d514-4453-b7ac-8151a1dfe9bd"
# The noise units are only in ivar, so the white noise spectrum is just a dimensionless 1
iN = 1

# This matched filter function receives a noise spectra and a noise map as inputs
rho, kappa = analysis.matched_filter_constcorr_lowcorr(map*fconv, beam, ivar/fconv**2, iN, uht)
flux  = rho/kappa
dflux = kappa**-0.5

print('Our measured flux is %.3f +- %.3f mJy'%(flux.at(pos)[0],dflux.at(pos)[0]))
```

<!-- #region id="h7aYtxafc_si" -->
**1/f noise** Let's try a more realistic 1/f noise now
<!-- #endregion -->

```python id="ArmXUetRcyN2"
# base noise depth of 10 uK * arcmin, this is the base of white noise
ivar  = 10**-2*pixarea/utils.arcmin**2
# spatial modulation with 1 arcmin wavelength horizontal sine wave
# this represents different observing depths in different parts of the sky like a real experiment
ivar *= (1+0.9*np.sin(enmap.posmap(shape, wcs)[0]/(1*utils.arcmin)))

# We model the noise power spectrum as a 1/f with l_knee=2000, alpha_knee=-3.
# We only include the 1/f part, the white noise part is done separately
l_arr = np.arange(8000+1)
N    = (10**2 * utils.arcmin**2) * ( ((l_arr+0.5)/2000)**-3 ) # this is for generating the realization
iN   = 1/(1 + ((uht.l+0.5)/2000)**-3) # this is in 2D, to use in the matched filter
# we generate a 1/f with a 10 uK*arcmin base white noise
noise_oof = enmap.rand_map(shape, wcs, N, spin=0)

# we coadd the white noise and the 1/f noise
noise_atm = enmap.rand_gauss(shape, wcs)*np.sqrt(1/ivar) + noise_oof

map = signal + noise_atm
```

```python colab={"base_uri": "https://localhost:8080/", "height": 334} id="PXvVgmIE3jMG" outputId="16b9d8b8-c659-452b-c296-64ca9a475ebc"
# Let's look at how the total map looks like
eshow(map, **{"colorbar":True})
```

```python colab={"base_uri": "https://localhost:8080/", "height": 351} id="Iaf18e7cblMR" outputId="651bf87d-79a0-43c1-e7ae-53b589d8563a"
# We estimate the flux, using the noise theory spectrum and the ivar map
rho, kappa = analysis.matched_filter_constcorr_lowcorr(map*fconv, beam, ivar/fconv**2, iN, uht)
flux  = rho/kappa
dflux = kappa**-0.5
print('Our measured flux is %.3f +- %.3f mJy'%(flux.at(pos)[0],dflux.at(pos)[0]))

eshow(flux, **{"range":10, "colorbar":True})
```

<!-- #region id="BYZ8BNVV4Ut-" -->
**Measure the spectrum empirically** Now instead of a model iN for the noise spectrum, we will measure it directly from the map
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/"} id="e9k9E4-D1vKu" outputId="c06fc9cf-9d7f-4ca3-aaa1-4f116f6b3f4e"
# We measure the spectra from the map. First, we will ignore the point source in the center and include it in the spectra calculation
iNemp  = 1/(np.mean(np.abs(uht.map2harm(map*ivar**0.5))**2,0) / map.pixsize())

rho, kappa = analysis.matched_filter_constcorr_dual(map*fconv, beam, ivar/fconv**2, iNemp, uht)
flux  = rho/kappa
dflux = kappa**-0.5
print('Our measured flux is %.3f +- %.3f mJy'%(flux.at(pos)[0],dflux.at(pos)[0]))
```

```python id="lyIiKnZ3eDEV"
# We can also mask the point source at the center

#helper function to create a circular mask
def cmask(dy, dx, center=None, radius=None):
    if center is None: # use the middle of the image
        center = (int(dx/2), int(dy/2))
    if radius is None: # use the smallest distance between the center and image walls
        radius = min(center[0], center[1], dx-center[0], dy-center[1])
    Y, X = np.ogrid[:dy, :dx]
    radmap = np.sqrt((X - center[0])**2 + (Y-center[1])**2)
    mask = radmap <= radius
    return np.logical_not(mask)
dx,dy = map.shape
```

```python colab={"base_uri": "https://localhost:8080/", "height": 472} id="0Fq7Bq7zFPgN" outputId="a63a7c9a-3b23-4e1e-b668-96bf15841f03"
# We create a mask with a radius of 6 pixels around the center
mask = cmask(dy,dx, radius=6)

# Let's look at the mask
pl.imshow(mask)
```

```python colab={"base_uri": "https://localhost:8080/"} id="-v0mQEJpE7IK" outputId="7e3f4814-7fc3-406e-bc9d-28a911bc113a"
# We measure the spectra from the map like before. This time we multiply by the mask
iNemp  = 1/(np.mean(np.abs(uht.map2harm(map*mask*ivar**0.5))**2,0) / map.pixsize())

rho, kappa = analysis.matched_filter_constcorr_dual(map*fconv, beam, ivar/fconv**2, iNemp, uht)
flux  = rho/kappa
dflux = kappa**-0.5
print('Our measured flux is %.3f +- %.3f mJy'%(flux.at(pos)[0],dflux.at(pos)[0]))
```

<!-- #region id="zaeNUXeceWYH" -->
**Second example** Our second example will be simulating multiple point sources in a big map, and stack them. We will generate random coordinates where we place the sources and assume that we are observing the same source with an "absolute" flux of 3 mJy at different coordinates and at different random distances. The measured fluxes will change depending on the distance to each source. This cell may take ~5 min to compute.
<!-- #endregion -->

```python id="AczSZDQqexID"
Nsources = 100

# We generate a big map. We will make a stripe 60 degrees wide by 20 degrees tall
shape, wcs = enmap.geometry(np.array([[-10,30],[10,-30]])*utils.degree, res=0.5*utils.arcmin)
pixarea    = enmap.pixsizemap(shape, wcs)
signal     = enmap.zeros(shape, wcs=wcs)

# We will store the random coordinates and distances for each source.
ra_sources = np.zeros(Nsources)
dec_sources = np.zeros(Nsources)
dist_sources = np.zeros(Nsources)

for n_source in range(Nsources):
  # this is not the proper way of generating uniformly sampled sources in the surface of the sphere, but for our purposes it is fine
  pos        = np.array([np.random.uniform(-10,10), np.random.uniform(-30,30)]) * utils.degree
  # The source will have a flux of 3 mJy at a distance of 1, and we generate random distances from 0.5 to 20.
  dist       = np.random.uniform(0.5, 20)
  signal     += 3 * (1/dist)**2 * (1/Omega_b) * np.exp(-0.5*enmap.modrmap(shape, wcs, pos)**2/bsigma**2)
  # Save to arrays
  ra_sources[n_source] = pos[1]
  dec_sources[n_source] = pos[0]
  dist_sources[n_source] = dist

# we need to transform our signal map which is in mJy/sr to uK using the conversion factor.
signal /= fconv # this will leave our map in uK units
```

```python id="kkzU7q6VnFrs"
# Let's generate a 1/f noise

# base noise depth of 10 uK * arcmin, this is the base of white noise
ivar  = 10**-2*pixarea/utils.arcmin**2
# spatial modulation with 5 arcmin wavelength horizontal sine wave
# this represents different observing depths in different parts of the sky like a real experiment
ivar *= (1+0.9*np.sin(enmap.posmap(shape, wcs)[1]/(5*utils.arcmin)))

# We model the noise power spectrum as a 1/f with l_knee=2000, alpha_knee=-3.
# We only include the 1/f part, the white noise part is done separately
l_arr = np.arange(8000+1)
N    = (10**2 * utils.arcmin**2) * ( ((l_arr+0.5)/2000)**-3 ) # this is for generating the realization
# we generate a 1/f with a 10 uK*arcmin base white noise
noise_oof = enmap.rand_map(shape, wcs, N, spin=0)

# We multiply by ivar to generate our final noise realization
noise_atm = enmap.rand_gauss(shape, wcs)*np.sqrt(1/ivar) + noise_oof

map = signal + noise_atm
```

```python colab={"base_uri": "https://localhost:8080/", "height": 394} id="SjbRKWS4jV_R" outputId="c5af5cce-d250-4a9e-e440-8ceeb1192eed"
# Let's look at the map
params = {"colorbar":True, "downgrade":8, "mask":0, "ticks":10}
eshow(map, **params)
```

```python id="LNJEqoC5m37v"
# Let's apply a matched filter and look at the flux map
uht        = uharm.UHT(shape, wcs)
beam       = np.exp(-0.5*uht.l**2*bsigma**2)
iN   = 1/(1 + ((uht.l+0.5)/2000)**-3) # this is in 2D, to use in the matched filter

rho, kappa = analysis.matched_filter_constcorr_dual(map*fconv, beam, ivar/fconv**2, iN, uht)
```

```python colab={"base_uri": "https://localhost:8080/", "height": 394} id="yHQsMolxpt6T" outputId="0d787b65-c827-443e-d725-57cd601a2fc4"
# Let's look at the flux map
params = {"colorbar":True, "downgrade":8, "mask":0, "ticks":10}
eshow(rho / kappa, **params)
```

<!-- #region id="Fx4tVzKIb1c_" -->
As you can see, the sin pattern we included to simulate spatial modulation is visible. Also, point sources are not easy to see, however when we stack their positions, they will be obvious to see.
<!-- #endregion -->

<!-- #region id="GE07pOHMq8RN" -->
**Explanation of stacking** We model the flux for source $i$ as $f_i = a R_i + n_i$, where $n_i$ is the noise of the flux, $R_i$ is the weight between transient $i$ and the reference transient, and $a$ is the detection statistic we are optimizing for (i.e. the coadded flux). In our case, we are assuming we are stacking the same type of source (with a fixed luminosity) but flux changing with the square distance law as these objects are found closer or further away. The inverse covariance of $f_i$ is $\kappa_i$. The maximum solution of this equation is given by
\begin{equation}
\hat{a} = \frac{\sum_i R_i \kappa_i f_i}{\sum_i R_i^2 \kappa_i}
\end{equation}
for $a$. This estimator has inverse covariance $A$ given by
\begin{equation}
\hat{A} = \sum_i R_i^2 \kappa_i \text{.}
\end{equation}
In our particular case, the weight $R_i$ is proportional to the inverse distance squared to transient $i$.
<!-- #endregion -->

```python id="j0yR4Ih0q_09"
# We define an empty 2x2 degrees empty stamp, and we will project the cutouts from the big map into this empty stamp.

shape_stack, wcs_stack = enmap.geometry(np.array([[-1,1],[1,-1]])*utils.degree, res=0.5*utils.arcmin)
rho_stack     = enmap.zeros(shape_stack, wcs=wcs_stack)
kappa_stack   = enmap.zeros(shape_stack, wcs=wcs_stack)

for n_source in range(Nsources):
  pos = np.array([dec_sources[n_source],ra_sources[n_source]]) # this coordinates are already in radians

  # we cutout a rho and kappa stamp around the source
  rho_i = reproject.thumbnails(rho, np.reshape(pos,(1,2)), oshape=shape_stack, owcs=wcs_stack, r=1*utils.degree)[0]
  kappa_i = reproject.thumbnails(kappa, np.reshape(pos,(1,2)), oshape=shape_stack, owcs=wcs_stack, r=1*utils.degree)[0]

  # this is the ratio with respect to the reference at distance 1.
  # We will assume our measured distance is the correct distance plus a random 4% error
  R_i = (1 / (dist_sources[n_source]*(1+np.random.normal(scale=0.04))))**2

  rho_stack += R_i * kappa_i * rho_i / kappa_i
  kappa_stack += R_i**2 * kappa_i
a = rho_stack / kappa_stack
da = kappa_stack ** -0.5
```

```python colab={"base_uri": "https://localhost:8080/", "height": 351} id="_ZMiaF0TvDsY" outputId="c086f2a5-6362-4573-f6bb-1a752a440d13"
# We measure the flux from the stacked sources at the center of the map, and we plot the S/N
pos = [0,0]
print('Our measured stacked flux is %.3f +- %.3f mJy, which is a %.1f sigma detection'%(a.at(pos)[0],da.at(pos)[0],a.at(pos)[0]/da.at(pos)[0]))

params = {"colorbar":True, "mask":0, "ticks":0.5}
eshow(a / da, **params)
```

<!-- #region id="MJg5Z31ePD_G" -->
Even though the individual sources are barely visible in the big map, if we have a rough idea of where they are and how much flux we should expect from them (e.g. we know their distance squared), we can stack them and recover their expected flux.
<!-- #endregion -->

```python id="19Fp5CfAPhZn"

```


---

# pixell_reprojection_and_resampling.md

---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3
    name: python3
---

<!-- #region id="yPF5lzLN9DJB" -->
# Reprojecting and Resampling Maps with pixell

*This notebook was written by the ACT Collaboration*

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/simonsobs/pixell_tutorials/blob/master/pixell_reprojection_and_resampling.ipynb)


---
This notebook, and the accompanying notebooks included in this set, are designed to help users who are new to working with [`pixell`](https://github.com/simonsobs/pixell/) get started with the package. As a set these notebooks will guide users through examples of how to read in and display maps, how to perform spherical harmonic transform and calculate simple spectra, how to transform the maps and how to study point sources in the maps.

The `pixell` library allows users to load,
manipulate and analyze maps stored in rectangular pixelization. It is
mainly targeted for use with maps of the sky (e.g. CMB intensity and polarization maps, stacks of 21 cm intensity maps, binned galaxy positions or shear) in cylindrical projection.

In this notebook, we will cover projecting the map to different geometries, cutting out smaller patches of the map (i.e. "postage stamp" generation), as well as reprojecting (converting) the CAR maps to `HEALPix`.
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/"} id="GPzMLmYO98my" outputId="c7ed8459-8473-425d-d6ea-fec0d2fd09c7"
# Download the data needed for the notebook - for now it wget's a DR4 map
!wget -O act_planck_dr5.01_s08s18_AA_f150_night_map_d56_I.fits https://phy-act1.princeton.edu/public/zatkins/act_planck_dr5.01_s08s18_AA_f150_night_map_d56_I.fits


```

```python colab={"base_uri": "https://localhost:8080/"} id="y8V_OhgCkurr" outputId="c0af10f3-db29-46ef-be3d-3df1ef63c7b5"

# Download the Planck 143 GHz map -- it takes a while!
# !wget https://irsa.ipac.caltech.edu/data/Planck/release_2/all-sky-maps/maps/HFI_SkyMap_143_2048_R2.02_full.fits

#smaller Planck map
!wget https://irsa.ipac.caltech.edu/data/Planck/release_2/all-sky-maps/maps/HFI_SkyMap_143_2048_R2.02_nominal.fits
```

```python colab={"base_uri": "https://localhost:8080/"} id="kDFKT4bz89Ra" outputId="b1c71930-dffd-4afc-a475-3980a67d553c"
# Install neccesary packages
!pip install pixell==0.20.4
```

```python id="s3We41ht94xX"
# Import packages
import numpy as np
import healpy as hp
import pixell
from pixell import enmap, enplot, utils, coordinates, reproject, wcsutils
import matplotlib
from matplotlib import cm
```

```python colab={"base_uri": "https://localhost:8080/", "height": 55} id="PhgGtF_YbdOC" outputId="f074dd24-e5ef-4994-e91d-d8b201e88988"
pixell.__version__
```

<!-- #region id="RFGNWqMC9yb5" -->
## **Reading maps from disk**

For more details on how to use maps in `pixell`  take a look at the map manipulation notebook!
<!-- #endregion -->

```python id="NX2A3eIk-y0J"
#read the map
map_act = enmap.read_map("act_planck_dr5.01_s08s18_AA_f150_night_map_d56_I.fits")
```

```python colab={"base_uri": "https://localhost:8080/"} id="y-kIjpJelJRQ" outputId="53e7638d-8178-446f-82a0-fef6bf67e403"
# print map's shape and wcs (world coordinate system)
print(map_act.shape, map_act.wcs)
```

```python colab={"base_uri": "https://localhost:8080/", "height": 309} id="yJMlBgCJlMCF" outputId="0b0c54ea-9ff4-45c5-9e82-aa9d1e109cc4"
# show the map
enplot.pshow(map_act, downgrade=4, colorbar=True) #downgrade the map, so it takes less time to plot, and include the colorbar
```

<!-- #region id="_vJ5OYvI9yjp" -->
## **Projecting to different sky geometries**
<!-- #endregion -->

<!-- #region id="0MCIRMuGk_3v" -->
Let's start with projecting the ACT map patch onto a new map.

First, we create an empty map that covers a different sky area than the original map (see the map manipulation notebook on how to create a map with an arbitrary shape and wcs).
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/"} id="BqU3Scs21vFD" outputId="8cae092a-f6cc-4b8c-b7f4-0420b7feeab6"
# Define area of the new map (wider than the original map)
box = np.array([[-10,46],[7,-13]]) * utils.degree

# Define map geometry
shape_new, wcs_new = enmap.geometry(pos=box,res=0.5 * utils.arcmin,proj='car')
print(shape_new)

# Create an empty ndmap
empty_map = enmap.empty((3,) + shape_new, wcs=wcs_new)

# Show the empty map
#eshow(empty_map[0], **{"downgrade": 4, "colorbar":True}) #downgrade the map, so it takes less time to plot, and include the colorbar
```

```python colab={"base_uri": "https://localhost:8080/"} id="WvCZ5ymu8brx" outputId="1a1bd367-5a4c-4132-9a0c-3b9d9a7d2422"
# Project the original map onto the new map
map_project = enmap.project(map_act, empty_map.shape, wcs=wcs_new)
map_project.shape
```

<!-- #region id="kkiog7dAHq4Z" -->
Show the ACT map projected onto a new (wider) patch
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 374} id="EglIUrpr-yhW" outputId="f3a2f0b5-d318-4be8-c8da-c061dc6e9493"
enplot.pshow(map_project, downgrade=4, colorbar=True) #downgrade the map, so it takes less time to plot, and include the colorbar
```

<!-- #region id="NAatZi0znRCy" -->
Now let's try to extract a smaller patch of the original map, given some shape.
<!-- #endregion -->

```python id="hyKRidiEnTSh"
# Define the shape to extract (# 1/4 of the original map, bottom left corner of the original map)
shape_extract = (map_act.shape[0]/2, map_act.shape[1]/2)

# Extract the patch from the original map
map_extract = enmap.extract(map_act, shape = shape_extract, wcs = map_act.wcs) #keep the same wcs
```

```python colab={"base_uri": "https://localhost:8080/", "height": 271} id="d0JWS1QrnVBW" outputId="edca3511-f436-4a25-ee61-3cae63d93a07"
# Compare the extracted and original map
enplot.pshow(map_extract, downgrade=4, colorbar=True, ticks=5)
```

<!-- #region id="FIgq7BMw9ysb" -->
## **Getting small cutouts of the map**
<!-- #endregion -->

<!-- #region id="BkxhiapnlxmC" -->
Similarly, we can get smaller cutout of the map centered at a given location (which is useful for stacking analyses) with `pixell`'s `reproject.thumbnails` function.

The default projection is `tan` (`proj=tan`), where the thumbnail image is projected onto a local tangent plane, removing the effect of size and shape distortions in the input map.
<!-- #endregion -->

```python id="e1RRZHjoOH5P"
# Define the central coordinates and radius of the patch
r = 30*utils.arcmin # radius, in arcminutes
coords = np.deg2rad([ -5., 0.]) # central coordinates, [dec, ra], in radians

# Thumbstack
cutout = reproject.thumbnails(map_act, coords = coords, r=r)
```

```python colab={"base_uri": "https://localhost:8080/", "height": 335} id="ZTOeWg0Yl1wM" outputId="704bf776-924c-43ec-a883-bc4b5ceda879"
enplot.pshow(cutout, colorbar=True, ticks=40})
```

<!-- #region id="WfrhlLOTOLI4" -->
## **Projecting to and from `HEALPix`**



<!-- #endregion -->

<!-- #region id="lWAMTZ2kl5DH" -->
`pixell` allows to reproject (convert) maps from CAR pixelization to `HEALPix`, and back. This can be done using the [reproject](https://github.com/simonsobs/pixell/blob/master/pixell/reproject.py#L115) library.


Let's start by converting the ACT CAR map to `HEALPix` with `reproject.map2healpix`, optionally including a rotation from Celestial/Equatorial (native ACT) to Galactic (native Planck) coordinates.
<!-- #endregion -->

```python id="wbcqKbNGl74Y" colab={"base_uri": "https://localhost:8080/", "height": 588} outputId="f48f258f-1689-4799-9443-bebf0fb32b66"
#reproject the ACT map to Healpix map of a given nside
NSIDE = 2048 # the nside of the healpix map
ELLMAX = 4000 #the reprojection operation will be done up to the chosen ellmax

map_hp = reproject.map2healpix(map_act, nside=NSIDE, lmax=ELLMAX)
#map_hp = reproject.map2healpix(map_act, nside=NSIDE, lmax=ELLMAX, rot="cel,gal") #optionally include rotation

#Normalize plots to this value
rang = 300
hp.mollview(map_hp, title= "Mollview ACT D56 in Healpix", min = -rang, max = rang, cmap = cm.get_cmap('RdYlBu'))
```

<!-- #region id="u87jICizl9yf" -->
Let's look at this `HEALPix` map cutout in Cartesian view
<!-- #endregion -->

```python id="lTY-Reb8l_pQ" colab={"base_uri": "https://localhost:8080/", "height": 384} outputId="779ce675-da5c-48dd-c779-b526d0e47a2e"
# Define latitude and longitude range corresponding to the ACT region to pass to hp.cartview
lonra = np.sort(map_act.box()[:, 1])/utils.degree
latra = np.sort(map_act.box()[:, 0])/utils.degree
print("Longitude range =", np.round(lonra,2) )
print("Latitude range =", np.round(latra,2) )

hp.cartview(map_hp, lonra = lonra, latra = latra, min = -rang, max = rang, title = "Cartesian view ACT D56 in Healpix",
            cmap = cm.get_cmap('RdYlBu'))
```

<!-- #region id="NAbf9ypzmB9r" -->
Now let's convert a `HEALPix` *Planck* map to CAR. We start by reading in the Planck map using `hp.read_map` and plotting it `hp.mollview`.
<!-- #endregion -->

```python id="TXMOl6sKmDwj" colab={"base_uri": "https://localhost:8080/", "height": 555} outputId="8140da49-cf37-45ab-de6f-081ce78d507d"
# Read in and plot Planck 143 GHz map
# note that generally Planck maps are in K, while ACT maps in uK

map_planck = hp.read_map("HFI_SkyMap_143_2048_R2.02_nominal.fits")

hp.mollview(map_planck, title = "Planck 143 GHz map", unit = "K", norm="hist")
```

```python id="RbXtHJd4guaH" colab={"base_uri": "https://localhost:8080/"} outputId="02400344-e300-4265-8df9-6cbbe3b33e2f"
# Plot using healpy
lonra = np.sort(map_act.box()[:, 1])/utils.degree
latra = np.sort(map_act.box()[:, 0])/utils.degree
rang = 300
print(lonra, latra)
```

```python id="lIQROuhshjbs" colab={"base_uri": "https://localhost:8080/", "height": 373} outputId="fc895282-6995-487d-9c16-222b0d153b2b"
hp.cartview(map_planck, lonra = lonra, latra = latra, coord=["G","C"], flip="astro",
            cmap = cm.get_cmap('RdYlBu_r'))
```

<!-- #region id="YMKQZZyqo6eW" -->
Now let's reproject the map into CAR using `reproject.healpix2map`. You can specify the shape, wcs, lmax as well as whether you want to include rotation (here we rotate from Galactic coordinates to Celestial with `rot="gal,cel"`). The `method` option controls how to interpolate between the input and output pixelization; the default option is `harm`, which uses spherical harmonics to do the interpolation.
<!-- #endregion -->

```python id="Crdw_6d0AtIu"
# Reproject Planck map to CAR, given shape and wcs (include rotation rot="gal,equ" )
map_planck_car_harm = reproject.healpix2map(map_planck, shape = map_act.shape, wcs = map_act.wcs, lmax=ELLMAX, method="harm", rot="gal,cel")

```

```python id="12-KpeQNKnqP" colab={"base_uri": "https://localhost:8080/", "height": 312} outputId="b256b53d-569d-4e34-b812-fd0ff2198985"
enplot.pshow(map_planck_car_harm, **{"downgrade": 4, "colorbar":True, "ticks": 10} )
```

<!-- #region id="ZN5KQ6c6TW8R" -->
Seems like the interpolation didn't work very well, likely due to bright sources in the map. Let's use the `spline` method instead. `spline` is also recommended for masks. Beware that `spline` might not necessarily preserve power.
<!-- #endregion -->

```python id="NyZSqoG7mFqs"
# Reproject Planck map to CAR, given shape and wcs (include rotation rot="gal,equ" )
map_planck_car = reproject.healpix2map(map_planck, shape = map_act.shape, wcs = map_act.wcs, lmax=ELLMAX, method="spline", rot="gal,cel")

```

```python id="Kr0EkEU4U3Te" colab={"base_uri": "https://localhost:8080/", "height": 312} outputId="d56a9c39-f68b-423f-c56f-0e0cf28fbb0f"
eshow(map_planck_car, downgrade=4, colorbar=True, ticks=10)
```

<!-- #region id="Hb1vNV9NmWLM" -->
Compare with the reprojected *Planck* 143 GHz map with the ACT map!
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 312} id="5eYhSidwmWvZ" outputId="123de782-e454-4818-c619-055c932f122c"
enplot.pshow(map_act, downgrade=4, colorbar=True, ticks=10)
```

<!-- #region id="A1KAMt5SvnEL" -->
In general, one has to be very careful with interpolation and reprojection for these reasons: spherical harmonics can bandlimit sharp features in the map and introduce ringing, while spline interpolation can distort map statistics. These drawbacks are unavoidable and a user will need to tailor approaches to their particular situation, or come up with workarounds (like masking bright point sources, for example).
<!-- #endregion -->


---

# pixell_simulations.md

---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3
    name: python3
---

<!-- #region id="yPF5lzLN9DJB" -->
# Simulations with pixell

*Written by the ACT Collaboration*

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/simonsobs/pixell_tutorials/blob/master/pixell_simulations.ipynb)

---


This notebook, and the accompanying notebooks included in this set, are designed to help users who are new to working with [`pixell`](https://github.com/simonsobs/pixell/) get started with the package. As a set these notebooks will guide users through examples of how to read in and display maps, how to perform spherical harmonic transform and calculate simple spectra, how to transform the maps and how to study point sources in the maps.

The `pixell` library allows users to load,
manipulate and analyze maps stored in rectangular pixelization. It is
mainly targeted for use with maps of the sky (e.g. CMB intensity and polarization maps, stacks of 21 cm intensity maps, binned galaxy positions or shear) in cylindrical projection.

In this notebook we will use pixell functions to simulate millimeter-wave sky maps, including different components such as CMB, CMB lensing, Extragalactic Point Sources and Galaxy Clusters, and simplistic noise.

- [x] `enmap.randmap` (flat-sky Gaussian simulations, CMB and noise)

- [x] `curvedsky.randmap` (curved-sky Gaussian simulations, CMB and noise)

- [x] `lensing.lens_map` (flat-sky lensing operation)

- [x] `lensing.lens_map_curved` (curved-sky lensing operation)

- [x] `pointsrcs.sim_objects` (injecting point sources)



<!-- #endregion -->

```python id="kDFKT4bz89Ra"
# Install neccesary packages
!pip install pixell camb
```

```python id="s3We41ht94xX"
# Import packages
import numpy as np
import matplotlib.pyplot as plt
from pixell import powspec
from pixell import utils
from pixell import enmap
from pixell import curvedsky
from pixell import lensing
from pixell import pointsrcs
from pixell import enplot
```

<!-- #region id="RFGNWqMC9yb5" -->
**Making a map from scratch**

For details on how to manipulate maps in pixell take a look at ["Pixell_map_manipulation.ipynb"](https://github.com/simonsobs/pixell_tutorials/blob/master/Pixell_map_manipulation.ipynb). First lets make a zeros map on a certain patch of the sky, let's use the region covering right ascension from 15 to 35 degrees and declination from -10 to -2 (you can try any patch). Here we need to define the vertices of a rectangle from left bottom to top right, these are RA0,DEC0 = 35,-10 and RA1,DEC1 = 15,-2 (think about the sky as going from right ascension 180 to -180 and declinations -90 to +90. We will use 0.5 arcminutes pixels in plate carrée projection, this means all pixels cover 0.5 arcminutes in latitude and longitude
<!-- #endregion -->

```python id="NX2A3eIk-y0J"
              # DEC0, RA0  DEC1 RA1
box = np.array([[-10, 35], [-2, 15]]) * utils.degree
shape, wcs = enmap.geometry(pos=box, res=0.5*utils.arcmin, proj='car')
# we will use only the temperature component or parameter stokes I
omap = enmap.zeros(shape, wcs)
```

```python id="-d8ndl4btd96"
# we can use enplot and see what we have
enplot.pshow(omap, range=500, colorbar=True, downgrade=2)
```

<!-- #region id="G9UeyFDdtipD" -->
looks like an empty map in the region that we wanted. We can also check the pixel size, since all pixels cover 0.5 in width and height we should have 8x60/0.5 = 960 pixels in height and 20x60/0.5 = 2400 in width

<!-- #endregion -->

```python id="DTXdCdZ2tnLZ"
omap.shape
```

<!-- #region id="6PyaTjLxPhOZ" -->
This means that dimension = (number of stokes parameters, declination pixels, right ascension pixels)
<!-- #endregion -->

<!-- #region id="_vJ5OYvI9yjp" -->
**Gaussian realization of CMB**

There are two ways of simulating things, using flat sky approximation or curved sky. Let's start with flat sky, there is a handy function from `enmap` called `rand_map`, which draws a random realization from a power spectrum. To call this function we need to pass the following arguments:

`shape`: shape of the map that we want to simulate, in our case omap.shape

`wcs`: world coordinates of the map, in our case omap.wcs

`cov`: power spectrum that we want to include, more on this later

`scalar = False`: If we have polarization components, treat them as polarization

`seed = None`: The random seed that we want to use, if None if will generate one

`pixel_units = False`: The input power spectrum uses steradians

`iau = False`: The default polarization convention in the CMB community (sad)

`spin = [0,2]`: Apply a EB -> QU rotation

The three first argument are mandatory, but you may need to modify the others depending on your application (see the `pixell` documentation).
<!-- #endregion -->

<!-- #region id="7JsQibuUPyii" -->
We need a power spectrum, specifically we want to simulate the CMB, for that we will use the Planck TT PS (you can try any other cosmology).

First we download the file in the format L TT EE BB TE

<!-- #endregion -->

```python id="hZB9rpVyRDT8"
!wget -O planck_lensedCls.dat https://raw.githubusercontent.com/simonsobs/nemo/main/nemo/data/planck_lensedCls.dat
```

<!-- #region id="UvkiTJlPRHGb" -->
We can plot the file to be sure if it contains the typical CMB power spectrum in the following way

<!-- #endregion -->

```python id="LmpnSCHxRTK6"
fileps = "planck_lensedCls.dat"
L, TT, EE, BB, TE = np.loadtxt(fileps, usecols=(0, 1, 2, 3, 4), unpack=True)
plt.loglog(L, TT)
# plt.yscale("log")
plt.xlabel(r"$\ell$")
plt.ylabel(r"$\ell (\ell+1) C_{\ell}^{TT}/(2 \pi)$")
```

```python id="6aGoL8QvGIfU"
TT.shape
```

<!-- #region id="UsSrZQqRtzhu" -->
We can then pass this Planck TT power spectrum to the pixell function `powspec.read_spectrum`, so that the array is reshaped in the form that Pixell expects, and the 2$\pi/(\ell (\ell+1))$ factors are applied.
<!-- #endregion -->

```python id="UEIWlvj4Tvxh"
ps = powspec.read_spectrum(fileps, scale=True, expand=None)
```

```python id="hswCbdCvFeJP"
ell = np.arange(len(ps[0]))
plt.semilogx(L, TE)
plt.semilogx(ell, ps[3] * (ell*(ell+1)) / (2*np.pi))
```

<!-- #region id="XtGDnuEpvsZg" -->
The pixell function `enmap.rand_map` will then take in the shape and wcs that we defined above, as well as the power spectrum from the cell above to make the corresponding map.
<!-- #endregion -->

```python id="-dIh1pIIRvoZ"
# T only
cmbmap = enmap.rand_map(omap.shape, omap.wcs, cov=ps[0])
enplot.pshow(cmbmap, range=500, colorbar=True, downgrade=2)
```

<!-- #region id="A7xJ4kx9UN2g" -->
If you run the previous code multiple times, you will see a different version each time, that's because each random realization is different but it is sampled from the same probability distribution (given by the power spectrum).

We can also make this polarized. We also need a 3-dimensional map to hold the simulation. We also need to change the `cov` parameter so that it includes all polarization components. We have a TT, EE, BB, and TE spectrum. We need to put this into a `(3, 3, nl)` array, rather than just an `(nl,)` array:
<!-- #endregion -->

```python id="4nWl2s4hj7L0"
nl = ps.shape[-1]
l = np.arange(nl)

ps_square = np.zeros((3, 3, nl))
print(ps_square.shape)

ps_square[0, 0] = ps[0]
ps_square[0, 1] = ps[3]
ps_square[1, 0] = ps[3]
ps_square[1, 1] = ps[1]
ps_square[2, 2] = ps[2]

plt.semilogy(l, l*(l+1)/2/np.pi*ps_square[0, 0], label='00')
plt.semilogy(l, l*(l+1)/2/np.pi*ps_square[1, 1], label='11')
plt.semilogy(l, l*(l+1)/2/np.pi*ps_square[2, 2], label='22')
plt.ylim(1e-3, 1e4)
plt.legend()
plt.show()

plt.plot(l, l*(l+1)/2/np.pi*ps_square[0, 1], label='01')
plt.legend()
```

<!-- #region id="nM_pj4yLmgFH" -->
Then we provide this square array as the `cov` parameter instead:
<!-- #endregion -->

```python id="XinX36L4miXy"
# T, Q, U
cmbmap_pol = enmap.rand_map((3, *shape), wcs, cov=ps_square)
for i in range(3):
  enplot.pshow(cmbmap_pol[i], range=[500, 25, 25][i], colorbar=True, downgrade=2)
```

<!-- #region id="46fOKO6QUQh2" -->
Now this is using flat sky approximation, so it uses the Fourier transform of the patch. If we want to account for the curvature of the sky, which is important for big patches we need to use the `curvedsky` module, in that module we can also find a `rand_map` function.
<!-- #endregion -->

```python id="klCE_gs5USqX"
# full sky goes from ra,dec +180, -90 to ra, dec -180, +90
# we can use bigger pixels such as 4 arcmin to avoid using too much memory
                #DEC0, RA0  DEC1 RA1
shape, wcs = enmap.fullsky_geometry(res=4*utils.arcmin, proj='car', variant='CC')
# we will use only the temperature component or parameter stokes I
omap = enmap.zeros((1, *shape), wcs)
# checking the map with a plot
enplot.pshow(omap, range=500, downgrade=4, ticks=15, colorbar=True)
```

<!-- #region id="F3tSf_0rv5l_" -->
This `curvedsky.rand_map` takes slightly different parameters than `enmap.rand_map`, in order they are

`shape`: shape of the map that we want to simulate, in our case omap.shape

`wcs`: world coordinates of the map, in our case omap.wcs

`ps`: power spectrum that we want to include. Can take an `(nl,)` shaped ps or a `(ncomp, ncomp, nl)` ps.

`lmax=None`: maximum multipole range to sample

`dtype=np.float32`: type of the resulting array

`seed=None`: number of the seed, if None it will generate one

`spin=[0,2]`: type of spin, in we have a IQU map it is [0,2], if we give as an input a single power spectrum it will take that into consideration to generate only one map

`method="auto"`: the default "auto" is fine

`verbose=False`: gives text information about the process

Note: it is typically sufficient to use single-precision maps (`dtype=np.float32`) which would speed up computation and use less memory. The default for this function is double precision (`dtype=np.float64`).
<!-- #endregion -->

```python id="0Bc0gGwaUjVv"
# now simulating the CMB taking into account the curvature of the sky
# this may take some time since it uses spherical harmonics

# T only
cmbmap = curvedsky.rand_map(omap.shape, omap.wcs, ps=ps[0], lmax=3000, dtype=np.float32, verbose=True)
enplot.pshow(cmbmap, range=500, downgrade=4, ticks=15, colorbar=True)
```

<!-- #region id="jQpjNRplUZT6" -->
Ok, it looks interesting. Notice the distortion at the poles; is this what you expected? To put it in context, consider this image of the earth in the same CAR projection:
<!-- #endregion -->

<!-- #region id="HXP3TMUKcyjz" -->
![](https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Equirectangular_projection_SW.jpg/1920px-Equirectangular_projection_SW.jpg)
<!-- #endregion -->

<!-- #region id="0NQ3gf4GyFR0" -->
This makes sense now. Each pixel in the top row of pixels (and bottom row) are in fact the same physical point -- the pole! Using `enmap.rand_map` in this case might make a more uniform looking picture but it would be physically wrong -- we can't use the flat sky approximation when our range of declinations is large!
<!-- #endregion -->

```python id="tshbkq-GUVNY"
# now simulating the CMB in this patch in the flat sky approximation
# NOTE: THIS IS WRONG
cmbmap = enmap.rand_map(omap.shape, omap.wcs, cov=ps[0])
enplot.pshow(cmbmap, range=500, colorbar=True, downgrade=4, ticks=15)
```

<!-- #region id="7f70XuQq1jmN" -->
There are no distortions at the poles -- this is *wrong*. We need the distortions!

Just like the flatsky case, we can draw a polarized simulation. We again need a map to hold the 3 polarization components, and need to give it a power spectrum that puts the components in a square:
<!-- #endregion -->

```python id="c3TSGZwepku0"
# T, Q, U
cmbmap_pol = curvedsky.rand_map((3, *shape), wcs, ps=ps_square, lmax=3000, dtype=np.float32, verbose=True)
for i in range(3):
  enplot.pshow(cmbmap_pol[i], range=[500, 25, 25][i], downgrade=4, ticks=15, colorbar=True)
```

<!-- #region id="FIgq7BMw9ysb" -->
**Lensing**
<!-- #endregion -->

<!-- #region id="y2TT6w_8xldi" -->
To make flat-sky lensing simulations, we need unlensed CMB power spectra, as well as a lensing potential power spectrum. We obtain these from CAMB by running the following cells:
<!-- #endregion -->

```python id="12A-gpoJ4QyW"
import camb

pars = camb.set_params(H0=67.5, ombh2=0.022, omch2=0.122, mnu=0.06, omk=0, tau=0.06,
                       As=2e-9, ns=0.965, halofit_version='mead', lmax=4000)
pars.set_for_lmax(4000, lens_potential_accuracy=4)

# calculate results for these parameters
results = camb.get_results(pars)
powers = results.get_cmb_power_spectra(pars, CMB_unit='muK', raw_cl=True)
TT, EE, BB, TE = powers["unlensed_scalar"].T
ell = np.arange(len(TT))

# for simplicity assume lensing is uncorrelated with the CMB power spectra, but
# we could include correlations too as CAMB calculates them
PP = powers["lens_potential"][:, 0]
```

<!-- #region id="ey-PxhdX1sGT" -->
Before we create the lensed simulations, we need to package the CMB and lensing potential power spectra in a format that pixell will understand:
<!-- #endregion -->

```python id="x1VNVLpyObKx"
ps_init = np.vstack((ell, TT, EE, TE, PP))
ps_init = np.atleast_2d(ps_init)
ps_init = powspec.expand_inds(np.array(ps_init[0],dtype=int), ps_init[1:])
ps_cmb = ps_init[:3]
ps_cmb = powspec.sym_expand(ps_cmb, scheme="diag", ncomp=3)
ps_lens = ps_init[3]
```

<!-- #region id="2ueUvhz_19A2" -->
We are then ready to use the pixell function `enmap.rand_map` to make a $\phi$ map from the lensing potential power spectrum, as well as unlensed CMB maps from the CMB power spectra.

Let's be careful to go back to the small patch of sky for which we used `enmap.rand_map` in the beginning of this notebook, where the flat-sky limit is approximately valid:
<!-- #endregion -->

```python id="UFF6_hOB17n4"
              # DEC0, RA0  DEC1 RA1
box = np.array([[-10, 35], [-2, 15]]) * utils.degree
shape, wcs = enmap.geometry(pos=box, res=0.5*utils.arcmin, proj='car')

phi_map = enmap.rand_map(shape, wcs, cov=ps_lens)
cmbmap = enmap.rand_map((3, *shape), wcs, cov=ps_cmb)
```

<!-- #region id="PTeynEA72dDM" -->
The pixell function `lensing.lens_map` will take in the CMB map we created above, as well as the gradient of the $\phi$ map and make a lensed version of the CMB maps. It has the following arguments:

`imap`: the unlensed map with shape `(..., ny, nx)` to be lensed

`grad_phi`: the map of the gradient of the lensing potential with shape `(2, ny, nx)`, obtained from `enmap.grad_phi`

`order=3`: related to the pixel-space interpolation (fine to keep)

`mode="spline"`: same as above

`border="cyclic"`: same as above

`trans=False`: if True, perform adjoint of lensing (not delensing)

`deriv=False`: whether to return derivatives of the interpolation

`h=1e-7`: finite difference size for the derivative

For standard lensing, we can accept all the defaults and just pass our unlensed map and lensing realization:
<!-- #endregion -->

```python id="2-XwNNvI2at7"
grad_phi = enmap.grad(phi_map)
lensedcmb = lensing.lens_map(cmbmap, grad_phi, order=3, mode="spline", border="cyclic", trans=False, deriv=False, h=1e-7)
```

<!-- #region id="blYntsOt2v46" -->
Let's take a look at the lensed CMB maps we just created, followed by the corresponding unlensed CMB map:
<!-- #endregion -->

```python id="3wEccFDQxOit"
enplot.pshow(lensedcmb[0], colorbar=True, downgrade=2, range=300)
enplot.pshow(cmbmap[0], colorbar=True, downgrade=2)
```

<!-- #region id="zyTrdUeOe_rv" -->
The effect of lensing is made more obvious by looking at the difference between the output and input (unlensed) CMB maps:
<!-- #endregion -->

```python id="tEojjqfve-JE"
enplot.pshow(lensedcmb[0] - cmbmap[0], colorbar=True, downgrade=2, range=50)
```

<!-- #region id="jJ1yHWKa21Iy" -->
We can then compare the power spectra of these lensed maps to the lensed power spectra from CAMB. To calculate the power spectra of the lensed maps we created, we will first apodize the maps, and use the pixell functions `enmap.map2harm` and enmap.lbin to calculate the power spectra. If you need a refresher of this procedure, please refer to the notebook ["Fourier Operations with pixell"](https://github.com/simonsobs/pixell_tutorials/blob/master/Pixell_fourier_space_operations.ipynb).
<!-- #endregion -->

<!-- #region id="VBX8FYSb4H7E" -->
Apodization is done as follows:
<!-- #endregion -->

```python id="kLXytVYRo46N"
apod_pix = 200 # number of pixels at the edge to apodize
taper = enmap.apod(cmbmap*0.0 + 1.0, apod_pix)
```

```python id="J5X1wU3mo9OZ"
for i in range(3):
  enplot.pshow((taper * lensedcmb)[i], downgrade=2, colorbar=True)
```

<!-- #region id="xRHS9Zq64Lb2" -->
We can then compute the 2D FFT with `enmap.map2harm` and use `enmap.lbin` to bin the power spectra into 1D.
<!-- #endregion -->

```python id="Ek0NoO8tNhj_"
harm_lensed = enmap.map2harm(taper * lensedcmb, normalize="phys")
w2 = np.mean(taper**2)
power = (harm_lensed[:, None] * np.conj(harm_lensed)).real/w2
cl, ls1 = power.lbin(bsize=40)
```

<!-- #region id="P4oKvpPf4z0R" -->
Here, we also load the CAMB lensed power spectra to compare to the lensed power spectra from the simulation we created in this notebook.
<!-- #endregion -->

```python id="u9SE_LlSk_qR"
powers_lensed_camb =  powers["lensed_scalar"].T
```

```python id="hxHxVjwfdcJm"
dll_fac = (ls1*(ls1+1))/(2*np.pi)
camb_dll_fac = (ell*(ell+1))/(2*np.pi)

fig, ax = plt.subplots(2, 2)

ax[0,0].plot(ls1,cl[0, 0]*dll_fac,label="This notebook")
ax[0,0].plot(powers_lensed_camb[0]*camb_dll_fac,label="CAMB lensed")
ax[0,0].set_xlim(20, 4000)

ax[0,1].plot(ls1,cl[1, 1]*dll_fac,label="This notebook")
ax[0,1].plot(powers_lensed_camb[1]*camb_dll_fac,label="CAMB lensed")
ax[0,1].set_xlim(20, 4000)

ax[1,0].plot(ls1,cl[2, 2]*dll_fac,label="This notebook")
ax[1,0].plot(powers_lensed_camb[2]*camb_dll_fac,label="CAMB lensed")
ax[1,0].set_xlim(20, 4000)

ax[1,1].plot(ls1,cl[0, 1]*dll_fac,label="This notebook")
ax[1,1].plot(powers_lensed_camb[3]*camb_dll_fac,label="CAMB lensed")
ax[1,1].set_xlim(20, 4000)

ax[0,0].set_xlabel("$\ell$")
ax[0,0].set_ylabel("TT")
ax[0,1].set_xlabel("$\ell$")
ax[0,1].set_ylabel("EE")
ax[1,0].set_xlabel("$\ell$")
ax[1,0].set_ylabel("BB")
ax[1,1].set_xlabel("$\ell$")
ax[1,1].set_ylabel("TE")

plt.tight_layout()
plt.legend()
plt.show()
```

<!-- #region id="HUYzOURssu-1" -->
Nice! There are clearly some lensing-induced B-modes, but they don't have quite the right shape. This is likely due to the fact that we've done everything on the flat sky and/or haven't properly accounted for the mode-coupling due to the sky mask.

Fortunately, just as for the Gaussian realization from the CMB, `pixell` also supports full-sky lensing operations that accounts for spherical geometry. Because we can work on the full-sky, we won't need to apodize the map; however, this will not apply to a realistic simulation for ACT or SO data, which only observes a fraction of the sky.

As for the Gaussian realization, the curved-sky lensing operation `lensing.lens_map_curved` has new arguments:

`shape`: with `wcs`, the geometry of the output map

`wcs`: with shape, the geometry of the output map

`phi_alm`: the spherical harmonic realization of the lensing potential realization

`cmb_alm`: the spherical harmonics of the unlensed CMB realization

`phi_ainfo=None`: describes the spherical harmonic ordering convention for `phi` (you will know if you need to adjust this)

`maplmax=None`: deprecated

`dtype=np.float64`: output precision, needs to be double for accurate calculations (may crash otherwise)

`spin=[0,2]`: like in `curvedsky.rand_map`

`output="l"`: returns only the lensed CMB map. `lu` returns the lensed and unlensed CMB. More options for lensing maps in the [function documentation](https://github.com/simonsobs/pixell/blob/a61ca1a3ae99e4c8627c86a0fe2401d4bfe67d66/pixell/lensing.py#L134)

`geodesic=True`: slower but accurate, `False` for faster but less accurate

`verbose=False`: print helpful messages

`delta_theta=None`: can leave this as-is

In the below, besides supplying the required arguments, the only other important argument we change is to also return the unlensed CMB so we can compare:
<!-- #endregion -->

```python id="PpV-vQ77wt6T"
# first get a full-sky realization of the phi map and the polarized, unlensed cmb
# use low-resolution to reduce memory and runtime
shape, wcs = enmap.fullsky_geometry(res=4*utils.arcmin, proj='car')

# pixell needs the maps in spherical harmonics
phi_alm = curvedsky.rand_alm(ps=ps_lens, lmax=2700)
cmb_alm = curvedsky.rand_alm(ps=ps_cmb, lmax=2700)

# get the lensed cmb map
lensedcmb, cmbmap = lensing.lens_map_curved((3, *shape), wcs, phi_alm, cmb_alm, output="lu", verbose=True)
```

<!-- #region id="MbTUbm2M023R" -->
As before, let's take a look at the lensed CMB map, the unlensed CMB map, and their difference:
<!-- #endregion -->

```python id="G-gBkklV09An"
enplot.pshow(lensedcmb[0], colorbar=True, downgrade=4, ticks=15)
enplot.pshow(cmbmap[0], colorbar=True, downgrade=4, ticks=15)
enplot.pshow(lensedcmb[0] - cmbmap[0], colorbar=True, downgrade=4, ticks=15)
```

<!-- #region id="Qt44MhuCL2WK" -->
Now we can take the full-sky power spectrum without a mask to see if the lensing produced the correct lensed CMB power spectrum. A nice benefit of this test compared to the flat-sky test is that we have more sky area and so the measured power spectrum is also less noisy:
<!-- #endregion -->

```python id="36bGziOGL1rR"
lensed_alm = curvedsky.map2alm(lensedcmb, lmax=2700)
cl = curvedsky.alm2cl(lensed_alm[:, None], lensed_alm)
```

```python id="K_M_UVJ2MY2P"
ell = np.arange(cl.shape[-1])
dll_fac = (ell*(ell+1))/(2*np.pi)

camb_ell = np.arange(powers_lensed_camb[0].shape[-1])
camb_dll_fac = (camb_ell*(camb_ell+1))/(2*np.pi)

fig, ax = plt.subplots(2, 2, figsize=(10, 6))

ax[0,0].plot(cl[0, 0]*dll_fac,label="This notebook")
ax[0,0].plot(powers_lensed_camb[0]*camb_dll_fac,label="CAMB lensed")
ax[0,0].set_xlim(20, 2700)

ax[0,1].plot(cl[1, 1]*dll_fac,label="This notebook")
ax[0,1].plot(powers_lensed_camb[1]*camb_dll_fac,label="CAMB lensed")
ax[0,1].set_xlim(20, 2700)

ax[1,0].plot(cl[2, 2]*dll_fac,label="This notebook")
ax[1,0].plot(powers_lensed_camb[2]*camb_dll_fac,label="CAMB lensed")
ax[1,0].set_xlim(20, 2700)

ax[1,1].plot(cl[0, 1]*dll_fac,label="This notebook")
ax[1,1].plot(powers_lensed_camb[3]*camb_dll_fac,label="CAMB lensed")
ax[1,1].set_xlim(20, 2700)

ax[0,0].set_xlabel("$\ell$")
ax[0,0].set_ylabel("TT")
ax[0,1].set_xlabel("$\ell$")
ax[0,1].set_ylabel("EE")
ax[1,0].set_xlabel("$\ell$")
ax[1,0].set_ylabel("BB")
ax[1,1].set_xlabel("$\ell$")
ax[1,1].set_ylabel("TE")

plt.tight_layout()
plt.legend()
plt.show()
```

<!-- #region id="7hBJxBOkNny0" -->
Hooray, that worked well -- look at how much better the BB spectrum matches! Evidently the flat-sky lensing example was indeed biased either by its flat-sky treatment and/or simplistic handling of the mask when measuring the power spectrum. However, we should keep in mind that the lensing is not accurate out to the bandlimit -- we need to build-in some buffer to our analysis by lensing to a high bandlimit but only using larger scales (in this case, e.g., <2000).
<!-- #endregion -->

<!-- #region id="AzJ6umw3QylK" -->
**Point Sources**
<!-- #endregion -->

<!-- #region id="vMfdDrc6Uz-3" -->
In CMB maps we typically have extragalactic point sources emission and galaxy clusters through the Sunyaev Zel'dovich effect. The former are bright spots in the map and the latter it is a decrement for frequencies below 220 GHz and increment above 220 GHz, the effect it null approximately at 220 GHz.

To simulate point sources we need a profile, since these galaxies are usually unresolved points in the sky their profile is the telescope beam. For a 6-meter telescope the full width at half maximum of the beam is roughly 1.4 arcminutes at 150 GHz, we can simplify the profile as Gaussian.

Considering that a unit normalized Gaussian centered at zero has the form $\exp{\left( -\frac{r^2}{2\sigma^2} \right)}$ and the full width at half maximum is $\mathrm{FWHM} = 2 \sqrt{2 \ln(2)} \sigma$, we have the following functional form for the beam: $\exp{\left(-\frac{4\ln(2)r^2}{\mathrm{FWHM}^2}\right)}$
<!-- #endregion -->

```python id="NvSpC9LmVHGm"
# Generating a Gaussian beam
FWHM = 1.4
r = np.linspace(0, 60, 1000) # 60 arcminutes or 1 degree
B = np.exp(-(4*np.log(2)*r**2) / (FWHM**2))
plt.plot(r, B)
plt.xlim(0, 5)
plt.ylabel("Beam amplitude")
plt.xlabel("Radius (arcmin)")
# we need to pass the radius to radians
r *= 1/60 * np.pi / 180
```

<!-- #region id="_nvc372KVKd-" -->
Now we can generate sources, for that we will use the `pointsrcs` module, in specific the function `sim_objects`, this function requires the following:

`shape`: Shape of the map in which we will inject sources, in our case omap.shape

`wcs`: World coordinates of the map in which we will inject sources in our case omap.wcs

`poss`: Position of the sources that we want to inject in the form [dec,ra] where dec and ra are arrays of floats with the declination and right ascension of the sources in radians

`amp`: Amplitude of the sources that we want to inject, this is the peak value of the beam in temperature units as an array of floats

`profile`: The radial profile of the sources, in case of point sources this profile is the beam, but for example for cluster it could be a more extended profile, the profile is given as [r,B] where r is the radius in radians and B is the profile amplitude

`vmin=None`: The lowest value to simulate in map units, by default it takes 1e-3*amp.

`pixwin=False`: If we want to apply the pixel window function after simulating the objects.

A nice feature of this function is that it automatically handles the "distorted" geometry near the poles, so that radially-symmetric objects will appear horizontally stretched (as they should). This won't be evident in the small cutout below but it is important for a full-sky simulation:

<!-- #endregion -->

```python id="F9-AaBFoVMsW"
             # DEC0, RA0  DEC1 RA1
box = np.array([[-10, 35],[-2, 15]]) * utils.degree
shape, wcs = enmap.geometry(pos=box, res=0.5 * utils.arcmin, proj='car')
# we will use only the temperature component or parameter stokes I

# we will generate 100 sources
nsrc = 100
# we choose a logspace between 100 and 10000
amp = np.logspace(2.0, 4.0, nsrc)
# the position are random values inside omap
dec = np.random.uniform(-10, -2, nsrc) * np.pi / 180
ra = np.random.uniform(15, 35, nsrc)  *np.pi / 180

# we generate the sourcemap here
srcmap = pointsrcs.sim_objects(shape, wcs, [dec, ra], amp, [r, B],
                               min=np.min(amp)*1e-4)

# plotting the result
enplot.pshow(srcmap, range=500)

# adding to a cmb map
cmbmap = curvedsky.rand_map(shape, wcs, ps=ps[0])
enplot.pshow(srcmap + cmbmap, range=500)
```

<!-- #region id="8mmWPSZwTsbn" -->
**Simplistic Noise**

Finally we consider simple, additive noise that you can add to any of the previous realizations of the underlying "signal." Unlike the signal, which dies off quickly as a function of $\ell$, the noise is not bandlimited. Realistic noise in the maps is quite complicated (see https://arxiv.org/abs/2303.04180), so here we just show a simplified example. In fact, we've already used all of the tools.

We want to go back the case of using `enmap.rand_map` -- the flat-sky code -- to generate Gaussian realizations on the full-sky. This was unphysical for the signal, but for the noise, it is faster, sufficient, and in some ways better (again, the realization is not bandlimited).

We define a realistic noise power spectrum and level, and can also exploit that noise is ~symmetric in E and B to just perform a "scalar" rather than spin-2 transform:
<!-- #endregion -->

```python id="WlPiL9zOiBtS"
# make a polarized noise ps function
def T_and_P_noise_ps(ell, white_level=30, noise_ps_scaling=-4, T_knee=3000,
                     T_cap=300, P_knee=300, P_cap=100):
  """Get the temperature and polarization noise power spectra evaluated at ell.
  Follows this model:

  PS(ell) = white_level**2 * ((ell/knee)**scaling + 1), ell > cap
  PS(ell) = white_level**2 * ((cap/knee)**scaling + 1), ell <= cap

  Parameters
  ----------
  ell : (...) np.ndarray
    Angular scales.
  white_level : scalar
    Temperature white noise level in uK-arcmin. Polarization is this times
    sqrt(2).
  noise_ps_scaling : scalar
    Power-law scaling of the low-ell noise power spectra.
  T_knee : scalar
    Ell-knee of temperature power spectrum.
  T_cap : scalar
    Minimum ell at which the spectrum is capped.
  P_knee : scalar
    Ell-knee of polarization power spectrum.
  P_cap : scalar
    Minimum ell at which the spectrum is capped.

  Returns
  -------
  (3, ...) np.ndarray
    The polarization noise power spectra in T, Q, U. Assumed diagonal over
    polarization.
  """
  T = np.zeros_like(ell)
  mask = ell <= T_cap
  T[mask] = white_level**2 * ((T_cap/T_knee)**noise_ps_scaling + 1)
  T[~mask] = white_level**2 * ((ell[~mask]/T_knee)**noise_ps_scaling + 1)

  P = np.zeros_like(ell)
  mask = ell <= P_cap
  P[mask] = 2 * white_level**2 * ((P_cap/P_knee)**noise_ps_scaling + 1)
  P[~mask] = 2 * white_level**2 * ((ell[~mask]/P_knee)**noise_ps_scaling + 1)


  # convert to steradians (note, not square radians!). the below lines first
  # convert to square radians, then from square radians to steradians
  T *= utils.arcmin**2 * (4*np.pi / (np.pi * 2*np.pi))
  P *= utils.arcmin**2 * (4*np.pi / (np.pi * 2*np.pi))

  # put into square shape and return
  out = np.zeros((3, 3, *ell.shape), ell.dtype)
  out[0, 0] = T
  out[1, 1] = P
  out[2, 2] = P

  return out
```

<!-- #region id="4649BFRFGl57" -->
Let's see what the default looks like as a function of $\ell$. This includes large-scale correlated noise from the atmosphere as would be observed by the SO LAT, but the SO SAT includes a half-wave plate and processing filters to mitigate this, so the noise spectra would need adjustment:
<!-- #endregion -->

```python id="idE-iUuHGWLA"
ell = np.arange(10000, dtype=np.float64)
noise_ps = T_and_P_noise_ps(ell)
plt.loglog(ell, noise_ps[0, 0])
plt.loglog(ell, noise_ps[1, 1])
```

<!-- #region id="p3frLSYIAny_" -->
Let's make a convenience function to draw noise realizations, since this will also need to take into account the area of each pixel to keep the white-noise level consistent:
<!-- #endregion -->

```python id="xHb547KoHEd2"
def get_noise_sim(shape, wcs, seed=None, **T_and_P_noise_ps_kwargs):
  """Draw a noise realization from the constructed noise powre spectrum
  that also accounts for the smaller, and thus noisier, pixels near the
  poles.

  Parameters
  ----------
  shape : (ny, nx) tuple
    The footprint of the map.
  wcs : astropy.wcs.wcs.WCS
    The geometry of the map. Assumes units of degrees (the pixell
    default for wcs).
  seed : int or list of int
    Random seed.
  T_and_P_noise_ps_kwargs : dict
    Keyword arguments to be passed to T_and_P_noise_ps.

  Returns
  -------
  (3, ny, nx) enmap.ndmap
    Noise realization (polarized) drawn from T_and_P_noise_ps, with the
    correct white-noise level, correlated noise shape, and corrected for
    pixel areas.
  """
  # get the noise ps. for enmap.rand_map to work, this needs to be
  # evaluated at integer ells and cover all the angular scales in
  # out 2d fourier space
  ell = np.arange(0, np.ceil(enmap.modlmap(shape, wcs).max()) + 1)
  noise_ps = T_and_P_noise_ps(ell, **T_and_P_noise_ps_kwargs)

  # draw a noise realization
  noise_sim = enmap.rand_map((3, *shape), wcs, cov=noise_ps, seed=seed,
                             scalar=True)

  # normalize by pixel area. we want this in terms of fraction of a
  # "flat-sky" pixel
  pixsize_steradians = enmap.pixsizemap(shape, wcs, broadcastable=True)
  pix_area_deg = np.abs(np.prod(wcs.wcs.cdelt))
  pix_area_steradians = pix_area_deg * utils.degree**2
  frac_pixsize = pixsize_steradians / pix_area_steradians

  return noise_sim / np.sqrt(frac_pixsize)
```

<!-- #region id="zbaSqjRtKnTc" -->
Let's try it out on the full-sky:
<!-- #endregion -->

```python id="Sj0bsLPVKqBy"
shape, wcs = enmap.fullsky_geometry(res=4*utils.arcmin, proj='car')

noise_sim = get_noise_sim(shape, wcs)

for i in range(3):
  enplot.pshow(noise_sim[i], downgrade=4, ticks=15, colorbar=True)
```

<!-- #region id="oOnru2LQLR-3" -->
### Put it all together

Let's take all the above pieces and make a not-so-unrealistic simulation of data as would be observed by an actual CMB experiment:



1.   We'll draw a full-sky unlensed T, Q, U CMB realization and a full-sky realization of the lensing potential and use it to "lens" the CMB
2.   We'll add a new step to the above: convolve the resulting signal with
the instrumental beam so that it is consistent with the point sources
3.   We'll inject a sample of point sources with the same beam size. Assume they are not polarized
4.   We'll add a T, Q, U noise realization to the signal

This simulation omits quite a lot of real-world complexity in each of its parts --- we won't include any scan-synchronous signal, beam leakage or pixel window function, polarized or extended or "SZ-like" sources, or realistic noise --- but it is actually fairly representative.

We'll wrap it in a big convenience function. Play around with all the inputs or add even more arguments to make it more tunable!

(Exercise: An obvious way to streamline the below function would be to allow the user to pass pre-built signal or noise maps. That way someone could more efficiently add multiple noise realizations to the same signal realization, without rebuilding the same signal map each time)

<!-- #endregion -->

```python id="d7YD88NvLU_B"
import healpy as hp

def get_signal_and_noise_sim(shape, wcs, lmax, ps_cmb, ps_lens, cmb_seed=None,
                             phi_seed=None, src_pos_seed=None, noise_seed=None,
                             beam_fwhm=1.4, nsrc=10000, white_level=30,
                             noise_ps_scaling=-4, T_knee=3000, T_cap=300,
                             P_knee=300, P_cap=100):
  """Draw a semi-realistic end-to-end sim including lensed CMB, temperature
  point sources, instrumental beam, and instrumental and atmospheric noise.

  Parameters
  ----------
  shape : (ny, nx) tuple
    The footprint of the map.
  wcs : astropy.wcs.wcs.WCS
    The geometry of the map. Assumes units of degrees (the pixell
    default for wcs).
  lmax : int
    maximum multipole for the signal
  ps_cmb : (3, 3, nl) np.ndarray
    CMB TEB power spectra with covariances
  ps_lens : (nl,) np.ndarray
    Lensing potential power spectrum
  cmb_seed : int or list of int
    Seed for unlensed CMB
  phi_seed : int or list of int
    Seed for lensing potential
  src_pos_seed : int or list of int
    Seed for point source locations
  noise_seed : int or list of int
    Seed for noise
  beam_fwhm : scalar
    Beam width in arcmin
  nsrc : int
    Number of point sources logarithmically distributed between
    100 and 10000 uK
  white_level : scalar
    Temperature white noise level in uK-arcmin. Polarization is this times
    sqrt(2).
  noise_ps_scaling : scalar
    Power-law scaling of the low-ell noise power spectra.
  T_knee : scalar
    Ell-knee of temperature power spectrum.
  T_cap : scalar
    Minimum ell at which the spectrum is capped.
  P_knee : scalar
    Ell-knee of polarization power spectrum.
  P_cap : scalar
    Minimum ell at which the spectrum is capped.

  Returns
  -------
  (3, ny, nx) enmap.ndmap
    The simulation
  """

  # get lensed CMB. assume lensing indep. of CMB (not true)
  phi_alm = curvedsky.rand_alm(ps=ps_lens, lmax=lmax, seed=phi_seed)
  cmb_alm = curvedsky.rand_alm(ps=ps_cmb, lmax=lmax, seed=cmb_seed)
  lensedcmb = lensing.lens_map_curved((3, *shape), wcs, phi_alm, cmb_alm,
                                      output="l", verbose=True)[0]

  # convolve it with the beam. fwhm in radians
  bl = hp.gauss_beam(beam_fwhm * utils.arcmin, lmax=lmax)
  lensedcmb_alm = curvedsky.map2alm(lensedcmb, lmax=lmax)
  curvedsky.almxfl(lensedcmb_alm, bl, out=lensedcmb_alm)
  curvedsky.alm2map(lensedcmb_alm, lensedcmb)

  # add srcs (already convolved with beam)
  r = np.linspace(0, 60, 1000) * utils.arcmin # 60 arcminutes or 1 degree
  B = np.exp(-4*np.log(2)*r**2 / (beam_fwhm*utils.arcmin)**2)
  amp = np.logspace(2.0, 4.0, nsrc)

  src_rng = np.random.default_rng(src_pos_seed)
  dec = src_rng.uniform(-90, 90, nsrc) * utils.degree
  ra = src_rng.uniform(-180, 180, nsrc)  * utils.degree
  srcmap = pointsrcs.sim_objects(shape, wcs, [dec, ra], amp, [r, B],
                                 vmin=np.min(amp)*1e-4)

  # and noise
  noisemap = get_noise_sim(shape, wcs, seed=noise_seed, white_level=white_level,
                           noise_ps_scaling=noise_ps_scaling, T_knee=T_knee,
                           T_cap=T_cap, P_knee=P_knee, P_cap=P_cap)

  out = lensedcmb + noisemap
  out[0] += srcmap
  return out
```

```python id="tA4kJ4eLTIFa"
totalsim = get_signal_and_noise_sim(shape, wcs, 2700, ps_cmb, ps_lens)

for i in range(3):
  enplot.pshow(totalsim[i], downgrade=4, ticks=15, colorbar=True)
```


---

# pixell_spherical_harmonics.md

---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.17.2
  kernelspec:
    display_name: Python 3
    name: python3
---

<!-- #region id="yPF5lzLN9DJB" -->
# Spherical Harmonics with pixell


*Written by the ACT Collaboration*

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/simonsobs/pixell_tutorials/blob/master/pixell_spherical_harmonics.ipynb)

---

This notebook, and the accompanying notebooks included in this set, are designed to help users who are new to working with [`pixell`](https://github.com/simonsobs/pixell/) get started with the package. As a set these notebooks will guide users through examples of how to read in and display maps, how to perform spherical harmonic transform and calculate simple spectra, how to transform the maps and how to study point sources in the maps.

The `pixell` library allows users to load,
manipulate and analyze maps stored in rectangular pixelization. It is
mainly targeted for use with maps of the sky (e.g. CMB intensity and polarization maps, stacks of 21 cm intensity maps, binned galaxy positions or shear) in cylindrical projection.

In this notebook we'll look at how to get the *alms* of a map with `pixell`. We'll also demonstrate how to filter the *alms* and how to project the *alms* back to map space. Lastly we'll demonstrate how the *alms* can be used with [`healpy`](https://healpy.readthedocs.io/en/latest/index.html), a python wrapper of `healpix`.
<!-- #endregion -->

```python id="GPzMLmYO98my" colab={"base_uri": "https://localhost:8080/"} outputId="cf9b98ea-1656-4bb2-b199-2e1a6ca9c7fd"
# Download the data needed for the notebook
!wget https://phy-act1.princeton.edu/public/zatkins/act_planck_dr5.01_s08s18_AA_f150_night_map_d56.fits
```

```python id="kDFKT4bz89Ra" colab={"base_uri": "https://localhost:8080/"} outputId="110af6c4-2ada-4a21-862a-e280725c7581"
# Install neccesary packages
!pip install pixell
```

```python id="s3We41ht94xX"
# Import packages
from pixell import curvedsky, enmap, enplot
import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
```

<!-- #region id="RFGNWqMC9yb5" -->
**Reading maps from disk**

For more details on how to use maps in pixell take a look at the map manipulation notebook!
<!-- #endregion -->

```python id="NX2A3eIk-y0J" colab={"base_uri": "https://localhost:8080/"} outputId="bd20d480-8f2e-4d3e-e084-10fc0eb7bf0c"
## This map has I, Q, U components which can each be accessed individually
imap = enmap.read_map("act_planck_dr5.01_s08s18_AA_f150_night_map_d56.fits")

print(imap[0].shape)

# To access the I component we can call imap[0].
# Q and U would be imap[1] and imap[2] respectively.
```

<!-- #region id="_vJ5OYvI9yjp" -->
A spherical harmonic transform (SHT) is analagous to an FFT, but for maps that live on the sphere rather than the flat sky. Their output is typically referred to as an *alm*, which are the components in the input map in the [spherical harmonic basis](https://en.wikipedia.org/wiki/Spherical_harmonics#Spherical_harmonics_expansion). Conventionally, each *alm* is represented as a 1d vector: all of the 2d information in the map gets reshaped into a 1d list of numbers in spherical harmonic space. If the map has a polarization component (so, a shape like `(3, Ny, Nx)`), then the output shape will be `(3, nalm)`, etc.

**Converting between maps and alms**

`pixell.curvedsky` has functions that allow users to convert maps to and from alms. In the next cell we'll demonstrate how to use these.


<!-- #endregion -->

```python id="zQ1LqS_W-8Ul"
# The transformation is limited by the `lmax` factor. Increasing this will make
# the alms exact on smaller scales but will also result in slower run times
lmax = 4000

alms = curvedsky.map2alm(imap[0], lmax=lmax)
```

<!-- #region id="aDqVWvk28FLI" -->
Unlike an FFT, the SHT is not fully information-preserving. Specifically, we need to select the maximum "ell" or "lmax" -- the minimum angular scale -- to calculate. Selecting a low value for the lmax will only calculate the *alm* for the larger-scale features, but will be faster, and vice versa. The size of the *alm* will reflect the specified lmax.

Let's query the alms shape. The spherical harmonics assume the input map is real to speed up calculation. Thus we expect there to be `(lmax + 1) * (lmax + 2) / 2` (why?) complex numbers:
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/"} id="rKnX3LtN8H87" outputId="12e8f885-45ef-4206-c679-3c937664f6c1"
print(alms.shape)

print((lmax+1) * (lmax+2) / 2, alms.dtype)
```

<!-- #region id="nBgshpw58Jam" -->
As expected, it is a 1d representation of the map in the spherical harmonic basis (up to ell=4000). If you want to know where in this array each *l* and *m* is located, we can do it (but it is rarely necessary):
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/"} id="82Ar-lZY9sww" outputId="4f1235e0-e61c-4f5b-e2e3-46e07e7e7714"
# an "alm_info" object contains lots of info and methods that can help with
# SHTs!
ainfo = curvedsky.alm_info(lmax=lmax)
ind = ainfo.lm2ind(l=100, m=99)
print(ind, alms[ind])
```

<!-- #region id="xi_1UfFO9rat" -->
Users can also pass an `alm_info` object into many `curvedsky` functions instead of `lmax` directly. This can be helpful if, for instance, we wish to get the returned *alm* in a "rectangular" (2d-compatible, useful for dealing with l's separately from m's) ordering instead of the default (1d, called "triangular"):
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 542} id="Pgxqle8UA-q4" outputId="346f418b-4436-4bcb-efa3-9c9f6d94db36"
ainfo_rect = curvedsky.alm_info(lmax=lmax, layout='rectangular')
alms_rect = curvedsky.map2alm(imap[0], ainfo=ainfo_rect)

print(alms_rect.shape)
print(f'expect (lmax+1)**2 = {(lmax+1)**2}')

# l's are across the columns, m's are across the rows
plt.imshow(np.log10(abs(alms_rect)).reshape(-1, (lmax+1)), origin='lower')
```

<!-- #region id="ucU7wxOGA8hL" -->
`alm_info` objects have other useful methods (such as transferring from one layout to another, and multiplying by l-dependent functions), and we encourage advanced users to check them out!

`pixell` also can transform an *alm* back to map space. Again, unless an `alm_info` object is explicitly passed, it is assumed that an *alm* is in the default "triangular" layout.
<!-- #endregion -->

```python id="6shX78elZYW9"
# You can also convert the alms back to maps with `curvedsky`. This will project
# the alms onto an existing enmap so you'll also need to provide an enmap for
# the function. If it's not empty, it will be overwritten!

out = imap[0]*0 # a new ndmap with 0's and the same shape, dtype, wcs as the input
omap = curvedsky.alm2map(alms, out)
```

```python colab={"base_uri": "https://localhost:8080/", "height": 1000} id="BFVUGlUZZ7hR" outputId="8ac9c902-8977-4470-bbf7-c2ce4f5cda53"
# We can plot the two maps and check if they look consistent

enplot.pshow(imap[0], downgrade=4, colorbar=True, range=250)
enplot.pshow(omap, downgrade=4, colorbar=True, range=250)
enplot.pshow(omap - imap[0], downgrade=4, colorbar=True, range=250)
```

<!-- #region id="KiwCFIrOEtjW" -->
Note the main difference between the output and the input is "ringing" around bright point sources. This is because we specified an lmax of 4000 -- we bandlimited the input and therefore excluded smaller scale information. Point sources have signal at small scales -- we are seeing the high-frequency (small-scale) information beyond l's of 4000.

Like the FFT `map2harm` function, we can handle polarized maps automatically. Remember `imap` is polarized:
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 1000} id="De6wPCCoF-CT" outputId="c5724255-1cef-4e8d-cb9b-029b765d0b66"
print(imap.shape)

enplot.pshow(imap[0], downgrade=4, colorbar=True)
enplot.pshow(imap[1:], downgrade=4, colorbar=True, color='gray')
```

<!-- #region id="ubIiXjCbGAX9" -->
By default, `map2alm` will assume a polarized map with 3 components -- I, Q, and U -- and give the output *alms* in T (same as I), E, and B. This is controlled by the `spin` argument:
<!-- #endregion -->

```python id="F2sg8PKzqrwq" colab={"base_uri": "https://localhost:8080/"} outputId="021e8d53-80d4-45b1-ca4f-d464e035a7d5"
# We can also convert the polarized maps to E and B maps using the `map2alm` function

# Spin tells `map2alm` how to treat the different components.
# 0 refers to a scalar transform for the I (T) component
# 2 refers to a spin-2 transform for the Q and U components.

alms = curvedsky.map2alm(imap, spin=[0,2], lmax=lmax) # spin=[0, 2] is default

print(alms.shape)
```

<!-- #region id="AW4HcVDIGwFC" -->
Likewise, by default, `alm2map` converts from T, E, and B back into I, Q and U:
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 1000} id="lp58schSG3b9" outputId="bffbdfe3-adb8-4f60-b8b4-68d6ac8ed09c"
out = imap*0 # a new ndmap with 0's and the same shape, dtype, wcs as the input
omap = curvedsky.alm2map(alms, out) # spin=[0, 2] is default

print(omap.shape)

enplot.pshow(omap[0], downgrade=4, colorbar=True)
enplot.pshow(omap[1:], downgrade=4, colorbar=True, color='gray')
```

<!-- #region id="p8KeW42kHnGD" -->
If we want to visualize the E and B maps, rather than Q and U, we first need to do `map2alm` with the default `spin=[0,2]` and then `alm2map` with a spin-0 transform:
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 1000} id="iUZqKzwnsZfs" outputId="1beb0997-e8ec-4f06-dc82-0b0237f2ef53"
# we can then project these to map space
IEBmap = curvedsky.alm2map(alms, imap.copy(), spin=[0,0]) # specify "0" for the Q, U components now

print(IEBmap.shape)

enplot.pshow(IEBmap[0], downgrade=4, colorbar=True)
enplot.pshow(IEBmap[1:], downgrade=4, colorbar=True, color='gray')
```

<!-- #region id="b9F0nNUDjJNH" -->
As expected, we see signal-dominated E modes, but B is consistent with noise!

**Filtering the maps**

Given some filter `fl` you can also filter alms using the `curvedsky.almxfl` function.
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 469} id="WpJcnjf-hKjY" outputId="506b7838-b4dc-4fd6-e103-21918b15f673"
# Lets start by creating a filter
fl = np.ones(lmax+1) # l=0 is one of the ells!
fl[:200] = 0         # cut out large scales

# Let's plot the filter.
plt.plot(fl)
plt.ylabel("Filter value")
plt.xlabel("ell")
plt.show()
```

<!-- #region id="ZbUQayeEihXn" -->
This filter will set large scale modes to 0. The filter itself could be any function of ell that you choose, this one was just chosen to demonstrate the process.
<!-- #endregion -->

```python id="zmSPzXd9ig8Z"
# Let's apply the filter
alms = curvedsky.map2alm(imap[0], lmax=lmax)
filtered_alms = curvedsky.almxfl(alms, fl)
```

```python id="fsLDYKqBVF5k"
# We can also try filtering out the small scales for comparison
fl = np.ones(lmax + 1)
fl[200:] = 0

filtered_alms_small_scales = curvedsky.almxfl(alms, fl)
```

```python id="WwoSMTJjS9Ga" colab={"base_uri": "https://localhost:8080/", "height": 742} outputId="721368e0-8650-4264-a13c-7c55dd6eb13e"
# We can then project the filtered alms to map space and take a look at the resulting map
filtered_map = curvedsky.alm2map(filtered_alms, imap[0].copy())
filtered_map_small_scales = curvedsky.alm2map(filtered_alms_small_scales, imap[0].copy())
enplot.pshow(filtered_map, downgrade=4, colorbar=True)
enplot.pshow(filtered_map_small_scales, downgrade=4, colorbar=True)
```

<!-- #region id="QDoBLL4Qixey" -->
Here we can see that in the first map the large scale modes are no longer visible as they've been filtered out. On the other hand, the second map shows just the large scale modes as we've removed the small scale modes with the second filter. `almxfl` can also accept functions of ell instead of a filter array.

**Calculate a power spectrum**

Just like in the FFT case, we can calculate the power in the maps as a function of angular scale. Very conveniently, because the *alms* are naturally in a basis where angular scale is directly indexed by `l`, we don't need any intermediate and inexact "binning" function like for FFTs. Instead we just use `curvedsky.alm2cl`.

We do still want to apodize the map edges to avoid discontinuities at the map edge:
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/"} id="S2nCzJ2AnXRY" outputId="b173f778-92a6-4ef9-f61e-20e2af9b67a5"
# get an apodized mask, multiply the map before doing map2alm
taper_mask = enmap.apod(enmap.ones(imap[0].shape, imap[0].wcs), width=100)
alms_taper = curvedsky.map2alm(taper_mask * imap, lmax=lmax)

# get the correction factor that accounts for the power lost due to only observing a
# fraction of the sky
# enmap.pixsizemap is a map of all the physical pixel areas in steradians
w2 = np.sum(taper_mask.pixsizemap() * taper_mask**2) / (4*np.pi)

# squaring and averaging over m is done by the alm2cl function
cl = curvedsky.alm2cl(alms_taper) / w2

# The shape here is refers to TT, EE, and BB spectra
print(cl.shape)
```

<!-- #region id="9yUfd_mvoz67" -->
We can plot the cls:
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 475} id="zAPuz7AGo1mJ" outputId="94b17687-2af4-453f-9dc7-f44686fbcdc6"
l = np.arange(cl.shape[1])

# plot
for i in range(3):
  plt.semilogy(l, cl[i] * l *(l+1) / 2 / np.pi, label=['TT', 'EE', 'BB'][i])
plt.ylim(1e-1, 1e4)
plt.legend()
```

<!-- #region id="1n59Ry56qr9R" -->
By default, `alm2cl` will just get the autospectrum of each component in the *alms*. We can also pass a second, different *alm* to take a cross spectrum. Or, we can get the cross spectra between the different components of an alm like so:
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 892} id="5O0K8YsSq-Dq" outputId="7addb109-e4b9-4fd5-8c16-fc1d863d375a"
# squaring and averaging over m is done by the alm2cl function
# take cross spectra using numpy array broadcasting of the input shapes
clx = curvedsky.alm2cl(alms_taper[:, None], alms_taper[None, :]) / w2

print(clx.shape)

# plot
for i in range(3):
  plt.semilogy(l, clx[i, i] * l *(l+1) / 2 / np.pi, label=['TT', 'EE', 'BB'][i])
plt.ylim(1e-1, 1e4)
plt.legend()
plt.show()

for i in range(3):
  for j in range(i + 1, 3):
    plt.plot(l, clx[i, j] * l *(l+1) / 2 / np.pi, label='TEB'[i] + 'TEB'[j])
plt.legend()
plt.show()
```

<!-- #region id="FIgq7BMw9ysb" -->
A real cosmological analysis would need to use a *mode coupling matrix*, not the simple `w2` factor shown here!

**Using Healpy with alms**

Other than the coordinate system, *alms* don't know anything about the map pixelization that produced them. So they are a way of "translating" between different pixelization schemes (but with a the bandlimit set by `lmax`!). This means that once we have an *alm*, we can project it back into a map that uses the `healpix` pixelization using `healpy`:
<!-- #endregion -->

<!-- #region id="G-LYRFgHVun6" -->
We can also project the alms to a `healpix` map and plot it with `healpy`. Note that pixell also has specific functions designed for reprojecting to `healpix` which are documented in the  reprojection notebook.
<!-- #endregion -->

```python colab={"base_uri": "https://localhost:8080/", "height": 327} id="9Lnb4-AHVuJr" outputId="641e4442-96d7-439f-9ad5-e8753ac00af6"
hp_map = hp.alm2map(alms_taper[0], 4096)

# Because we're only using a small patch of the sky we use cartview to plot
# and pass `lonra` and `latra` to select the area of the sky we wish to show.
hp.cartview(hp_map, min = -300, max=300, lonra =  [-10,45], latra =  [-8,5])
```

<!-- #region id="bCnXZk3IXRsg" -->
One thing to note is that these reprojections wont automatically set the masked pixells to `hp.UNSEEN`. If you wish to mask data we recommend you project a mask to `healpix` and then assign `hp.UNSEEN` to masked regions based on the reprojected mask.
<!-- #endregion -->

<!-- #region id="m5A9eBuf3k0Q" -->
**Further reading and other examples**

The ACT DR4 and DR5 notebooks, which are publicly [available on github](https://github.com/ACTCollaboration/DR4_DR5_Notebooks), include a more realistic example of how to compute power spectra in [Notebook 7](https://github.com/ACTCollaboration/DR4_DR5_Notebooks/blob/master/Notebooks/Section_7_power_spectra_part_1.ipynb).

For more examples of how to use `pixell` please see the full set of notebooks available on github.
<!-- #endregion -->

```python id="hPMLJBqu4Zty"

```

