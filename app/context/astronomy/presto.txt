# - Complete Documentation | presto -



---

# DDplan.md

### Function `choose_downsamps`

choose_downsamps(blocklen):
    Return a good list of possible downsample sizes given a
    block of data of length blocklen spectra.

### Function `dm_smear`

dm_smear(DM, BW, f_ctr, cDM=0.0):
    Return the smearing in ms caused by a 'DM' over a bandwidth
    of 'BW' MHz centered at 'f_ctr' MHz.

### Function `BW_smear`

BW_smear(DMstep, BW, f_ctr):
    Return the smearing in ms caused by a search using a DM stepsize of
    'DMstep' over a bandwidth of 'BW' MHz centered at 'f_ctr' MHz.

### Function `guess_DMstep_approx`

guess_DMstep_approx(dt, BW, f_ctr):
    Choose a reasonable DMstep by setting the maximum smearing across the
    'BW' to equal the sampling time 'dt'. This assumes that the BW is small
    compared to f_ctr.

### Function `guess_DMstep`

guess_DMstep(dt, BW, f_ctr):
    Choose a reasonable DMstep by setting the maximum smearing across the
    'BW' to equal the sampling time 'dt'.

### Function `subband_smear`

subband_smear(subDMstep, numsub, BW, f_ctr):
    Return the smearing in ms caused by a search using a subband
    DM stepsize of 'subDMstep' over a total bandwidth of 'BW' MHz
    centered at 'f_ctr' MHz, and having numsub subbands.

### Function `total_smear`

total_smear(DM, DMstep, dt, f_ctr, BW, numchan, subDMstep, cohdm=0.0, numsub=0):
    Return the total smearing in ms due to the sampling rate,
    the smearing over each channel, the smearing over each subband
    (if numsub > 0) and the smearing over the full BW assuming the
    worst-case DM error.

### Function `dm_steps`

dm_steps(loDM, hiDM, obs, cohdm=0.0, numsub=0, numprocs=1,
         ok_smearing=0.0, blocklen=None, device="/XWIN"):
    Return the optimal DM stepsizes (and subband DM stepsizes if
    numsub>0) to keep the total smearing below 'ok_smearing' (in ms),
    for the DMs between loDM and hiDM.  If 'ok_smearing'=0.0, then
    use the best values based only on the data.  If the blocklen is
    not None, use it to determine possible downsampling values.
    And if device is not None, use it as the PGPLOT device for plotting.

### Function `chan_smear`

Return the smearing (in ms) in each channel at the specified DM

### Function `total_smear`

Return the total smearing in ms due to the sampling rate,
the smearing over each channel, the smearing over each subband
(if numsub > 0) and the smearing over the full BW assuming the
worst-case DM error.

### Function `DM_for_smearfact`

Return the DM where the smearing in a single channel is a factor smearfact
larger than all the other smearing causes combined.

### Function `DM_for_newparams`

Return the DM where the smearing in a single channel causes the same smearing
as the effects of the new downsampling rate and dDM.


---

# GBNCC_search.md

### Function `find_masked_fraction`

find_masked_fraction(obs):
    Parse the output file from an rfifind run and return the
    fraction of the data that was suggested to be masked.

### Function `timed_execute`

timed_execute(cmd):
    Execute the command 'cmd' after logging the command
        to STDOUT.  Return the wall-clock amount of time
        the command took to execute.

### Function `get_folding_command`

get_folding_command(cand, obs, ddplans, maskfile):
    Return a command for prepfold for folding the subbands using
        an obs_info instance, a list of the ddplans, and a candidate 
        instance that describes the observations and searches.

## Class `obs_info`

class obs_info(fits_filenm)
    A class describing the observation and the analysis.

## Class `dedisp_plan`

class dedisp_plan(lodm, dmstep, dmsperpass, numpasses, numsub, downsamp)
   A class describing a de-dispersion plan for prepsubband in detail.


---

# GBT350_drift_prep.md

### Function `spigot_samples_per_file`

spigot_samples_per_file(spigot_filenm,):
    Return the number of samples present in the Spigot FITs file.


---

# GBT350_drift_search.md

### Function `find_masked_fraction`

find_masked_fraction(obs):
    Parse the output file from an rfifind run and return the
    fraction of the data that was suggested to be masked.

### Function `timed_execute`

timed_execute(cmd):
    Execute the command 'cmd' after logging the command
        to STDOUT.  Return the wall-clock amount of time
        the command took to execute.

### Function `get_folding_command`

get_folding_command(cand, obs, ddplans):
    Return a command for prepfold for folding the subbands using
        an obs_info instance, a list of the ddplans, and a candidate 
        instance that describes the observations and searches.

## Class `obs_info`

class obs_info(fil_filenm)
    A class describing the observation and the analysis.

## Class `dedisp_plan`

class dedisp_plan(lodm, dmstep, dmsperpass, numpasses, numsub, downsamp)
   A class describing a de-dispersion plan for prepsubband in detail.


---

# GUPPI_drift_prep.md

### Function `guppi_subint_per_file`

guppi_samples_per_file(spigot_filenm,):
    Return the number of subints present in the GUPPI FITs file.


---

# PALFA_presto_search.md

### Function `fix_fil_posn`

fix_fil_posn(fil_filenm, hdrlen, ra, dec):
    Modify the filterbank header and update the RA and DEC
        fields using the values given as input.  ra and dec
        should be in 'HH:MM:SS.SSSS' and 'DD:MM:SS.SSSS' format.
        hdrlen is the length of the filterbank header as
        reported by PRESTO's 'readfile' or SIGPROC's 'header'.

### Function `read_db_posn`

read_db_posn(orig_filenm, beam):
    Find the original WAPP filename in the db_pointing_file
       and return the sexagesimal position strings for
       the choen beam in that file.  Return None if not found.

### Function `find_masked_fraction`

find_masked_fraction(obs):
    Parse the output file from an rfifind run and return the
        fraction of the data that was suggested to be masked.

### Function `get_all_subdms`

get_all_subdms(ddplans):
    Return a sorted array of the subdms from the list of ddplans.

### Function `find_closest_subbands`

find_closest_subbands(obs, subdms, DM):
    Return the basename of the closest set of subbands to DM
    given an obs_info class and a sorted array of the subdms.

### Function `timed_execute`

timed_execute(cmd):
    Execute the command 'cmd' after logging the command
        to STDOUT.  Return the wall-clock amount of time
        the command took to execute.

### Function `get_folding_command`

get_folding_command(cand, obs, ddplans):
    Return a command for prepfold for folding the subbands using
        an obs_info instance, a list of the ddplans, and a candidate 
        instance that describes the observations and searches.

## Class `obs_info`

class obs_info(fil_filenm)
    A class describing the observation and the analysis.

## Class `dedisp_plan`

class dedisp_plan(lodm, dmstep, dmsperpass, numpasses, numsub, downsamp)
    A class describing a de-dispersion plan for prepsubband in detail.


---

# Pgplot.md

# Module docstring

Routine for easy to use 1-D and 2-D plotting using 'PGPLOT'
      and the Python 'PPGPLOT' package

Written by Scott M. Ransom (ransom@cfa.harvard.edu)
         last revision: 01 Jul 2000

'PGPLOT' was writtten by Tim Pearson <tjp@astro.caltech.edu>,
and can be found at http://astro.caltech.edu/~tjp/pgplot/

'PPGPLOT' was written by Nick Patavalis <npat@ariadne.di.uoa.gr>,
and can be found at http://ariadne.di.uoa.gr/ppgplot/
_or_ an updated version is available in the same directory
where this file was found:  ftp://cfa-ftp.harvard.edu/pub/ransom

### Function `scalerange`

scalerange(data):
    Adjust the range to be plotted so that it fits nicely on the page.
    Return a list with adjusted minimum and maximum values from 'data'.

### Function `resetdefaults`

resetdefaults():
    Reset global plotting variables to default values.

### Function `nextplotpage`

nextplotpage():
    Advance the plotting device to a new page.
    The optional entry is:
        reset: reset defaults or not (default = 0 (no)) 

### Function `prepplot`

prepplot(rangex, rangey, ...)
    Open a PGPLOT device for plotting.
        'rangex' and 'rangey' are sequence objects giving min and
            max values for each axis.
    The optional entries are:
        title:    graph title                 (default = None)   
        labx:     label for the x-axis        (default = None)   
        laby:     label for the y-axis        (default = None)   
        rangex2:  ranges for 2nd x-axis       (default = None)   
        rangey2:  ranges for 2nd y-axis       (default = None)   
        labx2:    label for the 2nd x-axis    (default = None)   
        laby2:    label for the 2nd y-axis    (default = None)   
        logx:     make the 1st x-axis log     (default = 0 (no))
        logy:     make the 1st y-axis log     (default = 0 (no))
        logx2:    make the 2nd x-axis log     (default = 0 (no))
        logy2:    make the 2nd y-axis log     (default = 0 (no))
        font:     PGPLOT font to use          (default = 1 (normal))
        fontsize: PGPLOT font size to use     (default = 1.0 (normal))
        id:       Show ID line on plot        (default = 0 (no)) 
        aspect:   Aspect ratio                (default = 1 (square))
        ticks:    Ticks point in or out       (default = 'in')   
        panels:   Number of subpanels [r,c]   (default = [1,1])
        device:   PGPLOT device to use        (default = '/XWIN')
    Note:  Many default values are defined in global variables
        with names like ppgplot_font_ or ppgplot_device_.

### Function `closeplot`

closeplot():
    Close the currently open plotting device

### Function `plotxy`

plotxy(y, ...)
    An interface to make various XY style plots using PGPLOT.
        'y' is the 1D sequence object to plot.
    The optional entries are:
        x:        x values                  (default = 0, 1, ...)
        title:    graph title               (default = None)   
        rangex:   ranges for the x-axis     (default = automatic)
        rangey:   ranges for the y-axis     (default = automatic)
        labx:     label for the x-axis      (default = None)   
        laby:     label for the y-axis      (default = None)   
        rangex2:  ranges for 2nd x-axis     (default = None)   
        rangey2:  ranges for 2nd y-axis     (default = None)   
        labx2:    label for the 2nd x-axis  (default = None)   
        laby2:    label for the 2nd y-axis  (default = None)   
        logx:     make the 1st x-axis log   (default = 0 (no))
        logy:     make the 1st y-axis log   (default = 0 (no))
        logx2:    make the 2nd x-axis log   (default = 0 (no))
        logy2:    make the 2nd y-axis log   (default = 0 (no))
        errx:     symmetric x errors        (default = None)   
        erry:     symmetric y errors        (default = None)   
        symbol:   symbol for points         (default = None)   
        line:     line style                (default = 1 (solid))
        width:    line width                (default = 1 (thin))
        color:    line and/or symbol color  (default = 'white')
        font:     PGPLOT font to use        (default = 1 (normal))
        fontsize: PGPLOT font size to use   (default = 1.0 (normal))
        id:       show ID line on plot      (default = 0 (no)) 
        noscale:  turn off auto scaling     (default = 0 (no)) 
        aspect:   aspect ratio              (default = 0.7727 (rect))
        ticks:    Ticks point in or out     (default = 'in')   
        panels:   Number of subpanels [r,c] (default = [1,1])
        device:   PGPLOT device to use      (default = '/XWIN')
        setup:    Auto-setup the plot       (default = 1)
    Note:  Many default values are defined in global variables
        with names like ppgplot_font_ or ppgplot_device_.

### Function `plotbinned`

plotbinned(y, ...):
    Plot x-y data that is binned.  This routine differs from
        plotxy() in that instead of each point being connected
        by diagonal lines, each point is actually a flat-line
        with the width of a bin.
        'y' is the numerical sequence of binned data to plot.
    The optional entries are:
        x:        x-centers of each bin.    (default = auto)
        title:    graph title               (default = None)   
        labx:     label for the x-axis      (default = 'Bins')
        laby:     label for the y-axis      (default = 'Counts')
        rangex:   ranges for the x-axis     (default = automatic)
        rangey:   ranges for the y-axis     (default = automatic)
        labx2:    label for the 2nd x-axis  (default = None)   
        laby2:    label for the 2nd y-axis  (default = None)   
        rangex2:  ranges for 2nd x-axis     (default = None)   
        rangey2:  ranges for 2nd y-axis     (default = None)   
        logx:     make the 1st x-axis log   (default = 0 (no))
        logy:     make the 1st y-axis log   (default = 0 (no))
        logx2:    make the 2nd x-axis log   (default = 0 (no))
        logy2:    make the 2nd y-axis log   (default = 0 (no))
        erry:     symmetric y errors        (default = None)   
        line:     line style                (default = 1 (solid))
        width:    line width                (default = 1 (thin))
        color:    line and/or symbol color  (default = 'white')
        font:     PGPLOT font to use        (default = 1 (normal))
        fontsize: PGPLOT font size to use   (default = 1.0 (normal))
        id:       show ID line on plot      (default = 0 (no)) 
        aspect:   aspect ratio              (default = 0.7727 (rect))
        ticks:    Ticks point in or out     (default = 'in')   
        panels:   Number of subpanels [r,c] (default = [1,1])
        device:   PGPLOT device to use      (default = '/XWIN')
        setup:    Auto-setup the plot       (default = 1)
    Note:  Many default values are defined in global variables
        with names like ppgplot_font_ or ppgplot_device_.

### Function `plot2d`

plot2d(z, ...)
    An interface to make various 2D plots using PGPLOT.
        'z' is the 2D Numpy array to be plotted.
    The optional entries are:
        x:         x values                    (default = 0, 1, ...) 
        y:         y values                    (default = 0, 1, ...) 
        title:     graph title                 (default = None)      
        rangex:    range for the x-axis        (default = automatic) 
        rangey:    range for the y-axis        (default = automatic) 
        rangez:    range for the z-axis        (default = automatic) 
        labx:      label for the x-axis        (default = None)      
        laby:      label for the y-axis        (default = None)      
        rangex2:   range for 2nd x-axis        (default = None)      
        rangey2:   range for 2nd y-axis        (default = None)      
        labx2:     label for the 2nd x-axis    (default = None)      
        laby2:     label for the 2nd y-axis    (default = None)      
        logx:      make the 1st x-axis log     (default = 0 (no))
        logy:      make the 1st y-axis log     (default = 0 (no))
        logx2:     make the 2nd x-axis log     (default = 0 (no))
        logy2:     make the 2nd y-axis log     (default = 0 (no))
        image:     color palette for image     (default = 'rainbow') 
        contours:  list of contour values      (default = None)      
        line:      contour line style          (default = 1 (solid)) 
        width:     contour line width          (default = 1 (thin))  
        color:     contour line color          (default = 'white')   
        labels:    color of contour labels     (default = None)      
        labelint:  contour label spacing       (default = 20)        
        labelmin:  min contour label spacing   (default = 20)        
        font:      PGPLOT font to use          (default = 1 (normal))
        fontsize:  PGPLOT font size to use     (default = 1.0 (normal))
        id:        show ID line on plot        (default = 0 (no))    
        noscale:   turn off auto scaling       (default = 0 (no))    
        aspect:    Aspect ratio                (default = 1 (square))
        ticks:     Ticks point in or out       (default = 'out')   
        panels:    Number of subpanels [r,c]   (default = [1,1])
        device:    PGPLOT device to use        (default = '/XWIN')   
    Note:  Many default values are defined in global variables
        with names like ppgplot_font_ or ppgplot_device_.

### Function `setpalette`

setpalette(self, palette):
    Set the color palette for imag-style routines

### Function `distance`

distance(width):
    Return a 'width' x 'width' Numpy array with each
        point set to the geometric distance from the array's center.


---

# __init__.md

### Function `val_with_err`

val_with_err(value, error, length=0, digits=2):
    Returns a string of length length (auto if 0) with 'value'
        rounded to the appropriate decimal place and the
        'error' in parenthesis as in scientific journals.
        The error has 'digits' decimal places.    
    Notes:
       'length' should be ~20 to show full double precision          
            if the base 10 exponent of the error needs to be shown.       
        If length == 0, left-justified minimum length string is returned.
        If length > 0, the string returned is right justified.       
        If length < 0, the string returned is left justified.       
        If latex=1, the string is converted into LaTeX markup.

### Function `read_inffile`

read_inffile(filename, verbose=True):
    Return an infodata 'C' structure containing the data from the
       'inf' file in 'filename'.

### Function `write_inffile`

wite_inffile(infodata, verbose=True):
    Write an '.inf' file based on its input structure

### Function `psrepoch`

psrepoch(psrname or parname, epoch):
    Return a psrparams 'C' structure which includes data for
        PSR 'psrname' (a string of the B1950 or J2000 name of the
        pulsar -- without PSR, J, or B included) at epoch 'epoch'
        (in MJD format) from the ATNF database, or, a parfile is
        passed, read the pulsar information from it instead.

### Function `read_rzwcands`

read_rzwcands(filename):
    Return a list of all of the rzw search candidates from
    the file 'filename'.

### Function `read_rawbincands`

read_rawbincands(filename):
    Return a list of all of the raw binary search candidates
        from the file 'filename'.

### Function `next2_to_n`

next2_to_n(x):
    Return the first value of 2^n >= x.

### Function `rfft`

rfft(data, sign=-1):
    Return the FFT of the real-valued, 32-bit floating point 'data'
    Note:  This only returns the positive frequency half of the FFT,
        since the other half is symmetric.  The Nyquist frequency
        is stored in the complex part of frequency 0 as per
        Numerical Recipes.
    The optional value 'sign' should be -1 (forward) or +1 (inverse).

### Function `spectralpower`

spectralpower(fftarray):
    Return the power spectrum of a complex FFT 'fftarray'.

### Function `spectralphase`

spectralphase(fftarray):
    Return the spectral phase (deg) of a complex FFT 'fftarray'.

### Function `rzw_response`

rzw_response(roffset, z, w, numbetween=1, numkern=None):
    Return the response of a signal offset from a Fourier bin
        by roffset bins, with a Fourier f-dot of z, and a
        Fourier f-dotdot of w.  The Fourier interpolation
        factor is the integer numbetween, and the the length
        of the resulting kernel will be auto-determined if
        numkern is None.

### Function `maximize_r`

maximize_r(data, r, norm = None):
    Optimize the detection of a signal at Fourier frequency 'r' in
        a FFT 'data'.  The routine returns a list containing
        the optimized values of the maximum normalized power, rmax,
        and an rderivs structure for the peak.

### Function `maximize_rz`

maximize_rz(data, r, z, norm = None):
    Optimize the detection of a signal at location 'r', 'z' in
        the F-Fdot plane.  The routine returns a list containing
        the optimized values of the maximum normalized power, rmax,
        zmax, and an rderivs structure for the peak.

### Function `maximize_rz_harmonics`

maximize_rz_harmonics(data, r, z, numharm, norm = None):
    Optimize the detection of a signal at location 'r', 'z' in
        the F-Fdot plane, including harmonic summing of the harmonics.
        The routine returns a list containing the optimized values of 
        the maximum normalized power, rmax, zmax, and a list of 
        rderivs structures for the peak.

### Function `maximize_rzw`

maximize_rzw(data, r, z, w, norm = None):
    Optimize the detection of a signal at location 'r', 'z', 'w' in
        the F-Fdot-Fdotdot plane.  The routine returns a list containing
        the optimized values of the maximum normalized power, rmax,
        zmax, wmax, and an rderivs structure for the peak.

### Function `maximize_rzw_harmonics`

maximize_rzw_harmonics(data, r, z, w, numharm, norm = None):
    Optimize the detection of a signal at location 'r', 'z', 'w' in
        the F-Fd-Fdd volume, including harmonic summing of the harmonics.
        The routine returns a list containing the optimized values of 
        the maximum normalized power, rmax, zmax, wmax, and a list of 
        rderivs structures for the peak.

### Function `search_fft`

search_fft(data, numcands):
    Search a short FFT and return a list containing the powers and
    Fourier frequencies of the 'numcands' highest candidates in 'data'.
    'norm' is the value to multiply each pow power by to get
         a normalized power spectrum (defaults to  1.0/(Freq 0) value)

### Function `ffdot_plane`

ffdot_plane(data, lor, dr, numr, loz, dz, numz):
     Generate an F-Fdot plane with the 'lower-left' corners
     at the point 'lor', 'loz'.  The plane will have 'numr' frequency
     bins and 'numz' slices in the fdot direction, separated by 'dr'
     and 'dz' respectively.  'lor', 'numr', and 'numz' should all be
     integers.  'data' is the input FFT.
     Note:  'dr' much be the reciprocal of an integer
          (i.e. 1 / numbetween).  Also, 'r' is considered to be
          the average frequency (r = ro + z / 2).

### Function `fdotdot_vol`

fdotdot_vol(data, lor, dr, numr, loz, dz, numz, low, dw, numw):
     Generate an F-Fdot-Fdotdot volume with the 'lower-left' corners
     at the point 'lor', 'loz', 'low'.  The vol will have 'numr' frequency
     bins, 'numz'/'numw' slices in the fdot/fdotdot direction, separated 
     by 'dr', 'dz', and 'dw' respectively.  'lor', 'numr', 'numz', and 
     'numw' should all be integers.  'data' is the input FFT.
     Note:  'dr' much be the reciprocal of an integer
          (i.e. 1 / numbetween).  Also, 'r' is considered to be
          the average frequency (r = r0 + w/6 + z0/2), and 'z'
          is the average fdot (z = z0 + w / 2).

### Function `estimate_rz`

estimate_rz(psr, T, show=0, device='/XWIN'):
    Return estimates of a pulsar's average Fourier freq ('r')
    relative to its nominal Fourier freq as well as its
    Fourier f-dot ('z') in bins, of a pulsar.
       'psr' is a psrparams structure describing the pulsar.
       'T' is the length of the observation in sec.
       'show' if true, displays plots of 'r' and 'z'.
       'device' if the device to plot to if 'show' is true.

### Function `alias`

alias_to_r(r, rny):
    Convert an aliased Fourier frequency into the 'true' Fourier
    frequency of a signal.  Or vise-versa -- the transformation is
    symmetric about the Nyquist Freq.
       'r' is the signal's Fourier frequency to convert.
       'rny' is the Nyquist frequency (in bins).  For an FFT
          of real data, 'rny' = number of data points FFT'd / 2.

### Function `show_ffdot_plane`

show_ffdot_plane(data, r, z):
    Show a color plot of the F-Fdot plane centered on the point 'r', 'z'.

### Function `v_from_e`

v_from_e(e, psr):
    Return a vector of velocities (km/s) from a vector of Eccentric
    anomalys.
        'e' is the vector of Eccentric anomalys.
        'psr' is a psrparams instance containing info about the pulsar.

### Function `d_from_e`

d_from_e(e, psr):
    Return a vector of time delays (s) from a vector of Eccentric
    anomalys.
        'e' is the vector of Eccentric anomalys.
        'psr' is a psrparams instance containing info about the pulsar.

### Function `p_from_e`

p_from_e(e, psr):
    Return a vector of pulsar periods (s) from a vector of Eccentric
    anomalys.
        'e' is the vector of Eccentric anomalys.
        'psr' is a psrparams instance containing info about the pulsar.

### Function `z_from_e`

z_from_e(e, psr):
    Return a vector of Fourier F-dots (bins) from a vector of Eccentric
    anomalys.
        'e' is the vector of Eccentric anomalys.
        'psr' is a psrparams instance containing info about the pulsar.
        'T' is the total length of the observation (s).

### Function `pcorr`

pcorr(data, kernel, numbetween, lo, hi):
    Perform a correlation with the raw complex vectors 'data' and
    'kernel'.  The returned vector should start at frequency
    'lo' (must be an integer), and go up to but not include 'hi'
    (also an integer).

### Function `p_to_f`

p_to_f(p, pd, pdd):
   Convert period, period derivative and period second
   derivative to the equivalent frequency counterparts.
   Will also convert from f to p.

### Function `bary_to_topo`

bary_to_topo(pb, pbd, pbdd, infofilenm, ephem="DE200"):
   Use least squares to calculate topocentric period
   period derivative, and period second derivative
   for the corresponding barycentric values.  The data
   for the observation must be found in the info file.

### Function `measure_phase`

measure_phase(profile, template, sigma, fwhm):
   TOA measurement technique from J. H. Taylor's talk
   _Pulsar_Timing_and_Relativistic_Gravity_.  Routine
   takes two profiles, the first measured and the
   second a high S/N template and determines the phase
   offset of 'profile' from 'template'.  Both profiles
   must have the same number of points.  'sigma' denotes
   the RMS noise level of the 'profile'.  'fwhm' is the
   approximate width of the template pulse (0-1).  The phase
   returned is cyclic (i.e. from 0-1).  The routine
   returns a tuple comtaining (tau, tau_err, b, b_err, a).
   Where 'tau' is the phase, 'B' is the scaling factor,
   and 'a' is the DC offset.  The error values are
   estimates of the 1 sigma errors.

### Function `get_baryv`

get_baryv(ra, dec, mjd, T, obs="PK"):
  Determine the average barycentric velocity towards 'ra', 'dec'
  during an observation from 'obs'.  The RA and DEC are in the
  standard string format (i.e. 'hh:mm:ss.ssss' and 'dd:mm:ss.ssss').
  'T' is in sec and 'mjd' is (of course) in MJD.  The obs variable
  is the standard two character string from TEMPO:  PK, GB, AO, GM, JB, ...

### Function `fold`

fold(indata, dt, nbins, f, fd=0.0, fdd=0.0, startphs=0.0, tlo=0.0):
  This is an interface into PRESTO's fold() code, which is what
  prepfold uses to fold data.  It will return a tuple of a
  double-precision profile of length nbins, and the ending phase
  (0-1) of the fold.
    indata is an array of floats to fold
    dt is the duration in sec of each of the indata bins
    f, fd, and fdd are the freq, freq deriv, and freq 2nd deriv to fold (Hz)
    startphs (0-1) is the phase for the beginning of the first bin
    tlo is the time (in sec) referring to the start of the first bin,
      with respect to the reference time of f, fd, and fdd (i.e. tlo=0.0).
    If standard (bool), then traditional prepfold "drizzling" will be
      used.  Otherwise, treat each input data point as a sample and put
      it fully in a single profile bin.

### Function `compute_chi2`

Compute chi^2 as a pulsation test for a folded pulse profile 'data'

To get the reduced-chi^2, you would typically divide the result by
the number of profile bins minus 1 (but beware of prepfold's inter-bin
correlations!  See DOF_corr() in prepfold.py for details.)

See Leahy et al. 1983 for details:
https://ui.adsabs.harvard.edu/abs/1983ApJ...266..160L/abstract

Parameters
----------
data : [double precision numpy array]
    A folded pulse profile on which to compute Z^2_N
avg : [double]
    The average level of the data (should be the background average).
var : [double]
    The variance of the data (should be the background variance).
    Beware prepfold's bin correlations!

### Function `compute_Z2N`

Compute Z^2_N statistic for a folded pulse profile 'data'

See Bachetti et al. 2021 for details:
https://ui.adsabs.harvard.edu/abs/2021ApJ...909...33B/abstract

Parameters
----------
data : [double precision numpy array]
    A folded pulse profile on which to compute Z^2_N
N : [integer]
    The number of harmonics to include in the Z^2_N calculation
var : [double]
    The variance of the data (should be the background variance).
    Beware prepfold's bin correlations!


---

# bary_and_topo.md

# Module docstring

Original code found in presto. Written by Scott M. Ransom.
Modified by Chitrang Patel to read information from PSRFITs file.
Modified to return topocentric and corresponding barycentric
times. 

### Function `read_inffile`

read_inffile(filename):
    Return an infodata 'C' structure containing the data from the
    'inf' file in 'filename'.  'filename' should not include the
    '.inf' suffix.

### Function `bary_to_topo`

bary_to_topo(infofilenm, ephem="DE200"):
   Returns the barycentric and topocentric times evert 10 seconds.
   The data for the observation must be found in the info file.


---

# barycenter.md

### Function `convert_angle`

convert_angle(inval, flag=1):
    Converts a coded double to an angle based on the optional 'flag'
    'flag' = 1:  Input form = ddmmss.ss, Output in radians (default)
    'flag' = 2:  Input form = ddmmss.ss, Output in frac of 2pi
    'flag' = 3:  Input form = hhmmss.ss, Output in radians
    'flag' = 4:  Input form = hhmmss.ss, Output in frac of 2pi

### Function `hms2hours`

hms2hours(hms):
    Converts an angle 'hms' expressed as hhmmss.ss into
    fractional hours.

### Function `dms2deg`

dms2deg(dms):
    Converts an angle 'dms' expressed as ddmmss.ss into
    fractional degrees.

### Function `rad2dms`

rad2dms(rad):
    Convert 'rad' radians into dd:mm:ss.sss format.

### Function `rad2hms`

rad2hms(rad):
    Convert 'rad' radians into hh:mm:ss.sss format.

### Function `geodetic2geocentcyl`

geodetic2geocentcyl(lat, lon, elev):
    Return a list containing the Geocentric Cylindrical coords.
        'lat' is Geodetic latitude in degrees (ddmmss.ss)
        'long' is Geodetic west longitude in degrees (ddmmss.ss)
        'elev' is meters above mean sea level

### Function `xyz2geocentcyl`

xyz2geocentcyl(x, y, z):
    Return a list containing the Geocentric Cylindrical coords.
        'x', 'y', and 'z' are referenced to the Geocenter in m.

### Function `obs_coords`

obs_coords(observ):
    Return a list containing the Geocentric Cylindrical Coords for
    an observatory found in the TEMPO 'obsys.dat'.
        'observ' is the two letter observatory code
            from 'obsys.dat' (i.e. 'PK' = Parkes)

### Function `precess_J2000_to_B1950`

precess_J2000_to_B1950(ra, dec, rapm, decpm, par, vel): 
    Precess a set of J2000.0 FK5 coords to epoch B1950.0 FK4.
    Return a list containing the B1950 version of the arguments.
        'ra' is the J2000 right ascension (hhmmss.ssss)
        'dec' is the J2000 declination (ddmmss.ssss)
        'rapm' is the J2000 RA proper motion in rad/Julian Year (0.0)
        'decpm' is the J2000 DEC proper motion in rad/Julian Year (0.0)
        'par' is the parallax in arcsec (0.0)
        'vel' is the radial velocity in km/s (+ = away from us) (0.0)
    Note: Parenthesized values at the ends of the above lines are the
          default values.

### Function `TAI_minus_UTC`

TAI_minus_UTC(mjd):
    Return the difference between TAI (International Atomic Time)
    and UTC in seconds at a specified MJD.
        'mjd' is the Modified Julian Date UTC

### Function `TT_minus_UTC`

TT_minus_UTC(mjd):
    Return the difference between TT (Terrestrial Dynamic Time)
    and UTC in seconds at a specified MJD.  TT used to be called
    ET (Ephemeris Time).
        'mjd' is the Modified Julian Date UTC

### Function `TDB_minus_UTC`

TDB_minus_UTC(mjd):
    Return the difference between TDB (Barycentric Dynamic Time)
    and UTC in seconds at a specified MJD.
        'mjd' is the Modified Julian Date UTC


---

# binary_psr.md

### Function `shapR`

shapR(m2):
    Return the Shapiro 'R' parameter (in sec) with m2 in
        solar units.

### Function `shapS`

shapS(m1, m2, x, pb):
    Return the Shapiro 'S' parameter with m1 and m2 in
        solar units, x (asini/c) in sec, and pb in days.
        The Shapiro S param is also equal to sin(i).

## Class `binary_psr`

class binary_psr

    This class reads in a parfile (the only option for instantiation) of
        a binary pulsar.  It allows access the calculation of the mean,
        eccentric, and true anomalies, orbital position, radial velocity,
        and predicted spin period as a function of time.
        

### Function `calc_anoms`

calc_anoms(MJD):
    Return a tuple of the mean, eccentric, and true anomalies (all
        in radians) at the barycentric epoch MJD(s).

### Function `most_recent_peri`

most_recent_peri(MJD):
    Return the MJD(s) of the most recent periastrons that occurred
        before the input MJD(s).

### Function `eccentric_anomaly`

eccentric_anomaly(mean_anomaly):
    Return the eccentric anomaly in radians, given a set of mean_anomalies
        in radians.

### Function `calc_omega`

calc_omega(MJD):
    Return the argument of periastron (omega in radians) at
    time (or times) MJD(s).

### Function `radial_velocity`

radial_velocity(MJD):
    Return the radial velocity of the pulsar (km/s) at the given MJD(s).

### Function `doppler_period`

doppler_period(MJD):
    Return the observed pulse spin period in sec at the given MJD(s).

### Function `position`

position(MJD, inc=60.0, returnz=False):
    Return the 'x' (along the LOS with + being towards us) and 'y' (in the
        plane of the sky with + being away from the line of nodes and -
        being in the direction of the line of nodes) positions of the
        pulsar with respect to the center of mass in units of lt-sec.
        (Note:  This places the observer at (+inf,0.0) and the line of nodes
        extending towards (0.0,-inf) with the pulsar orbiting (0.0,0.0)
        clockwise).  'inc' is the inclination of the orbit in degrees.
        MJD can be an array.  The return value is (xs, ys).  If returnz
        is True, return (xs, ys, zs), where 'z' is the other in-the-sky
        direction.  These coordinates correspond to the I, J, and K vectors
        in Damour & Taylor (1992) in the following way:
        x = -K
        y = -I
        z = -J

### Function `reflex_motion`

reflex_motion(MJD, inc, Omega, dist):
    Return the projected on-sky orbital reflex motion in mas referenced
        to Omega, which is the line-of-nodes, clockwise from East towards
        North.  This is the definition of Omega used by e.g. Damour & 
        Taylor (1992) and Kopeikin (1996), but note that it differs from
        most non-pulsar applications (in which Omega is measured counter-
        clockwise from North to East). The distance to the pulsar is in 
        kpc. The returned values are dRA (corrected by cos(dec)), dDEC.

### Function `demodulate_TOAs`

demodulate_TOAs(MJD):
    Return arrival times correctly orbitally de-modulated using
        the iterative procedure described in Deeter, Boynton, and Pravdo
        (1981ApJ...247.1003D, thanks, Deepto!).  This corrects for the
        fact that the emitted times are what you want when you only
        have the arrival times.  MJD can be an array.  The returned
        values are in MJD as well.

### Function `shapiro_delays`

shapiro_delays(R, S, MJD):
    Return the predicted Shapiro delay (in us) for a variety of
        barycentric MJDs, given the R and S parameters.

### Function `shapiro_measurable`

shapiro_measurable(R, S, MJD):
    Return the predicted _measurable_ Shapiro delay (in us) for a
        variety of barycentric MJDs, given the R and S parameters.  
        This is eqn 28 in Freire & Wex 2010 and is only valid in 
        the low eccentricity limit.


---

# bindata.md

### Function `help`

help(funct):
Print the documentation string of a function or method.


---

# cosine_rand.md

### Function `cosine_rand`

cosine_rand(num):  Return num phases that are randomly distributed
as per a sinusoid with maximum at phase=0 (0 < phase < 1).


---

# events.md

### Function `sine_events`

sine_events(pulsed_frac, Nevents, phase=0.0):
   Return an array of 'Nevents' of phase values [0,1)
   simulating a folded profile with a pulsed fraction
   'pulsed_frac', a phase offset 'phase', and with a
   sinusoidal pulse profile.

### Function `gaussian_events`

gaussian_events(pulsed_frac, Nevents, phase=0.0):
   Return an array of 'Nevents' of phase values [0,1)
   simulating a folded profile with a pulsed fraction
   'pulsed_frac', a phase offset 'phase', and with a
   gaussian pulse profile of width 'fwhm'

### Function `harm_to_sum`

harm_to_sum(fwhm):
   For an MVMD profile of width 'fwhm', returns the
   optimal number of harmonics to sum incoherently

### Function `DFTexact`

DFTexact(times, f, maxnumharms=20):
   Return an array of 'maxnumharms' complex amplitudes
   corresponding to the harmonics of the 'times' (in sec)
   with a fundamental at frequency 'f' Hz.

### Function `incoherent_sum`

incoherent_sum(amps):
   Return the incoherent sum of an array of complex Fourier
   amplitudes.  Usually these correspond to the complex
   harmonics of a periodic signal.

### Function `coherent_sum`

coherent_sum(amps):
   Return the coherent sum (i.e. including phase information)
   of an array of complex Fourier amplitudes.  Usually these
   correspond to the complex harmonics of a periodic signal.

### Function `Htest_exact`

Htest_exact(phases, maxnumharms=20, weights=None):
   Return an exactly computed (i.e. unbinned) H-test statistic
   for periodicity for the events with folded phases 'phases' [0,1).
   Also return the best number of harmonics.  The H-statistic and
   harmonic number are returned as a tuple: (hstat, harmnum).
   This routine returns the Leahy normalized H-statistic, and the
   best number of harmonics summed.  If weights are set to be
   fractional photon weights, then the weighted Htest is returned
   (see Kerr 2011: http://arxiv.org/pdf/1103.2128.pdf)

### Function `Hstat_prob`

Hstat_prob(h):
   Return the probability associated with an H-test statistic
   of value 'h'.  Uses de Jager & Busching 2010 result.

### Function `gauss_sigma_to_prob`

gauss_sigma_to_prob(sigma):
    Returns the area under the Gaussian probability density
    function, integrated from 'sigma' to infinity.

### Function `prob_to_gauss_sigma`

prob_to_gauss_sigma(prob):
    Returns the Gaussian sigma for which the area under the
    Gaussian probability density function (integrated from minus
    infinity to 'sigma') is equal to 'prob'.

### Function `xray_time_to_detect`

xray_time_to_detect(ctrate, pfract, dt, fpsr, bins=0, confidence=0.99,
                    detectfract=0.99):
    Return the observation duration required (assuming no breaks
    and a sinusoidal pulse profile) to detect pulsations at
    frequency 'fpsr' while looking in a number of Fourier
    bins equal to 'bins' (Note: the default value of 0 means
    that all bins will be examined).  'dt' is the bin duration in
    sec, 'ctrate' is the total expected count rate, and 'pfract' is
    the expected pulsed fraction.  'confidence' is the confidence
    level that the signal is not caused by noise, and 'detectfract'
    is the fraction of the time that you want this observation to
    occur (i.e. if set to 0.5, 50% of observations of this duration
    would detect the specified signal at 'confidence' level).

### Function `power_average`

power_average(signal_power, n=1):
    Return the expectation value of the measured power given
    a signal with intrinsic power 'signal_power' and 'n'
    summed powers.  This is from equation 14 in Groth, 1975.

### Function `power_variance`

power_variance(signal_power, n=1):
    Return the variance of the measured power given a signal
    with intrinsic power 'signal_power' and 'n' summed
    powers.  This is from equation 14 in Groth, 1975.

### Function `power_sigma`

power_sigma(signal_power, n=1):
    Return the standard deviation of the measured power
    given a signal with intrinsic power 'signal_power' and
    'n' summed powers.  This is from equation 14 in Groth, 1975.

### Function `log_fact_table`

log_fact_table(maxn):
    Return a table of the natural logarithms of the
    first 'maxn'+1 factorials.

### Function `binning_factor`

binning_factor(freq, nyquist_freq):
    Return the factor that causes high frequency Fourier
    Amplitudes to be decreased if the time series is
    made of binned events.  Square this for a power
    spectrum adjustment.  'freq' is the frequency of
    interest and 'nyquist_freq' is the Nyquist Frequency
    which can be defined as N/(2*T).

### Function `max_noise_power`

max_noise_power(bins, n=1, confidence=0.99):
    Return the power level that gives you some
    'confidence' that spectral noise could not cause
    that level in your power spectrum.  The total number
    of independent frequencies searched is 'bins'.
    This is P_detect in Vaughan et. al, 1994, and is also
    known as P_threshold.

### Function `prob_power_series`

prob_power_series(power, signal_power, n=1, TOL=1.0e-14):
    Return the integrated probability from P=0 to 'power'
    that a signal with theoretical power 'signal_power'
    will show up in a power spectrum with power 'power'.
    This method evaluates the integral using an infinite
    sum and is equation 16 in Groth, 1975.

### Function `prob_power_integral`

prob_power_integral(power, signal_power, n=1):
    Return the integrated probability from P=0 to 'power'
    that a signal with theoretical power 'signal_power'
    will show up in a power spectrum with power 'power'.
    This method evaluates the integral numerically and
    is equation 18 in Groth, 1975.

### Function `power_probability`

power_probability(power, signal_power, n=1):
    Return the probability of a signal with power
    'signal_power' actually showing up with power
    'power' in a power spectrum'  This is equation
    12 in Groth, 1975 and is the integrand of the
    prob_power_* functions (which integrate it from 0 to P)

### Function `required_signal_power`

required_signal_power(power, n=1, confidence=0.99):
    Return the required power of a signal that will cause
    at least a power 'power' in a power spectrum a fraction
    'confidence' of the time.  This is the inverse of
    equation 16 in Groth, 1975, with solves for P_signal.
    If called with 'power' = P_detect the result is
    the search sensitivity.  If called with 'power' = P_max,
    then the result is the upper limit on the signal power
    in the power spectrum.

### Function `fft_sensitivity`

fft_sensitivity(N, bins=0, n=1, confidence=0.99):
    Return a measure of the weakest signal power you can
    confidently detect in an FFT search containing 'N' data
    points (this is the number of bins in the time series -- the
    number of Frequency bins searched is usually N/2).  'bins' is
    only different from 0 if the number of independent frequencies
    searched does not equal N/2 (i.e. when an acceleration search
    is performed).  'confidence' is our fractional confidence in
    the result (i.e. 0.99 = 99% limit).  This calculation does not
    include the correction to sensitivity due to binning effects.
    These calculations are based on the Vaughan et al 1994 paper
    and compute P_sens.

### Function `rzw_sensitivity`

rzw_sensitivity(N, zlo=-100.0, zhi=100.0, n=1, confidence=0.99):
    Return a measure of the weakest signal power you can
    confidently detect in an RZW (Fourier acceleration) search
    containing 'N' data points (this is the number of bins in the
    time series) and low and high acceleration values of 'zlo'
    and 'zhi'.  'confidence' is our fractional confidence in
    the result (i.e. 0.99 = 99% limit).  This calculation does not
    include the correction to sensitivity due to binning effects.
    These calculations are based on the Vaughan et al 1994 paper
    and compute P_sens.

### Function `binned_fft_sensitivity`

binned_fft_sensitivity(N, dt, freq, bins=0, n=1, confidence=0.99):
    Return a measure of the weakest signal power of frequency 'freq'
    Hz you can confidently detect in an FFT search containing 'N'
    data points (this is the number of bins in the time series --
    the number of Frequency bins searched is usually 1/2 of this
    value) each of which was binned into 'dt' sec bins.
    'bins' is only different from 0 if the number of independent
    frequencies searched does not equal N/2 (i.e. when an
    acceleration search is performed).  'confidence' is our
    fractional confidence in the result (i.e. 0.99 = 99% limit).
    This calculation includes the correction to sensitivity
    due to binning effects.  These calculations are based on
    the Vaughan et al 1994 paper and compute P_sens.

### Function `binned_rzw_sensitivity`

binned_rzw_sensitivity(N, dt, freq, zlo=-100.0, zhi=100.0,
                       n=1, confidence=0.99):
    Return a measure of the weakest signal power of frequency 'freq'
    Hz you can confidently detect in an RZW (Fourier acceleration)
    search containing 'N' data points (this is the number of bins in
    the time series) each of which was binned into 'dt' sec bins.
    Low and high acceleration values of 'zlo' and 'zhi' were used.
    'confidence' is our fractional confidence in the result (i.e.
    0.99 = 99% limit).  This calculation includes the correction to
    sensitivity due to binning effects.  These calculations are
    based on the Vaughan et al 1994 paper and compute P_sens.

### Function `pulsed_fraction_limit`

pulsed_fraction_limit(phot, Pow):
    Return an _observational_ (i.e. not intrinsic) upper limit
    to the pulsed fraction of a signal that is in the data but
    was not detected.  By observational, I mean that some of the
    unpulsed events do not come from the source you are looking
    for pulsations in.  The data contain a total of 'Nphot'
    photons and the largest measured power (or P_sens as
    calculated using the *_sensitivity functions in this module)
    is 'Pow'.  If you want the _intrinsic_ pulsed fraction,
    you should divide the returned value by the fraction of Nphot
    that actually comes from the _source_ (i.e. the NS).


---

# fb_truncate.md

# Module docstring

A script to truncate a filterbank file in time/frequency.

Patrick Lazarus, Aug 27, 2012


---

# filterbank.md

# Module docstring

A module for reading filterbank files.

Patrick Lazarus, June 26, 2012
(Minor modification from file originally from June 6th, 2009)

### Function `create_filterbank_file`

Write filterbank header and spectra to file.

Input:
    outfn: The outfile filterbank file's name.
    header: A dictionary of header paramters and values.
    spectra: Spectra to write to file. (Default: don't write
        any spectra - i.e. write out header only)
    nbits: The number of bits per sample of the filterbank file.
        This value always overrides the value in the header dictionary.
        (Default: 8 - i.e. each sample is an 8-bit integer)
    verbose: If True, be verbose (Default: be quiet)
    mode: Mode for writing (can be 'append' or 'write')

Output:
    fbfile: The resulting FilterbankFile object opened
        in read-write mode.

### Function `is_float`

For a given number of bits per sample return
true if it corresponds to floating-point samples
in filterbank files.

Input:
    nbits: Number of bits per sample, as recorded in the filterbank
        file's header.

Output:
    isfloat: True, if 'nbits' indicates the data in the file
        are encoded as floats.

### Function `check_nbits`

Given a number of bits per sample check to make
sure 'filterbank.py' can cope with it.

An exception is raise if 'filterbank.py' cannot cope.

Input:
    nbits: Number of bits per sample, as recorded in the filterbank
        file's header.

Output:
    None

### Function `get_dtype`

For a given number of bits per sample return
a numpy-recognized dtype.

Input:
    nbits: Number of bits per sample, as recorded in the filterbank
        file's header.

Output:
    dtype: A numpy-recognized dtype string.

### Function `read_header`

Read the header of a filterbank file, and return
a dictionary of header paramters and the header's
size in bytes.

Inputs:
    filename: Name of the filterbank file.
    verbose: If True, be verbose. (Default: be quiet)

Outputs:
    header: A dictionary of header paramters.
    header_size: The size of the header in bytes.

### Function `append_spectra`

Append spectra to the file if is not read-only.

Input:
    spectra: The spectra to append. The new spectra
        must have the correct number of channels (ie
        dimension of axis=1.

Outputs:
    None

### Function `write_spectra`

Write spectra to the file if is writable.

Input:
    spectra: The spectra to append. The new spectra
        must have the correct number of channels (ie
        dimension of axis=1.
    ispec: The index of the spectrum of where to start writing.

Outputs:
    None

### Function `print_header`

Print header parameters and values.
        


---

# fitorb.md

# Module docstring

fitorb: A non-linear optimizer for solving pulsar orbits by Ryan Lynch

### Function `parse_cmd_line`

Parse command line argumentss

Input
-----
   args - a list of command line aruments and values
   
Output
------
   user-supplied values for the given arguments

### Function `read_bestprof`

Read relevant information from prepfold .bestprof files (written by
Scott Ransom

Input
-----
    file_name - string containing the path to a .bestprof file

Output
------
    epoch - the barycentric epoch (MJD) of the observation
    N*dt - length of observation (number of data points * sampling time)
    p0,p1,p2 - observed spin period and higher-order period derivatives

### Function `get_params_info`

Build a list of dictionaries with information about spin and orbital
parameters to be passed to mpfit

Input
-----
    params_start - a list of initial guesses for parameter values
    const_params - a string containing the parameters to hold constant
        during fit

Output
------
    params_info - a list of dictionaries with information on each
        parameter

### Function `myasarray`

Properly format array (written by Scott Ransom)

Input
-----
    a - python array

Output
------
    a - modified python array

### Function `calc_omega`

Calculate w in at the barycentric epoch MJD (written by Scott Ransom)

Input
-----
    params - a list of parameter values
    MJD - barycentric epoch MJD

Output
------
    w in radians

### Function `eccentric_anomaly`

Calculate the eccentric anomaly using a simplte iteration to solve
Kepler's Equations (written by Scott Ransom)

Input
-----
    params - a list of parameter values
    mean_anomaly - the mean anomaly

Output
------
    the eccentric anomaly in radians

### Function `calc_anoms`

Calculate the mean, eccentric, and true anomalies at the barycentric
epoch MJD (written by Scott Ransom)

Input
-----
    params - a list of parameter values
    MJD - the barycentric epoch MJD

Output
------
    mean_anom - mean anomaly in radians
    ecc_anom - eccentric enomaly in radians
    true_anom - the true anomaly in radians

### Function `radial_velocity`

Calculate the radial velocity of the pulsar at the given MJD
(written by Scott Ransom)

Input
-----
    params - a list of parameter values
    MJD - the barycentric epoch MJD

Output
------
    the radial velocity in km/s

### Function `doppler_period`

Calculate the doppler modulated pulse period (written by Scott Ransom)

Input
-----
    params - list of parameter values
    MJD - barycentric epoch MJD

Output
------
    observed pulse period in seconds

### Function `funct`

Calculate the difference between the modeled and observed period

Input
-----
    params - list of parameter values
    fjac - function for calculating the Jacobian (if None mpfit
           will use a default method)
    times - array of MJDs when period observations were made
    measured - array of observed periods (in seconds)

Output
------
    a list containing the exit status (used by mpfit) and the
    differences between the model and data


---

# fourier_fold.md

### Function `get_fourier_prof`

Generate a pulse profile from the Fourier amplitudes in a .fft file

Parameters
----------
fft : Numpy array of type complex64 which contains FFT amplitudes
rr : Fractional Fourier bin number for the fundamental frequency
zz : Fractional Fourier f-dot for fundamental (defaults to 0.0)
Nbins : The number of bins to use in the pulse profile. By default None,
        which means that you will get the number corresponding to the
        number of harmonics that fits within the Nyquist frequency, and
        then rounded up to the nearest power-of-two.

Returns
-------
A numpy float array containing the pulse profile.

### Function `estimate_profile_variance`

Estimate the variance of a pulse profile based on the FFT harmonics

Parameters
----------
fft : Numpy array of type complex64 which contains FFT amplitudes
rr : Fractional Fourier bin number for the fundamental frequency
Nbins : The number of bins to use in the pulse profile. By default None,
        which means that you will get the number corresponding to the
        number of harmonics that fits within the Nyquist frequency, and
        then rounded up to the nearest power-of-two.
Ntrials : int, optional. The number of random nearby frequencies to use
        to statistically compute the variance. By default 20.

Returns
-------
A float estimate of the off-pulse profile variance.

### Function `optimize_freq`

Optimize the frequency of a periodic signal in an FFT

Parameters
----------
fft : Numpy array of type complex64 which contains FFT amplitudes
rr : Fractional Fourier bin number for the fundamental frequency
var : The float variance of the profile
Nbins : The number of bins to use in the pulse profile. By default None,
        which means that you will get the number corresponding to the
        number of harmonics that fits within the Nyquist frequency, and
        then rounded up to the nearest power-of-two.
dr : float, optional (by default 0.01). The Fourier frequency step-size
        over which to search.
maxoff : float, optional (by default 1.0). The maximum Fourier frequency
        deviation from rr over which to search.

Returns
-------
A tuple of an array of reduced chi^2 values of the profiles, and a float
of the highest significance Fourier frequency of the pulsations.

### Function `profile_for_plot`

Return a centered and doubled pulse profile


---

# get_TOAs.md

### Function `measure_phase`

measure_phase(profile, template):
    Call FFTFIT on the profile and template to determine the
        following parameters: shift,eshift,snr,esnr,b,errb,ngood
        (returned as a tuple).  These are defined as in Taylor's
        talk at the Royal Society.


---

# guppidrift2fil.md

### Function `read_4bit`

Unpack 4-bit PSRFITS data that has been read in as bytes
 by pyfits.

     Input: array of unsigned 8-bit ints
     Output: unpacked array

### Function `read_subint`

Read a 4-bitized PSRFITS subint from a open pyfits file object.
 Applys scales, weights, and offsets to the data.

     Input: fits - open pyfits file object
            i_subint - index of subint (first subint is 0)
            nchan - number of frequency channels
            nsamps - number of time samples per subint
            apply_weights - If True, apply weights. 
                    (Default: apply weights)
            apply_scales - If True, apply scales. 
                    (Default: apply scales)
            apply_offsets - If True, apply offsets. 
                    (Default: apply offsets)
     Output: subint data with scales, weights, and offsets
             applied in float32 dtype with shape (nsamps,nchan).


---

# harmonic_sum.md

### Function `get_frac_harmonic`

Return spectrum values corresponding to harmonic num/denom

Parameters
----------
num : integer or float
    Numerator of the fractional harmonic
denom : integer or float
    Denominator of the fractional harmonic
spectrum : float or double array
    Spectrum that you want to do harmonic summing of

Returns
-------
array of the same type of spectrum
    Selected elements of the spectrum for harmonic num/denom

### Function `harmonic_sum`

Perform a top-down harmonic sum of a spectrum

Parameters
----------
numharm : integer
    Number of harmonics to sum (2, 4, 8, 16, 32, or 64)
spectrum : float or double array
    Spectrum to perform harmonic summing on
partial : float or double array
    partially harmonic sum spectrum, default is None
partialN : int, optional
    Number of harmonics in partial spectrum

Returns
-------
array of same type of the spectrum
    The full harmonic summed spectrum


---

# injectpsr.md

# Module docstring

Inject a fake pulsar into real data, creating
a filterbank file.

Patrick Lazarus, June 26, 2012

## Class `Profile`

A class to represent a generic pulse profile.
    

## Class `MultiComponentProfile`

A class to represent a pulse profile made up of 
multiple components.

## Class `VectorProfile`

A class to represent a vector of pulse profiles.
This can be used to encode intrinsic profile variation, 
or extrisinc smearing/scattering across the band

### Function `get_phasedelays`

Return phase delays corresponding to a particular DM.

Inputs:
    dm: DM (in pc cm-3)
    freqs: The list of frequencies (in MHz)
    period: The profiles period (in seconds)

Outputs:
    phasedelays: The corresponding phase delays.

### Function `apply_dm`

Given a profile apply DM delays, smearing, and scattering 
within each channel as is appropriate for the given params.

Inputs:
    inprof: The profile to modify.
    period: The profiles period (in seconds)
    dm: The DM (in pc cm-3)
    chan_width: The width of each channel (in MHz)
    freqs: The list of frequencies (in MHz)
    tsamp: Sample time of the recipient filterbank file (in seconds).
    do_delay: Boolean, if True apply DM delays to each channel.
        The highest freq channel is not shifted. (Default: True)
    do_smear: Boolean, if True apply DM smearing to each channel.
        (Default: True)
    do_scatter: Boolean, if True apply scattering to each channel.
        (Default: True)

Outputs:
    vecprof: The delayed and smeared VectorProfile.

### Function `get_spline_profile`

Given a profile object evaluate it and return
a SplineProfile object. If the input profile object
is already an instance of SplineProfile, do nothing
and return the input profile.

Inputs:
    prof: The profile object to conver to a SplineProfile.
    npts: The number of points to use when evaluating the
        profile. (Default: 1024)
    **All additional keyword arguments are passed to the 
        spline constructor.

Outputs:
    spline_prof: The resulting SplineProfile object.

### Function `vonmises_factory`

Return a Profile with a single von Mises component.

Inputs:
    amp: Amplitude of the von Mises function.
    shape: A parameter characterising the width 
        (NOTE: this value is not directly the width.)
    loc: Phase of the peak of the von Mises function.

Output:
    vm_prof: A Profile object with a von Mises profile described
        by the input parameters.

### Function `boxcar_factory`

Return a boxcar Profile scaled to have unit area.

Inputs:
    width: The width of the boxcar function in phase.
        NOTE: if width > 1, it will be folded
    delay: The delay, in phase, to apply to the boxcar.
        NOTE: positive delays cause the boxcar to be shifted
        (Default: No delay)
        to the right (i.e. larger pulse phase)

Output:
    boxcar_prof: A boxcar Profile object with the given width.

### Function `exponential_factory`

Return a one-sided exponential Profile.

Inputs:
    efold: The e-folding phase of the exponential function.

Output:
    exp_prof: A one-sided exponential Profile object.

### Function `scale_from_snr`

Set the profile's scaling factor such that the simulated 
injected pulsar signal will have the given Smean.

Inputs:
    fil: A FilterbankFile object.
    prof: The Profile object representing the profile to inject.
    snr: The desired signal-to-noise ratio
    rms: The RMS of the recipient file's DM=0 time series.

Outputs:
    scale: The scaling factor to apply to the profile.

### Function `snr_from_smean`

Set the profile's scaling factor such that the simulated 
injected pulsar signal will have the given Smean.

Inputs:
    fil: A FilterbankFile object.
    prof: The Profile object representing the profile to inject.
    smean: The mean flux density to simulate, in mJy.
    gain: The telescope's gain, in K/Jy.
    tsys: The observing system's temperature, in K.

Outputs:
    snr: The target signal-to-noise ratio.

### Function `get_scaling`

Given a target filterbank file, a profile, and
a configuration string return the corresponding 
scaling factor.

Inputs:
    fil: A filterbank.FilterbankFile object.
    prof: A Profile object.
    cfgstrs: A list of strings containing configurations.

Output:
    scaling: The corresponding scaling.

### Function `get_scaling_from_snr`

Given a target filterbank file, a profile, and
a configuration string compute the scaling factor
given the SNR.

Inputs:
    fil: A filterbank.FilterbankFile object.
    prof: A Profile object.
    cfgstrs: A list of strings containing configurations.

Output:
    scaling: The corresponding scaling.

### Function `get_scaling_from_smean`

Given a target filterbank file, a profile, and
a configuration string compute the scaling factor
given the target mean flux density.

Inputs:
    fil: A filterbank.FilterbankFile object.
    prof: A Profile object.
    cfgstrs: A list of strings containing configurations.

Output:
    scaling: The corresponding scaling.

### Function `get_scaling_from_file`

Given a target filterbank file, a profile, and
a configuration string read scaling factors from
a text file. The file should have one floating point
number per line. There should be as many lines as there
are frequency channels in the filterbank file.

Inputs:
    fil: A filterbank.FilterbankFile object.
    prof: A Profile object.
    cfgstrs: A list of strings containing configurations.

Output:
    scaling: The corresponding scaling.

### Function `scale_profile`

Scale the profile.

Inputs:
    prof: The profile object to scale.
    scale_name: The name of the type of scaler to use.
    scale_cfgstrs: A list of configuration strings for the scaler.
    fil: A FilterbankFile object.
    verbose: Print extra information. (Default: True)

Outputs:
    None - the scalings are applied directly to the input profile.

### Function `make_profile`

Create the profile object to use.

Inputs:
    vonmises: A list of strings defining von mises components.
    verbose: Print extra information. (Default: True)

### Function `parse_model_file`

Parse a pass model file (*.m) written by paas.
Return a list of parameters describing each component.
In particular (amplitude, shape, phase).

Input:
    modelfn: The name of the model file.

Outputs:
    params: List of parameters for each component.
        (i.e. "amplitude shape phase")

### Function `__init__`

Construct a profile.

Inputs:
    prof_func: A function of a single variable.
        This function should:
            1) Represent the pulse profile.
            2) Expect input values of phase ranging between 
                0 and 1.
            3) Work when provided with a numpy array.
    scale: An overall scaling factor to multiply
        the profile by.

Output:
    prof: The profile object.

### Function `__call__`

Return the value of the profile at the given phase.

Inputs:
    phs: The phase of the profile (between 0 and 1) where
        the profile should be evaluated.

Output:
    vals: The values of the profile at the requested phases.

### Function `get_area`

Return the area under the pulse in units of (intensity x phase).
The area is calculated by evaluating the profile at many points
and numerically integrated using the trapezoid rule.

NOTE: the scale-factor will be applied.

Input:
    npts: The number of points to use when evaluating the
        profile.

Ouput:
    area: The area under the pulse in units of (intensity x phase).

### Function `get_max`

Return the maximum value of the profile.
The profile is evaluated at many points. The quantity returned
is the maximum value evaluated.

NOTE: the scale-factor will be applied.

Inputs:
    npts: The number of points to use when evaluating the
        profile.

Ouput:
    profmax: The profile maximum.

### Function `get_fwhm`

Determine and return the FWHM of the profile, in phase.
This only works if two points in the profile are at half-maximum,
and all points in between are larger than half-max.

Input:
    npts: The number of points to use when evaluating the
        profile.

Ouput:
    fwhm: The full-width at half-maximum of the profile, in phase.

### Function `get_equivalent_width`

Determine and return the equivalent width of the profile, in phase.
The equivalent width is the area under the pulse divided
by the profile's maximum value.

Input:
    npts: The number of points to use when evaluating the
        profile.

Ouput:
    weq: The equivalent width of the profile, in phase.

### Function `set_scaling`

Set the profile's scaling factor.

Input:
    scale: The scaling factor to use.

Outputs:
    None

### Function `delay`

Delay the profile and return a new Profile object. 

Input:
    phasedelay: The amount of phase to delay the profile by.

Output:
    delayed: The delayed Profile.

### Function `convolve_with`

Convolve Profile with another. Return a SplineProfile
with the requested number of points.

Inputs:
    other: The Profile to convolve with.
    npts: The number of points to use when creating the
        resulting convolution (i.e. a SplineProfile). 
        (Default: 4096)
    conserve_area: If true, scale the covolution such that
        it has the same area as the input profile (i.e. 'self')

Other:
    convolution: The convolution, a SplineProfile object.

### Function `smear`

Smear the profile with a boxcar of width 'smearphs'. Return
a SplineProfile object sampled with 'npts' points.

Inputs:
    smearphs: The amount (in phase) to smear the profile by.
    delayphs: The amount (in phase) to delay the pulse by.
        (Default: No delay)
    npts: The number of points to use when creating the
        smeared SplineProfile. (Default: 4096)

Output:
    smeared: The smeared Profile.

### Function `scatter`

Scatter the profile with a one-sided exponential of width
'scatterphs'. Return a SplineProfile object sampled
with 'npts' points.

Inputs:
    scatterphs: The time-scale (in phase) of the exponential
        scattering function.
    npts: The number of points to use when creating the scattered
        SplineProfile. (Default: 4096)

Outputs:
    scattered: The scattered Profile.

### Function `__init__`

Construct a profile that uses a spline to interpolate a function.

Inputs:
    profvals: The values of the profile to be interpolated. 
    scale: An overall scaling factor to multiply
        the profile by.
    **All additional keyword arguments are passed to the 
        spline constructor.

Output:
    prof: The profile object.

### Function `__call__`

Return the value of the profile at the given phase.

Inputs:
    phs: The phase of the profile (between 0 and 1) where
        the profile should be evaluated.

Output:
    vals: The values of the profile at the requested phases.

### Function `__init__`

Construct a multi-component profile.

Input:
    components: A list of Profile objects that serve
        as the components of this MultiComponentProfile 
        object. (Default: Create a multi-component profile
        with no components.)
    scale: An overall scaling factor to multiply 
        the profile by.

Output:
    prof: The MultiComponentProfile object.

### Function `_get_profile`

Private method to get the pulse profile vs. phase
function.

### Function `__init__`

Construct a vector of profiles.

Inputs:
    profiles: A list of Profile objects.
    scales: A numpy array of scaling factors to multiply
        the profile vector by when evaluating.

Output:
    prof: The profile object.

### Function `set_scaling`

Set the profiles' scaling factors.

Input:
    scales: The scaling factors to use.

Outputs:
    None

### Function `get_area`

Return the area under the pulse in units of (intensity x phase).
The area is calculated by evaluating the profile at many points
and numerically integrated using the trapezoid rule.

NOTE: the scale-factor will be applied.

Input:
    npts: The number of points to use when evaluating the
        profile.

Ouput:
    area: The area under the pulse in units of (intensity x phase).


---

# kuiper.md

### Function `kuiper_uniform_test`

kuiper_uniform_test(data, output=0):
   Conduct a Kuiper test on the data.  The data must be values
   within [0,1) (e.g. phases from a periodicity search).  They
   will be compared to a uniform distribution.  The return value
   is the probability that the data is uniformly distributed.


---

# make_spd.md

# Module docstring

make_spd.py

Make single pulse plots which include the waterfall plots and dedispersed time series with Zero-DM On/Off.
Also includes Signal-to-noise vs DM and DM vs Time subplots.
Usage on the command line:
python make_spd.py [OPTIONS] <psrfits file> <singlepulse files> 

Chitrang Patel - May. 21, 2015 -- Updated on June 10 2016

### Function `waterfall_array`

Runs the waterfaller. If dedispersing, there will be extra bins added to the 2D plot.
Inputs:
    Inputs required for the waterfaller. dm, nbins, etc. 
Outputs:
   data: 2D array as an "object" 
   array: 2D array ready to be plotted by sp_pgplot.plot_waterfall(array). 

### Function `make_spd_from_file`

Makes spd files from output files of rratrap. 
Inputs:
    spdcand: spcand parameters instance (read in spcand.params)
    rawdatafile: psrfits file instance
    txtfile: rratrap output file (groups.txt file)
    maskfile: rfifind mask file. need this file if you want to remove the bandpass 
              or use rfifind mask information.
    min_rank: plot all groups with rank more than this. min 1, max 6
    group_rank: plot groups ranked whatever you specify
    plot: do you want to produce the plots as well? 
    just_waterfall: Do you just want to make the waterfall plots.
    integrate_ts: Do you want to display the dedispersed time series in the plot?
    integrate_spec: Do you want to display the pulse spectrum in the plot?
    disp_pulse: Do you want to see the inset dispersed pulse in the plot?
    loc_pulse: Fraction of the window length where the pulse is located.(eg. 0.25 = 1/4th of the way in.
                                                                         0.5 = middle of the plot)
    maxnumcands: What is the maximum number of candidates you would like to generate?
    basename: output basename of the file. Appended with _DM_TIME(s)_RANK.spd 
Optional arguments:
    mask: Do you want to mask out rfi contaminated channels?
    bandpass_corr: Do you want to remove the bandpass?
    barytime: Is the given time(s) barycentric?
    man_params: Do you want to specify the parameters for waterfalling 
                manually? If yes, I suggest using the function make_spd_from_man_params().
                (I suggest giving it the rratrap output file)    
Outputs:
   Binary npz file containing the necessary arrays and header information to generate the spd plots.

### Function `make_spd_from_man_params`

Makes spd files from output files of rratrap. 
Inputs:
    spdcand: spcand parameters instance (read in spcand.params)
    rawdatafile: psrfits file instance
    txtfile: rratrap output file (groups.txt file)
    maskfile: rfifind mask file. need this file if you want to remove the bandpass 
              or use rfifind mask information.
    plot: do you want to produce the plots as well? 
    just_waterfall: Do you just want to make the waterfall plots.
    subdm: DM to use when subbanding.
    dm: DM to use when dedispersing data for plot. 
    sweep_dm: Show the frequency sweep using this DM.
    sigma: signal-to-noise of the pulse
    start_time: start time of the data to be read in for waterfalling.
    duration: duration of data to be waterfalled.
    width_bins: Smooth each channel/subband with a boxcar width_bins wide.
    nbins: Number of time bins to plot. This option overrides
            the duration argument. 
    downsamp: Factor to downsample in time by. Default: Don't downsample.
    nsub: Number of subbands to use. Must be a factor of number of channels.
    scaleindep:Do you want to scale each subband independently?(Type: Boolean)
    spec_width: Twice this number times the pulse_width around the pulse to consider for the spectrum
    loc_pulse: Fraction of the window length where the pulse is located.(eg. 0.25 = 1/4th of the way in.
                                                                         0.5 = middle of the plot)
    integrate_ts: Do you want to display the dedispersed time series in the plot?
    integrate_spec: Do you want to display the pulse spectrum in the plot?
    disp_pulse: Do you want to see the inset dispersed pulse in the plot?
    basename: output basename of the file. Appended with _DM_TIME(s)_RANK.spd 
    mask: Do you want to mask out rfi contaminated channels?
    bandpass_corr: Do you want to remove the bandpass?
    barytime: Is the given time(s) barycentric?
    man_params: Do you want to specify the parameters for waterfalling 
                manually? If yes, I suggest using the function make_spd_from_man_params().
                (I suggest giving it the rratrap output file)    
Outputs:
   Binary npz file containing the necessary arrays and header information to generate the spd plots.


---

# monte_sideb.md

### Function `secant`

Summary 
   Solve for a zero of function using Secant method 

Usage 
   real = func(real) 
   real = secant(func, real, real [, TOL=real]) 
   
Similar to Newton's method, but the derivative is estimated by divided
difference using only function calls.  A root is estimated by
x = x - f(x) (x - oldx)/(f(x) - f(oldx))
where oldx = x[i-1] and x = x[i].


---

# mpfit.md

# Module docstring

Perform Levenberg-Marquardt least-squares minimization, based on MINPACK-1.

                                   AUTHORS
  The original version of this software, called LMFIT, was written in FORTRAN
  as part of the MINPACK-1 package by XXX.

  Craig Markwardt converted the FORTRAN code to IDL.  The information for the
  IDL version is:
     Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770
     craigm@lheamail.gsfc.nasa.gov
     UPDATED VERSIONs can be found on my WEB PAGE: 
        http://cow.physics.wisc.edu/~craigm/idl/idl.html

  Mark Rivers created this Python version from Craig's IDL version.
    Mark Rivers, University of Chicago
    Building 434A, Argonne National Laboratory
    9700 South Cass Avenue, Argonne, IL 60439
    rivers@cars.uchicago.edu
    Updated versions can be found at http://cars.uchicago.edu/software


                                 DESCRIPTION

 MPFIT uses the Levenberg-Marquardt technique to solve the
 least-squares problem.  In its typical use, MPFIT will be used to
 fit a user-supplied function (the "model") to user-supplied data
 points (the "data") by adjusting a set of parameters.  MPFIT is
 based upon MINPACK-1 (LMDIF.F) by More' and collaborators.

 For example, a researcher may think that a set of observed data
 points is best modelled with a Gaussian curve.  A Gaussian curve is
 parameterized by its mean, standard deviation and normalization.
 MPFIT will, within certain constraints, find the set of parameters
 which best fits the data.  The fit is "best" in the least-squares
 sense; that is, the sum of the weighted squared differences between
 the model and data is minimized.

 The Levenberg-Marquardt technique is a particular strategy for
 iteratively searching for the best fit.  This particular
 implementation is drawn from MINPACK-1 (see NETLIB), and is much faster
 and more accurate than the version provided in the Scientific Python package
 in Scientific.Functions.LeastSquares.
 This version allows upper and lower bounding constraints to be placed on each
 parameter, or the parameter can be held fixed.

 The user-supplied Python function should return an array of weighted
 deviations between model and data.  In a typical scientific problem
 the residuals should be weighted so that each deviate has a
 gaussian sigma of 1.0.  If X represents values of the independent
 variable, Y represents a measurement for each value of X, and ERR
 represents the error in the measurements, then the deviates could
 be calculated as follows:

   DEVIATES = (Y - F(X)) / ERR

 where F is the analytical function representing the model.  You are
 recommended to use the convenience functions MPFITFUN and
 MPFITEXPR, which are driver functions that calculate the deviates
 for you.  If ERR are the 1-sigma uncertainties in Y, then

   TOTAL( DEVIATES^2 ) 

 will be the total chi-squared value.  MPFIT will minimize the
 chi-square value.  The values of X, Y and ERR are passed through
 MPFIT to the user-supplied function via the FUNCTKW keyword.

 Simple constraints can be placed on parameter values by using the
 PARINFO keyword to MPFIT.  See below for a description of this
 keyword.

 MPFIT does not perform more general optimization tasks.  See TNMIN
 instead.  MPFIT is customized, based on MINPACK-1, to the
 least-squares minimization problem.


                               USER FUNCTION

 The user must define a function which returns the appropriate
 values as specified above.  The function should return the weighted
 deviations between the model and the data.  It should also return a status
 flag and an optional partial derivative array.  For applications which
 use finite-difference derivatives -- the default -- the user
 function should be declared in the following way:

   def myfunct(p, fjac=None, x=None, y=None, err=None)
    # Parameter values are passed in "p"
    # If fjac==None then partial derivatives should not be
    # computed.  It will always be None if MPFIT is called with default
    # flag.
    model = F(x, p)
    # Non-negative status value means MPFIT should continue, negative means
    # stop the calculation.
    status = 0
    return([status, (y-model)/err]

 See below for applications with analytical derivatives.

 The keyword parameters X, Y, and ERR in the example above are
 suggestive but not required.  Any parameters can be passed to
 MYFUNCT by using the functkw keyword to MPFIT.  Use MPFITFUN and
 MPFITEXPR if you need ideas on how to do that.  The function *must*
 accept a parameter list, P.

 In general there are no restrictions on the number of dimensions in
 X, Y or ERR.  However the deviates *must* be returned in a
 one-dimensional numpy array of type float.

 User functions may also indicate a fatal error condition using the
 status return described above. If status is set to a number between
 -15 and -1 then MPFIT will stop the calculation and return to the caller.


                            ANALYTIC DERIVATIVES

 In the search for the best-fit solution, MPFIT by default
 calculates derivatives numerically via a finite difference
 approximation.  The user-supplied function need not calculate the
 derivatives explicitly.  However, if you desire to compute them
 analytically, then the AUTODERIVATIVE=0 keyword must be passed to MPFIT.
 As a practical matter, it is often sufficient and even faster to allow
 MPFIT to calculate the derivatives numerically, and so
 AUTODERIVATIVE=0 is not necessary.

 If AUTODERIVATIVE=0 is used then the user function must check the parameter
 FJAC, and if FJAC!=None then return the partial derivative array in the
 return list.
   def myfunct(p, fjac=None, x=None, y=None, err=None)
    # Parameter values are passed in "p"
    # If FJAC!=None then partial derivatives must be comptuer.
    # FJAC contains an array of len(p), where each entry
    # is 1 if that parameter is free and 0 if it is fixed. 
    model = F(x, p)
    Non-negative status value means MPFIT should continue, negative means
    # stop the calculation.
    status = 0
    if (dojac):
       pderiv = numpy.zeros([len(x), len(p)], numpy.float64)
       for j in range(len(p)):
         pderiv[:,j] = FGRAD(x, p, j)
    else:
       pderiv = None
    return([status, (y-model)/err, pderiv]

 where FGRAD(x, p, i) is a user function which must compute the
 derivative of the model with respect to parameter P[i] at X.  When
 finite differencing is used for computing derivatives (ie, when
 AUTODERIVATIVE=1), or when MPFIT needs only the errors but not the
 derivatives the parameter FJAC=None.  

 Derivatives should be returned in the PDERIV array. PDERIV should be an m x
 n array, where m is the number of data points and n is the number
 of parameters.  dp[i,j] is the derivative at the ith point with
 respect to the jth parameter.  

 The derivatives with respect to fixed parameters are ignored; zero
 is an appropriate value to insert for those derivatives.  Upon
 input to the user function, FJAC is set to a vector with the same
 length as P, with a value of 1 for a parameter which is free, and a
 value of zero for a parameter which is fixed (and hence no
 derivative needs to be calculated).

 If the data is higher than one dimensional, then the *last*
 dimension should be the parameter dimension.  Example: fitting a
 50x50 image, "dp" should be 50x50xNPAR.


           CONSTRAINING PARAMETER VALUES WITH THE PARINFO KEYWORD

 The behavior of MPFIT can be modified with respect to each
 parameter to be fitted.  A parameter value can be fixed; simple
 boundary constraints can be imposed; limitations on the parameter
 changes can be imposed; properties of the automatic derivative can
 be modified; and parameters can be tied to one another.

 These properties are governed by the PARINFO structure, which is
 passed as a keyword parameter to MPFIT.

 PARINFO should be a list of dictionaries, one list entry for each parameter.
 Each parameter is associated with one element of the array, in
 numerical order.  The dictionary can have the following keys
 (none are required, keys are case insensitive):

    'value' - the starting parameter value (but see the START_PARAMS
             parameter for more information).

    'fixed' - a boolean value, whether the parameter is to be held
             fixed or not.  Fixed parameters are not varied by
             MPFIT, but are passed on to MYFUNCT for evaluation.

    'limited' - a two-element boolean array.  If the first/second
               element is set, then the parameter is bounded on the
               lower/upper side.  A parameter can be bounded on both
               sides.  Both LIMITED and LIMITS must be given
               together.

    'limits' - a two-element float array.  Gives the
              parameter limits on the lower and upper sides,
              respectively.  Zero, one or two of these values can be
              set, depending on the values of LIMITED.  Both LIMITED
              and LIMITS must be given together.

    'parname' - a string, giving the name of the parameter.  The
               fitting code of MPFIT does not use this tag in any
               way.  However, the default iterfunct will print the
               parameter name if available.

    'step' - the step size to be used in calculating the numerical
            derivatives.  If set to zero, then the step size is
            computed automatically.  Ignored when AUTODERIVATIVE=0.

    'mpside' - the sidedness of the finite difference when computing
              numerical derivatives.  This field can take four
              values:

                 0 - one-sided derivative computed automatically
                 1 - one-sided derivative (f(x+h) - f(x)  )/h
                -1 - one-sided derivative (f(x)   - f(x-h))/h
                 2 - two-sided derivative (f(x+h) - f(x-h))/(2*h)

             Where H is the STEP parameter described above.  The
             "automatic" one-sided derivative method will chose a
             direction for the finite difference which does not
             violate any constraints.  The other methods do not
             perform this check.  The two-sided method is in
             principle more precise, but requires twice as many
             function evaluations.  Default: 0.

    'mpmaxstep' - the maximum change to be made in the parameter
                 value.  During the fitting process, the parameter
                 will never be changed by more than this value in
                 one iteration.

                 A value of 0 indicates no maximum.  Default: 0.

    'tied' - a string expression which "ties" the parameter to other
            free or fixed parameters.  Any expression involving
            constants and the parameter array P are permitted.
            Example: if parameter 2 is always to be twice parameter
            1 then use the following: parinfo(2).tied = '2 * p(1)'.
            Since they are totally constrained, tied parameters are
            considered to be fixed; no errors are computed for them.
            [ NOTE: the PARNAME can't be used in expressions. ]

    'mpprint' - if set to 1, then the default iterfunct will print the
               parameter value.  If set to 0, the parameter value
               will not be printed.  This tag can be used to
               selectively print only a few parameter values out of
               many.  Default: 1 (all parameters printed)


 Future modifications to the PARINFO structure, if any, will involve
 adding dictionary tags beginning with the two letters "MP".
 Therefore programmers are urged to avoid using tags starting with
 the same letters; otherwise they are free to include their own
 fields within the PARINFO structure, and they will be ignored.

 PARINFO Example:
 parinfo = [{'value':0., 'fixed':0, 'limited':[0,0], 'limits':[0.,0.]}]*5
 parinfo[0]['fixed'] = 1
 parinfo[4]['limited'][0] = 1
 parinfo[4]['limits'][0]  = 50.
 values = [5.7, 2.2, 500., 1.5, 2000.]
 for i in range(5): parinfo[i]['value']=values[i]

 A total of 5 parameters, with starting values of 5.7,
 2.2, 500, 1.5, and 2000 are given.  The first parameter
 is fixed at a value of 5.7, and the last parameter is
 constrained to be above 50.


                                   EXAMPLE

   import mpfit
   import numpy
   x = numpy.arange(100, numpy.float64)
   p0 = [5.7, 2.2, 500., 1.5, 2000.]
   y = ( p[0] + p[1]*[x] + p[2]*[x**2] + p[3]*numpy.sqrt(x) +
         p[4]*numpy.log(x))
   fa = {'x':x, 'y':y, 'err':err}
   m = mpfit('myfunct', p0, functkw=fa)
   print('status = ', m.status)
   if (m.status <= 0): print('error message = ', m.errmsg)
   print('parameters = ', m.params)

   Minimizes sum of squares of MYFUNCT.  MYFUNCT is called with the X,
   Y, and ERR keyword parameters that are given by FUNCTKW.  The
   results can be obtained from the returned object m.


                            THEORY OF OPERATION

   There are many specific strategies for function minimization.  One
   very popular technique is to use function gradient information to
   realize the local structure of the function.  Near a local minimum
   the function value can be taylor expanded about x0 as follows:

      f(x) = f(x0) + f'(x0) . (x-x0) + (1/2) (x-x0) . f''(x0) . (x-x0)
             -----   ---------------   -------------------------------  (1)
     Order    0th          1st                      2nd

   Here f'(x) is the gradient vector of f at x, and f''(x) is the
   Hessian matrix of second derivatives of f at x.  The vector x is
   the set of function parameters, not the measured data vector.  One
   can find the minimum of f, f(xm) using Newton's method, and
   arrives at the following linear equation:

      f''(x0) . (xm-x0) = - f'(x0)                            (2)

   If an inverse can be found for f''(x0) then one can solve for
   (xm-x0), the step vector from the current position x0 to the new
   projected minimum.  Here the problem has been linearized (ie, the
   gradient information is known to first order).  f''(x0) is
   symmetric n x n matrix, and should be positive definite.

   The Levenberg - Marquardt technique is a variation on this theme.
   It adds an additional diagonal term to the equation which may aid the
   convergence properties:

      (f''(x0) + nu I) . (xm-x0) = -f'(x0)                  (2a)

   where I is the identity matrix.  When nu is large, the overall
   matrix is diagonally dominant, and the iterations follow steepest
   descent.  When nu is small, the iterations are quadratically
   convergent.

   In principle, if f''(x0) and f'(x0) are known then xm-x0 can be
   determined.  However the Hessian matrix is often difficult or
   impossible to compute.  The gradient f'(x0) may be easier to
   compute, if even by finite difference techniques.  So-called
   quasi-Newton techniques attempt to successively estimate f''(x0)
   by building up gradient information as the iterations proceed.

   In the least squares problem there are further simplifications
   which assist in solving eqn (2).  The function to be minimized is
   a sum of squares:

       f = Sum(hi^2)                                         (3)

   where hi is the ith residual out of m residuals as described
   above.  This can be substituted back into eqn (2) after computing
   the derivatives:

       f'  = 2 Sum(hi  hi')     
       f'' = 2 Sum(hi' hj') + 2 Sum(hi hi'')                (4)

   If one assumes that the parameters are already close enough to a
   minimum, then one typically finds that the second term in f'' is
   negligible [or, in any case, is too difficult to compute].  Thus,
   equation (2) can be solved, at least approximately, using only
   gradient information.

   In matrix notation, the combination of eqns (2) and (4) becomes:

        hT' . h' . dx = - hT' . h                          (5)

   Where h is the residual vector (length m), hT is its transpose, h'
   is the Jacobian matrix (dimensions n x m), and dx is (xm-x0).  The
   user function supplies the residual vector h, and in some cases h'
   when it is not found by finite differences (see MPFIT_FDJAC2,
   which finds h and hT').  Even if dx is not the best absolute step
   to take, it does provide a good estimate of the best *direction*,
   so often a line minimization will occur along the dx vector
   direction.

   The method of solution employed by MINPACK is to form the Q . R
   factorization of h', where Q is an orthogonal matrix such that QT .
   Q = I, and R is upper right triangular.  Using h' = Q . R and the
   ortogonality of Q, eqn (5) becomes

        (RT . QT) . (Q . R) . dx = - (RT . QT) . h
                     RT . R . dx = - RT . QT . h         (6)
                          R . dx = - QT . h

   where the last statement follows because R is upper triangular.
   Here, R, QT and h are known so this is a matter of solving for dx.
   The routine MPFIT_QRFAC provides the QR factorization of h, with
   pivoting, and MPFIT_QRSOLV provides the solution for dx.


                                 REFERENCES

   MINPACK-1, Jorge More', available from netlib (www.netlib.org).
   "Optimization Software Guide," Jorge More' and Stephen Wright, 
     SIAM, *Frontiers in Applied Mathematics*, Number 14.
   More', Jorge J., "The Levenberg-Marquardt Algorithm:
     Implementation and Theory," in *Numerical Analysis*, ed. Watson,
     G. A., Lecture Notes in Mathematics 630, Springer-Verlag, 1977.


                           MODIFICATION HISTORY

   Translated from MINPACK-1 in FORTRAN, Apr-Jul 1998, CM
 Copyright (C) 1997-2002, Craig Markwardt
 This software is provided as is without any warranty whatsoever.
 Permission to use, copy, modify, and distribute modified or
 unmodified copies is granted, provided this copyright and disclaimer
 are included unchanged.

   Translated from MPFIT (Craig Markwardt's IDL package) to Python,
   August, 2002.  Mark Rivers

### Function `__init__`

Inputs:
  fcn:
     The function to be minimized.  The function should return the weighted
     deviations between the model and the data, as described above.

  xall:
     An array of starting values for each of the parameters of the model.
     The number of parameters should be fewer than the number of measurements.

     This parameter is optional if the parinfo keyword is used (but see
     parinfo).  The parinfo keyword provides a mechanism to fix or constrain
     individual parameters.  

Keywords:

   autoderivative:
      If this is set, derivatives of the function will be computed
      automatically via a finite differencing procedure.  If not set, then
      fcn must provide the (analytical) derivatives.
         Default: set (=1) 
         NOTE: to supply your own analytical derivatives,
               explicitly pass autoderivative=0

   fastnorm:
      Set this keyword to select a faster algorithm to compute sum-of-square
      values internally.  For systems with large numbers of data points, the
      standard algorithm can become prohibitively slow because it cannot be
      vectorized well.  By setting this keyword, MPFIT will run faster, but
      it will be more prone to floating point overflows and underflows.  Thus, setting
      this keyword may sacrifice some stability in the fitting process.
         Default: clear (=0)

   ftol:
      A nonnegative input variable. Termination occurs when both the actual
      and predicted relative reductions in the sum of squares are at most
      ftol (and status is accordingly set to 1 or 3).  Therefore, ftol
      measures the relative error desired in the sum of squares.
         Default: 1E-10

   functkw:
      A dictionary which contains the parameters to be passed to the
      user-supplied function specified by fcn via the standard Python
      keyword dictionary mechanism.  This is the way you can pass additional
      data to your user-supplied function without using global variables.

      Consider the following example:
         if functkw = {'xval':[1.,2.,3.], 'yval':[1.,4.,9.],
                       'errval':[1.,1.,1.] }
      then the user supplied function should be declared like this:
         def myfunct(p, fjac=None, xval=None, yval=None, errval=None):

      Default: {}   No extra parameters are passed to the user-supplied
                    function. 

   gtol:
      A nonnegative input variable. Termination occurs when the cosine of
      the angle between fvec and any column of the jacobian is at most gtol
      in absolute value (and status is accordingly set to 4). Therefore,
      gtol measures the orthogonality desired between the function vector
      and the columns of the jacobian.
         Default: 1e-10

   iterkw:
      The keyword arguments to be passed to iterfunct via the dictionary
      keyword mechanism.  This should be a dictionary and is similar in
      operation to FUNCTKW.
         Default: {}  No arguments are passed.

   iterfunct:
      The name of a function to be called upon each NPRINT iteration of the
      MPFIT routine.  It should be declared in the following way:
         def iterfunct(myfunct, p, iter, fnorm, functkw=None, 
                       parinfo=None, quiet=0, dof=None, [iterkw keywords here])
         # perform custom iteration update

      iterfunct must accept all three keyword parameters (FUNCTKW, PARINFO
      and QUIET). 

      myfunct:  The user-supplied function to be minimized,
      p:        The current set of model parameters
      iter:     The iteration number
      functkw:  The arguments to be passed to myfunct.
      fnorm:    The chi-squared value.
      quiet:    Set when no textual output should be printed.
      dof:      The number of degrees of freedom, normally the number of points
                less the number of free parameters.
      See below for documentation of parinfo.

      In implementation, iterfunct can perform updates to the terminal or
      graphical user interface, to provide feedback while the fit proceeds.
      If the fit is to be stopped for any reason, then iterfunct should return a
      a status value between -15 and -1.  Otherwise it should return None
      (e.g. no return statement) or 0.
      In principle, iterfunct should probably not modify the parameter values,
      because it may interfere with the algorithm's stability.  In practice it
      is allowed.

      Default: an internal routine is used to print the parameter values.

      Set iterfunct=None if there is no user-defined routine and you don't
      want the internal default routine be called.

   maxiter:
      The maximum number of iterations to perform.  If the number is exceeded,
      then the status value is set to 5 and MPFIT returns.
      Default: 200 iterations

   nocovar:
      Set this keyword to prevent the calculation of the covariance matrix
      before returning (see COVAR)
      Default: clear (=0)  The covariance matrix is returned

   nprint:
      The frequency with which iterfunct is called.  A value of 1 indicates
      that iterfunct is called with every iteration, while 2 indicates every
      other iteration, etc.  Note that several Levenberg-Marquardt attempts
      can be made in a single iteration.
      Default value: 1

   parinfo
      Provides a mechanism for more sophisticated constraints to be placed on
      parameter values.  When parinfo is not passed, then it is assumed that
      all parameters are free and unconstrained.  Values in parinfo are never
      modified during a call to MPFIT.

      See description above for the structure of PARINFO.

      Default value: None  All parameters are free and unconstrained.

   quiet:
      Set this keyword when no textual output should be printed by MPFIT

   damp:
      A scalar number, indicating the cut-off value of residuals where
      "damping" will occur.  Residuals with magnitudes greater than this
      number will be replaced by their hyperbolic tangent.  This partially
      mitigates the so-called large residual problem inherent in
      least-squares solvers (as for the test problem CURVI,
      http://www.maxthis.com/curviex.htm).
      A value of 0 indicates no damping.
         Default: 0

      Note: DAMP doesn't work with autoderivative=0

   xtol:
      A nonnegative input variable. Termination occurs when the relative error
      between two consecutive iterates is at most xtol (and status is
      accordingly set to 2 or 3).  Therefore, xtol measures the relative error
      desired in the approximate solution.
      Default: 1E-10

 Outputs:

   Returns an object of type mpfit.  The results are attributes of this class,
   e.g. mpfit.status, mpfit.errmsg, mpfit.params, npfit.niter, mpfit.covar.

   .status
      An integer status code is returned.  All values greater than zero can
      represent success (however .status == 5 may indicate failure to
      converge). It can have one of the following values:

      -16
         A parameter or function value has become infinite or an undefined
         number.  This is usually a consequence of numerical overflow in the
         user's model function, which must be avoided.

      -15 to -1 
         These are error codes that either MYFUNCT or iterfunct may return to
         terminate the fitting process.  Values from -15 to -1 are reserved
         for the user functions and will not clash with MPFIT.

      0  Improper input parameters.

      1  Both actual and predicted relative reductions in the sum of squares
         are at most ftol.

      2  Relative error between two consecutive iterates is at most xtol

      3  Conditions for status = 1 and status = 2 both hold.

      4  The cosine of the angle between fvec and any column of the jacobian
         is at most gtol in absolute value.

      5  The maximum number of iterations has been reached.

      6  ftol is too small. No further reduction in the sum of squares is
         possible.

      7  xtol is too small. No further improvement in the approximate solution
         x is possible.

      8  gtol is too small. fvec is orthogonal to the columns of the jacobian
         to machine precision.

   .fnorm
      The value of the summed squared residuals for the returned parameter
      values.

   .covar
      The covariance matrix for the set of parameters returned by MPFIT.
      The matrix is NxN where N is the number of  parameters.  The square root
      of the diagonal elements gives the formal 1-sigma statistical errors on
      the parameters if errors were treated "properly" in fcn.
      Parameter errors are also returned in .perror.

      To compute the correlation matrix, pcor, use this example:
         cov = mpfit.covar
         pcor = cov * 0.
         for i in range(n):
            for j in range(n):
               pcor[i,j] = cov[i,j]/numpy.sqrt(cov[i,i]*cov[j,j])

      If nocovar is set or MPFIT terminated abnormally, then .covar is set to
      a scalar with value None.

   .errmsg
      A string error or warning message is returned.

   .nfev
      The number of calls to MYFUNCT performed.

   .niter
      The number of iterations completed.

   .perror
      The formal 1-sigma errors in each parameter, computed from the
      covariance matrix.  If a parameter is held fixed, or if it touches a
      boundary, then the error is reported as zero.

      If the fit is unweighted (i.e. no errors were given, or the weights
      were uniformly set to unity), then .perror will probably not represent
      the true parameter uncertainties.  

      *If* you can assume that the true reduced chi-squared value is unity --
      meaning that the fit is implicitly assumed to be of good quality --
      then the estimated parameter uncertainties can be computed by scaling
      .perror by the measured chi-squared value.

         dof = len(x) - len(mpfit.params) # deg of freedom
         # scaled uncertainties
         pcerror = mpfit.perror * numpy.sqrt(mpfit.fnorm / dof)

      


---

# orbellipsefit.md

### Function `parabola_funct`

Generic parabola fitting function.
pars is the array of parameters [p0, p1, p2].
Fit function is y = p2*x**2 + p1*x + p0
x, y_measured and y_err must all be same length

### Function `funct`

Fitting function from Eqn A1 of Freire et al. 2001.
pars[i] is the array of 3 parameters [a_0, a_1, a_2]
Asq_measured is the array of measures accelerations SQUARED
ps is the array of measured pulse periods.

### Function `fitellipse`

Fit an orbit using Eqn A1 of Freire et al. 2001, MNRAS.
Period errors are assumed to be negligible.


---

# parfile.md

### Function `ELL1_check`

ELL1_check(par_file):
    Check the parfile to see if ELL1 can be safely used as the
        binary model.  To work properly, we should have:
        asini/c * ecc**2 << timing precision / sqrt(# TOAs)


---

# plot_spd.md

# Module docstring

plot_spd.py

Generate spd plots either using information from the .spd files that are generated by make_spd.py.
Usage:  plot_spd.py [OPTIONS] <.spd file> <.singlepulse files (optional: 
                                          if not provided, will leave DM vs Time window blank).>

Chitrang Patel - June 10, 2016.

### Function `plot`

Generates spd plots which include the following subplots:
    De-dispersed Zero-DM filtered Waterfall plot
    De-dispersed Waterfall plot
 optional subplots:
    Dispersed Zero-DM filtered Waterfall plot (Inset of the corresponding dedispersed plot).
    Dispersed Waterfall plot ((Inset of the corresponding dedispersed plot).).
    Dedispersed zero-DM filtered time series for the corresponding waterfall plot.
    Dedispersed time series for the corresponding waterfall plot.
    Spectra of the de-dispersed pulse for each of the above waterfalled plots.
    SNR vs DM
    DM vs. Time

 Inputs:
    spdfile: A .spd file.
 Optional Inputs:  
    spec_width: Twice this number times the pulse_width around the pulse to consider for the spectrum
    loc_pulse: Fraction of the window length where the pulse is located.(eg. 0.25 = 1/4th of the way in.
                                                                         0.5 = middle of the plot)
    singlepulsefiles: list of .singlepulse files
    xwin: plot in an xwin window?
    outfile: name of the output file you want.
    just_waterfall: Do you only want to display the waterfall plots?
    integrate_spec: Do you want to show the pulse spectrum?
    integrate_ts: Do you want to show the time series?
    disp_pulse: Do you want to show the inset dispersed pulse?
    tar: Supply the tarball of the singlepulse files instead of individual files.


---

# polycos.md

### Function `create_polycos`

Create polycos object from a parfile.
Inputs:
    parfn: parfile's filename, or a parfile object.
    telescope_id: The TEMPO 1-character telescope identifier.
    center_freq: The observation's center frequencies in MHz.
    start_mjd: MJD on which the polycos should start.
    end_mjd: MJD until the polycos should extend.
    max_hour_angle: The maximum hour angle as expected by tempo.
        (Default: Use default value chosen for given telescope).
    span: Span of each set of polycos in min.
        (Default: 60 min).
    numcoeffs: Number of coefficients to use.
        (Default: 12).
    keep_file: If true do not delete polyco.dat file.
        (Default: delete polyco.dat file).

Output:
    new_polycos: a polycos object.

### Function `phase`

self.phase(mjdi, mjdf):
    Return the predicted pulsar phase at a given integer and frational MJD.

### Function `rotation`

self.rotation(mjdi, mjdf):
    Return the predicted pulsar (fractional) rotation at a 
    given integer and fractional MJD.

### Function `freq`

self.freq(mjdi, mjdf):
    Return the predicted pulsar spin frequency at a given integer and frational MJD.

### Function `select_polyco`

self.select_polyco(mjdi, mjdf):
    Return the polyco number that is valid for the specified time.

### Function `get_phase`

self.get_phase(mjdi, mjdf):
    Return the predicted pulsar phase for the specified time.

### Function `get_rotation`

self.get_rotation(mjdi, mjdf):
    Return the predicted pulsar (fractional) rotation 
    number for the specified time.

### Function `get_freq`

self.get_freq(mjdi, mjdf):
    Return the predicted pulsar spin frquency for the specified time.

### Function `get_phs_and_freq`

self.get_voverc(mjdi, mjdf):
    Return the predicted pulsar phase and spin frquency for the specified time.

### Function `get_voverc`

self.get_voverc(mjdi, mjdf):
    Return the (approximate) topocentric v/c for the specified time.


---

# prepfold.md

### Function `dedisperse`

dedisperse(DM=self.bestdm, interp=False, doppler=False):
    Rotate (internally) the profiles so that they are de-dispersed
        at a dispersion measure of DM.  Use FFT-based interpolation if
        'interp' is non-zero (NOTE: It is off by default!).
        Doppler shift subband frequencies if doppler is non-zero.
        (NOTE: It is off by default. However, if you fold raw data
        for a search candidate (and let it search), prepfold *does*
        doppler correct the frequencies! It does *not* doppler
        correct if you fold with polycos for timing, for instance.)

### Function `freq_offsets`

freq_offsets(p=*bestp*, pd=*bestpd*, pdd=*bestpdd*):
    Return the offsets between given frequencies
    and fold frequencies.

    If p, pd or pdd are None use the best values.

    A 3-tuple is returned.

### Function `DOF_corr`

DOF_corr():
    Return a multiplicative correction for the effective number of
    degrees of freedom in the chi^2 measurement resulting from a
    pulse profile folded by PRESTO's fold() function
    (i.e. prepfold).  This is required because there are
    correlations between the bins caused by the way that prepfold
    folds data (i.e. treating a sample as finite duration and
    smearing it over potenitally several bins in the profile as
    opposed to instantaneous and going into just one profile bin).
    The correction is semi-analytic (thanks to Paul Demorest and
    Walter Brisken) but the values for 'power' and 'factor' have
    been determined from Monte Carlos.  The correction is good to
    a fractional error of less than a few percent as long as
    dt_per_bin is > 0.5 or so (which it usually is for pulsar
    candidates).  There is a very minimal number-of-bins
    dependence, which is apparent when dt_per_bin < 0.7 or so.
    dt_per_bin is the width of a profile bin in samples (a float),
    and so for prepfold is pulse period / nbins / sample time.  Note
    that the sqrt of this factor can be used to 'inflate' the RMS
    of the profile as well, for radiometer eqn flux density estimates,
    for instance.

### Function `use_for_timing`

use_for_timing():
    This method returns True or False depending on whether
    the .pfd file can be used for timing or not.  For this
    to return true, the pulsar had to have been folded with
    a parfile and -no[p/pd]search (this includes -timing), or
    with a p/pdot/pdotdot and a corresponding -no[p/pd]search.
    In other words, if you let prepfold search for the best
    p/pdot/pdotdot, you will get bogus TOAs if you try timing
    with it.

### Function `time_vs_phase`

time_vs_phase(p=*bestp*, pd=*bestpd*, pdd=*bestpdd*):
    Return the 2D time vs. phase profiles shifted so that
        the given period and period derivative are applied.
        Use FFT-based interpolation if 'interp' is non-zero.
        (NOTE: It is off by default as in prepfold!).

### Function `adjust_period`

adjust_period(p=*bestp*, pd=*bestpd*, pdd=*bestpdd*):
    Rotate (internally) the profiles so that they are adjusted to
        the given period and period derivatives.  By default,
        use the 'best' values as determined by prepfold's seaqrch.
        This should orient all of the profiles so that they are
        almost identical to what you see in a prepfold plot which
        used searching.  Use FFT-based interpolation if 'interp'
        is non-zero.  (NOTE: It is off by default, as in prepfold!)

### Function `combine_profs`

combine_profs(self, new_npart, new_nsub):
    Combine intervals and/or subbands together and return a new
        array of profiles.

### Function `kill_intervals`

kill_intervals(intervals):
    Set all the subintervals (internally) from the list of
        subintervals to all zeros, effectively 'killing' them.

### Function `kill_subbands`

kill_subbands(subbands):
    Set all the profiles (internally) from the list of
        subbands to all zeros, effectively 'killing' them.

### Function `plot_sumprof`

plot_sumprof(self, device='/xwin'):
    Plot the dedispersed and summed profile.

### Function `greyscale`

greyscale(array2d, **kwargs):
    Plot a 2D array as a greyscale image using the same scalings
        as in prepfold.

### Function `plot_intervals`

plot_intervals(self, phasebins='All', device='/xwin'):
    Plot the subband-summed profiles vs time.  Restrict
        the bins in the plot to the (low:high) slice defined
        by the phasebins option if it is a tuple (low,high)
        instead of the string 'All'.

### Function `plot_subbands`

plot_subbands(self, phasebins='All', device='/xwin'):
    Plot the interval-summed profiles vs subband.  Restrict
        the bins in the plot to the (low:high) slice defined
        by the phasebins option if it is a tuple (low,high)
        instead of the string 'All'.

### Function `calc_varprof`

calc_varprof(self):
    This function calculates the summed profile variance of the
        current pfd file.  Killed profiles are ignored.

### Function `calc_redchi2`

calc_redchi2(self, prof=None, avg=None, var=None):
    Return the calculated reduced-chi^2 of the current summed profile.

### Function `calc_sigma`

calc_sigma(self):
    Return the calculated sigma (equivalent gaussian sig) of the summed profile.

### Function `plot_chi2_vs_DM`

plot_chi2_vs_DM(self, loDM, hiDM, N=100, interp=0, device='/xwin'):
    Plot (and return) an array showing the reduced-chi^2 versus
        DM (N DMs spanning loDM-hiDM).  Use sinc_interpolation
        if 'interp' is non-zero.

### Function `plot_chi2_vs_sub`

plot_chi2_vs_sub(self, device='/xwin'):
    Plot (and return) an array showing the reduced-chi^2 versus
        the subband number.

### Function `estimate_offsignal_redchi2`

estimate_offsignal_redchi2():
    Estimate the reduced-chi^2 off of the signal based on randomly shifting
        and summing all of the component profiles.

### Function `adjust_fold_frequency`

adjust_fold_frequency(phasebins, profs=None, shiftsubs=False):
    Linearly shift the intervals by phasebins over the course of
        the observation in order to change the apparent folding
        frequency.  Return a 2D array containing the de-dispersed
        profiles as a function of time (i.e. shape = (npart, proflen)),
                        and the reduced chi^2 of the resulting summed profile.
        If profs is not None, then use profs instead of self.profs.
                        If shiftsubs is not False, then actually correct the subbands
                        instead of a 2D projection of them.

### Function `dynamic_spectra`

dynamic_spectra(onbins, combineints=1, combinechans=1,
                calibrate=True, plot=True, device='/xwin'):
    Return (and plot) the dynamic spectrum (DS) resulting
        from the folds in the .pfd assuming that the pulsar
        is 'on' during the bins specified in 'onbins' and
        off elsewhere (ON-OFF).  If calibrate is True, the
        DS will be (ON-OFF)/OFF.  combineints and combinechans
        describe how many adjacent intervals or frequency
        channels will be combined when making the DS.


---

# presto.md

### Function `_swig_add_metaclass`

Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass

## Class `_SwigNonDynamicMeta`

Meta class to enforce nondynamic attributes (no new attributes) for a class


---

# prestoswig.md

### Function `_swig_add_metaclass`

Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass

## Class `_SwigNonDynamicMeta`

Meta class to enforce nondynamic attributes (no new attributes) for a class


---

# psr_utils.md

### Function `span`

span(Min, Max, Number):
    Create a range of 'Num' floats given inclusive 'Min' and 'Max' values.

### Function `distance`

distance(width):
    Return a 'width' x 'width' Num Python array with each
        point set to the geometric distance from the array's center.

### Function `is_power_of_10`

is_power_of_10(n):
    If n is a power of 10, return True.

### Function `choose_N`

choose_N(orig_N):
    Choose a time series length that is larger than
        the input value but that is highly factorable.
        Note that the returned value must be divisible
        by at least the maximum downsample factor * 2.
        Currently, this is 8 * 2 = 16.

### Function `running_avg`

running_avg(arr, navg):
    Return an array of the running average of 'navg' bins from the
    input array 'arr'.

### Function `hist`

hist(data, bins, range=None, laby="Number", **kwargs):
Return and plot a histogram in one variable.
  data  -- a sequence of data points
  bins  -- the number of bins into which the data is to be sorted
  range -- a tuple of two values, specifying the lower and
           the upper end of the interval spanned by the bins.
           Any data point outside this interval will be ignored.
           If no range is given, the smallest and largest
           data values are used to define the interval.
Note:  This command also accepts all the keyword arge of plotbinned().

### Function `KS_test`

KS_test(data, cumdist, output=0):
    Perform a Kolmogorov-Smirnov test on data compared to the
        cumulative-distribution function cumdist.

### Function `weighted_mean`

NAME:
  weighted_mean()

PURPOSE:
  Calculate the weighted mean, error, and optionally standard deviation of
  an input array.  By default error is calculated assuming the weights are
  1/err^2, but if you send calcerr=True this assumption is dropped and the
  error is determined from the weighted scatter.

CALLING SEQUENCE:
 wmean,werr = wmom(arr, weights, inputmean=None, calcerr=False, sdev=False)

INPUTS:
  arr: A numpy array or a sequence that can be converted.
  weights: A set of weights for each elements in array.
OPTIONAL INPUTS:
  inputmean:
      An input mean value, around which the mean is calculated.
  calcerr=False:
      Calculate the weighted error.  By default the error is calculated as
      1/sqrt( weights.sum() ).  If calcerr=True it is calculated as sqrt(
      (w**2 * (arr-mean)**2).sum() )/weights.sum()
  sdev=False:
      If True, also return the weighted standard deviation as a third
      element in the tuple.

OUTPUTS:
  wmean, werr: A tuple of the weighted mean and error. If sdev=True the
     tuple will also contain sdev: wmean,werr,wsdev

REVISION HISTORY:
  Converted from IDL: 2006-10-23. Erin Sheldon, NYU

### Function `MJD_to_JD`

MJD_to_JD(MJD):
   Convert Modified Julian Date (MJD) to Julian Date (JD)

### Function `JD_to_MJD`

JD_to_MJD(JD):
   Convert Julian Date (JD) to Modified Julian Date (MJD)

### Function `MJD_to_Julian_Epoch`

MJD_to_Julian_Epoch(MJD):
   Convert Modified Julian Date (MJD) to Julian Epoch

### Function `Julian_Epoch_to_MJD`

Julian_Epoch_to_MJD(jepoch):
   Convert Julian Epoch to Modified Julian Date (MJD)

### Function `MJD_to_Besselian_Epoch`

MJD_to_Besselian_Epoch(MJD):
   Convert Modified Julian Date (MJD) to Besselian Epoch

### Function `Besselian_Epoch_to_MJD`

Besselian_Epoch_to_MJD(bepoch):
   Convert Besselian Epoch to Modified Julian Date (MJD)

### Function `rad_to_dms`

rad_to_dms(rad):
   Convert radians to degrees, minutes, and seconds of arc.

### Function `dms_to_rad`

dms_to_rad(deg, min, sec):
   Convert degrees, minutes, and seconds of arc to radians.

### Function `dms_to_deg`

dms_to_deg(deg, min, sec):
   Convert degrees, minutes, and seconds of arc to degrees.

### Function `rad_to_hms`

rad_to_hms(rad):
   Convert radians to hours, minutes, and seconds of arc.

### Function `hms_to_rad`

hms_to_rad(hour, min, sec):
   Convert hours, minutes, and seconds of arc to radians

### Function `hms_to_hrs`

hms_to_hrs(hour, min, sec):
   Convert hours, minutes, and seconds of arc to hours.

### Function `coord_to_string`

coord_to_string(h_or_d, m, s):
   Return a formatted string of RA or DEC values as
   'hh:mm:ss.ssss' if RA, or 'dd:mm:ss.ssss' if DEC.

### Function `ra_to_rad`

ra_to_rad(ar_string):
   Given a string containing RA information as
   'hh:mm:ss.ssss', return the equivalent decimal
   radians.

### Function `dec_to_rad`

dec_to_rad(dec_string):
   Given a string containing DEC information as
   'dd:mm:ss.ssss', return the equivalent decimal
   radians.

### Function `delta_m`

delta_m(flux_factor):
    Return the change in magnitudes caused by a change
        in flux of flux_factor.

### Function `flux_factor`

flux_factor(delta_m):
    Return the change in flux caused by a change
        in magnitude of delta_m magnitudes

### Function `distance_modulus_to_distance`

distance_modulus_to_distance(dm, absorption=0.0):
    Return the distance (kpc) given a distance modulus dm and
        an optional absorption.

### Function `distance_to_distance_modulus`

distance_to_distance_modulus(d, absorption=0.0):
    Return the distance modulus given a distance d and
        an optional absorption.

### Function `true_anomaly`

true_anomaly(E, ecc):
    Return the True Anomaly (in radians) given the Eccentric anomaly
        (E in radians) and the eccentricity (ecc)

### Function `mass_funct`

mass_funct(pb, x):
    Return the mass function of an orbit given the following:
        'pb' is the binary period in days.
        'x' is the projected semi-major axis in lt-sec.

### Function `mass_funct2`

mass_funct2(mp, mc, i):
    Return the mass function of an orbit given the following:
        'mp' is the mass of the primary in solar masses.
        'mc' is the mass of the companion in solar masses.
        'i' is the orbital inclination (rad).
    Note:  An 'average' orbit has cos(i) = 0.5, or i = 60 deg

### Function `asini_c`

asini_c(pb, mf):
    Return the orbital projected semi-major axis (lt-sec) given:
        'pb' is the binary period in sec.
        'mf' is the mass function of the orbit.

### Function `TS99_WDmass`

TS99_WDmass(pb, pop="I+II"):
    Return the mass of the predicted WD companion for an MSP-HE WD
        system, with an oprbital period of 'pb' days.  The options
        for the pop parameter are "I", "II", or the default "I+II".
        That is the population of the stars that formed the system
        (i.e. pop II stars are older and more metal poor)
        From Tauris & Savonije, 1999, ApJ.

### Function `ELL1_check`

ELL1_check(A1, E, TRES, NTOA, output=False):
    Check if a binary pulsar to see if ELL1 can be safely used as the
        binary model.  To work properly, we should have:
        asini/c * ecc**2 << timing precision / sqrt(# TOAs)
        or A1 * E**2 << TRES / sqrt(NTOA)

### Function `accel_to_z`

accel_to_z(accel, T, reffreq, harm=1):
    Return the accelsearch 'z' (i.e. number of bins drifted)
        at a reference frequency 'reffreq', for an observation
        of duration 'T' seconds and with acceleration (in m/s/s)
        'accel'.  You can specify the harmonic number in 'harm'.

### Function `z_to_accel`

z_to_accel(z, T, reffreq, harm=1):
    Return the acceleration (in m/s/s) corresponding to the
        accelsearch 'z' (i.e. number of bins drifted) at a
        reference frequency 'reffreq', for an observation
        of duration 'T'. You can specify the harmonic number
        in 'harm'.

### Function `bins_to_accel`

bins_to_accel(z, T, f=[1.0, 1000.0], device="/XWIN"):
    Make a plot showing the acceleration which corresponds
    to a certain number of Fourier bins drifted 'z' during
    an observation of length 'T'.

### Function `pulsar_mass`

pulsar_mass(pb, x, mc, inc):
    Return the pulsar mass (in solar mass units) for a binary
    system with the following characteristics:
        'pb' is the binary period in days.
        'x' is the projected semi-major axis in lt-sec.
        'inc' is the orbital inclination in degrees.
        'mc' is the mass of the companion in solar mass units.

### Function `companion_mass`

companion_mass(pb, x, inc=60.0, mpsr=1.4):
    Return the companion mass (in solar mass units) for a binary
    system with the following characteristics:
        'pb' is the binary period in days.
        'x' is the projected semi-major axis in lt-sec.
        'inc' is the orbital inclination in degrees.
        'mpsr' is the mass of the pulsar in solar mass units.

### Function `companion_mass_limit`

companion_mass_limit(pb, x, mpsr=1.4):
    Return the lower limit (corresponding to i = 90 degrees) of the
    companion mass (in solar mass units) in a binary system with
    the following characteristics:
        'pb' is the binary period in days.
        'x' is the projected semi-major axis in lt-sec.
        'mpsr' is the mass of the pulsar in solar mass units.

### Function `OMDOT`

OMDOT(porb, e, Mp, Mc):
    Return the predicted advance of periaston (deg/yr) given the
    orbital period (days), eccentricity, and pulsar and companion masses.

### Function `GAMMA`

GAMMA(porb, e, Mp, Mc):
    Return the predicted value of relativistic gamma (sec) given the
    orbital period (days), eccentricity, and pulsar and companion masses.

### Function `PBDOT`

PBDOT(porb, e, Mp, Mc):
    Return the predicted orbital period derivative (s/s) given the
    orbital period (d), eccentricity, and pulsar and companion masses.

### Function `OMDOT_to_Mtot`

OMDOT_to_Mtot(OMDOT, porb, e):
    Return the total mass (in solar units) of a system given an advance
    of periastron (OMDOT) in deg/yr.  The orbital period should be in days.

### Function `GAMMA_to_Mc`

GAMMA_to_Mc(gamma, porb, e, Mp):
    Given the relativistic gamma in sec, the orbital period in days,
    the eccentricity and the pulsar mass in solar units, return the
    predicted companion mass.

### Function `shklovskii_effect`

shklovskii_effect(pm, D):
    Return the 'acceleration' due to the transverse Doppler effect
    (i.e. the Shklovskii Effect) given the proper motion (pm) in mas/yr
    and the distance (D) in kpc.  Note:  What is returned is a_pm/C,
    or equivalently, Pdot_pm/P.

### Function `galactic_accel_simple`

galactic_accel_simple(l, b, D, v_o=240.0, R_o = 8.34):
    Return the approximate projected acceleration/c (in s^-1)
    (a_p - a_ssb) dot n / c, where a_p and a_ssb are acceleration
    vectors, and n is the los vector.  This assumes a simple spherically
    symmetric isothermal sphere with v_o = 220 km/s circular velocity
    and R_o = 8 kpc to the center of the sphere from the SSB.  l and
    b are the galactic longitude and latitude (in deg) respectively,
    and D is the distance in kpc.  This is eqn 2.4 of Phinney 1992.
    The default v_o and R_o values are from Reid et al 2014.

### Function `galactic_accel`

galactic_accel(l, b, D, v_o=240.0, R_o = 8.34):
    Return the approximate projected acceleration/c (in s^-1)
    (a_p - a_ssb) dot n / c, where a_p and a_ssb are acceleration
    vectors, and n is the los vector.  This assumes v_o = 220 km/s
    circular velocity and R_o = 8 kpc to the center of Galaxy.  l and
    b are the galactic longitude and latitude (in deg) respectively,
    and D is the distance in kpc.  This is eqn 5 of Nice & Taylor 1995.
    The default v_o and R_o values are from Reid et al 2014.

### Function `gal_z_accel`

gal_z_accel(l, b, D):
    Return the approximate projected acceleration/c (in s^-1)
    (a_p - a_ssb) dot n / c, where a_p and a_ssb are acceleration
    vectors, and n is the los vector, caused by the acceleration
    of the pulsar towards the plane of the galaxy.  l and b are
    the galactic longitude and latitude (in deg) respectively, and D
    is the distance in kpc.  This is eqn 3+4 of Nice & Taylor 1995.

### Function `beam_halfwidth`

beam_halfwidth(obs_freq, dish_diam):
    Return the telescope beam halfwidth in arcmin
        'obs_freq' = the observing frqeuency in MHz
        'dish_diam' = the telescope diameter in m

### Function `limiting_flux_dens`

limiting_flux_dens(Ttot, G, BW, T, P=0.01, W=0.05, polar=2, factor=15.0):
    Return the approximate limiting flux density for a pulsar
    survey in mJy based of the following characteristics:
        'Ttot' = sky + system temperature (K)
        'G' = forward gain of the antenna (K/Jy)
        'BW' = observing bandwidth (MHz)
        'T' = integration time (s)
        'P' = pulsar period (s) (default = 0.01)
        'W' = duty cycle of pulsar (0-1) (default = 0.05)
        'polar' = number of polarizations (default = 2)
        'factor' = normalization factor that take into account
            limiting SNR, hardware limitations etc. (default = 15.0)
    Note:  This is a _very_ approximate calculation.  For a better
        calculation, see Cordes and Chernoff, ApJ, 482, p971, App. A.
    Observatories:
        Parkes Multibeam: Tsys = 21 K, G = 0.735 K/Jy

### Function `dm_info`

dm_info(dm=None, dmstep=1.0, freq=1390.0, numchan=512, chanwidth=0.5):
    Return info about potential DM smearing during an observation.

### Function `best_dm_step`

best_dm_step(maxsmear=0.1, dt=0.00080, dm=0.0, freq=1390.0, numchan=512, chanwidth=0.5):
    Return the required DM step to keep the total smearing below 'maxsmear' (in ms).

### Function `dm_smear_approx`

dm_smear_approx(dm, BW, center_freq):
    Return the smearing in sec caused by a 'dm' over a bandwidth
    of 'BW' MHz centered at 'center_freq' MHz. This is the version
    that assumes that the BW is small compared to center_freq.

### Function `dm_smear`

dm_smear(dm, BW, center_freq):
    Return the smearing in sec caused by a 'dm' over a bandwidth
    of 'BW' MHz centered at 'center_freq' MHz.

### Function `diagonal_DM`

diagonal_DM(dt, chanBW, center_freq):
    Return the so-called "diagonal DM" where the smearing across
    one channel is equal to the sample time.

### Function `pulse_broadening`

pulse_broadening(DM, f_ctr):
    Return the approximate pulse broadening (tau) in ms due to scattering
    based on the rough relation in Cordes' 'Pulsar Observations I' paper.
    'f_ctr' should be in MHz.  The approximate error is 0.65 in log(tau).

### Function `rrat_period`

rrat_period(times, numperiods=20, output=True):
    Try to determine a RRAT pulse period using a brute force
    search when the input times are (real!) single-pulse
    arrival times.  numperiods is the number of integer pulses
    to try between the first two pulses.  If output is True,
    print some diagnostic information

### Function `rrat_period_multiday`

rrat_period_multiday(days_times, numperiods=20, output=True):
    Try to determine a RRAT pulse period using a brute force
    search when the input times are (real!) single-pulse
    arrival times. numperiods is the maximum number of periods
    to try in the smallest interval betweeen pulses.
    If output is True, print some diagnostic information.
    days_times should be a list where each entry is the list
    you would pass to rrat_period for a single day/observation.
    e.g.
    [[times, from, one, day], [times from, another, day], ...]

### Function `guess_DMstep`

guess_DMstep(DM, dt, BW, f_ctr):
    Choose a reasonable DMstep by setting the maximum smearing across the
    'BW' to equal the sampling time 'dt'.

### Function `delay_from_DM`

Return the delay in seconds caused by dispersion, given
a Dispersion Measure (DM) in cm-3 pc, and the emitted
frequency (freq_emitted) of the pulsar in MHz.

### Function `delay_from_foffsets`

Return the delays in phase caused by offsets in
frequency (df), and two frequency derivatives (dfd, dfdd)
at the given times in seconds.

### Function `smear_plot`

smear_plot(dm=[0.0,1000.0], dmstep=1.0, subdmstep=10.0, freq=1390.0,
           numchan=512, numsub=32, chanwidth=0.5, dt=0.000125,
           device='/xwin'):
     Show a plot that displays the expected smearing in ms
     from various effects during a radio pulsar search.

### Function `search_sensitivity`

(periods, S_min) = search_sensitivity(Ttot, G, BW, chan, freq, T, dm,
         ddm, dt, Pmin=0.001, Pmax=1.0, W=0.1, polar=2, factor=15.0, pts=1000):
    Return the approximate limiting flux density for a pulsar
    survey in mJy based of the following characteristics:
        'Ttot' = sky + system temperature (K)
        'G' = forward gain of the antenna (K/Jy)
        'BW' = observing bandwidth (MHz)
        'chan' = number of channels in the filterbank
        'freq' = central observing frequency (MHz)
        'T' = integration time (s)
        'dm' = Dispersion Measure in pc cm^-3
        'ddm' = Dispersion Measure stepsize in pc cm^-3
        'dt' = Sample time for each data point in sec
        'Pmin' = minimum pulsar period (s) (default = 0.001)
        'Pmax' = maximum pulsar period (s) (default = 1.0)
        'W' = duty cycle of pulsar (0-1) (default = 0.1)
        'polar' = number of polarizations (default = 2)
        'factor' = normalization factor that take into account
            limiting SNR, hardware limitations etc. (default = 15.0)
        'pts' = the number of points to calculate
    Note:  This is a _very_ approximate calculation.  For a better
        calculation, see Cordes and Chernoff, ApJ, 482, p971, App. A.
    Observatories:
        Parkes Multibeam: Tsys = 21 K, G = 0.735 K/Jy

### Function `smin_noise`

smin_noise(Ttot, G, BW, dt):
    Return the 1 sigma Gaussian noise level (mJy) for each time
    series bin in a pulsar data simulation.  Default is for a
    sinusoidal pulse (i.e. W = P / 2) with freq << Nyquist freq.
        'Ttot' = sky + system temperature (K)
        'G' = forward gain of the antenna (K/Jy)
        'BW' = observing bandwidth (MHz)
        'dt' = time per time series bin (s)
    Observatories:
        Parkes Multibeam: Tsys = 21 K, G = 0.735 K/Jy

### Function `read_profile`

read_profile(filenm, normalize=0):
    Read a simple ASCII profile with one bin per line
        from the file 'filenm'.  Comments are allowed
        if they begin with '#'.  The profile is pseudo-
        normalized if 'normalize' is true.

### Function `calc_phs`

calc_phs(MJD, refMJD, *args):
    Return the rotational phase (0-1) at MJD (can be an array)
        given a reference MJD and the rotational freq (f0) and
        optional freq derivs (f1...) as ordered in the *args
        list (e.g. [f0, f1, f2, ...]).

### Function `calc_freq`

calc_freq(MJD, refMJD, *args):
    Return the instantaneous frequency at an MJD (can be an array)
        given a reference MJD and the rotational freq (f0) and
        optional freq derivs (f1...) as ordered in the *args
        list (e.g. [f0, f1, f2, ...]).

### Function `calc_t0`

calc_t0(MJD, refMJD, *args):
    Return the closest previous MJD corresponding to phase=0 of the pulse.
        *args are the spin freq (f0) and optional freq derivs (f1...)

### Function `write_princeton_toa`

Princeton Format

columns     item
1-1     Observatory (one-character code) '@' is barycenter
2-2     must be blank
16-24   Observing frequency (MHz)
25-44   TOA (decimal point must be in column 30 or column 31)
45-53   TOA uncertainty (microseconds)
69-78   DM correction (pc cm^-3)

### Function `write_tempo2_toa`

Write Tempo2 format TOAs.
Note that first line of file should be "FORMAT 1"
TOA format is "file freq sat satErr siteID <flags>"

### Function `rotate`

rotate(arr, bins):
    Return an array rotated by 'bins' places to the left

### Function `interp_rotate`

interp_rotate(arr, bins, zoomfact=10):
    Return a sinc-interpolated array rotated by 'bins' places to the left.
        'bins' can be fractional and will be rounded to the closest
        whole-number of interpolated bins.  The resulting vector will
        have the same length as the oiginal.

### Function `fft_rotate`

fft_rotate(arr, bins):
    Return array 'arr' rotated by 'bins' places to the left.  The
        rotation is done in the Fourier domain using the Shift Theorem.
        'bins' can be fractional.  The resulting vector will have
        the same length as the original.

### Function `corr`

corr(profile, template):
    Cross-correlate (using FFTs) a 'profile' and a 'template'.

### Function `autocorr`

autocorr(x):
    Circular normalized auto-correlation of the (real) function x
    using FFTs.  Returns only N/2+1 points as the remaining N/2-1
    points are symmetric (corresponding to negative lags).

### Function `maxphase`

maxphase(profile, template):
    Return the phase offset required to get the 'profile' to best
        match the 'template'.

### Function `linear_interpolate`

linear_interpolate(vector, zoom=10):
    Linearly interpolate 'vector' by a factor of 'zoom'.

### Function `downsample`

downsample(vector, factor):
    Downsample (i.e. co-add consecutive numbers) a short section
        of a vector by an integer factor.

### Function `measure_phase_corr`

measure_phase_corr(profile, template, zoom=10):
    Return the phase offset required to get the 'profile' to best
        match the 'template', each of which has been interpolated
        by a factor of 'zoom'.

### Function `harm_to_sum`

harm_to_sum(fwhm):
    For an MVMD profile returns the optimal number
        of harmonics to sum incoherently

### Function `expcos_profile`

expcos_profile(N, phase, fwhm):
    Return a pulse profile with 'N' bins and an integrated 'flux'
    of 1 unit based on the 'Exponentiated Sinusoid'.
        'N' = the number of points in the profile
        'phase' = the pulse phase (0-1)
        'fwhm' = pulse full width at half-max (0.0 < fwhm <= 0.5)

### Function `read_gaussfitfile`

read_gaussfitfile(gaussfitfile, proflen):
    Read a Gaussian-fit file as created by the output of pygaussfit.py.
        The input parameters are the name of the file and the number of
        bins to include in the resulting template file.  A numpy array
        of that length is returned.

### Function `gaussian_profile`

gaussian_profile(N, phase, fwhm):
    Return a gaussian pulse profile with 'N' bins and
    an integrated 'flux' of 1 unit.
        'N' = the number of points in the profile
        'phase' = the pulse phase (0-1)
        'fwhm' = the gaussian pulses full width at half-max
    Note:  The FWHM of a gaussian is approx 2.35482 sigma

### Function `gauss_profile_params`

gauss_profile_params(profile, output=0):
    Return parameters of a best-fit gaussian to a profile.
    The funtion returns a tuple containg the following values:
       ret[0] = Best-fit gaussian integrated 'flux'.
       ret[1] = Best-fit gaussian FWHM.
       ret[2] = Best-fit gaussian phase (0.0-1.0).
       ret[3] = Baseline (i.e. noise) average value.
       ret[4] = Residuals average value.
       ret[5] = Residuals standard deviation.
    If 'output' is true, the fit will be plotted and
       the return values will be printed.

### Function `twogauss_profile_params`

twogauss_profile_params(profile, output=0):
    Return parameters of a two best-fit gaussians to a profile.
    The function returns a tuple containg the following values:
       ret[0] = Best-fit gaussian integrated 'flux'.
       ret[1] = Best-fit gaussian FWHM.
       ret[2] = Best-fit gaussian phase (0.0-1.0).
       ret[3] = Best-fit gaussian integrated 'flux'.
       ret[4] = Best-fit gaussian FWHM.
       ret[5] = Best-fit gaussian phase (0.0-1.0).
       ret[6] = Baseline (i.e. noise) average value.
       ret[7] = Residuals average value.
       ret[8] = Residuals standard deviation.
    If 'output' is true, the fit will be plotted and
       the return values will be printed.

### Function `estimate_flux_density`

estimate_flux_density(profile, N, dt, Ttot, G, BW, prof_stdev, display=0):
    Return an estimate of the flux density (mJy) of a pulsar.
        'profile' = the pulse profile you are using
        'N' = number of time series bins folded
        'dt' = time per time series bin (s)
        'Ttot' = sky + system temperature (K)
        'G' = forward gain of the antenna (K/Jy)
        'BW' = observing bandwidth (MHz)
        'prof_stdev' = profile standard deviation
        'display' = if set, the gaussian fit plots are shown
    Observatories:
        Parkes Multibeam: Tsys = 21 K, G = 0.735 K/Jy

### Function `max_spike_power`

max_spike_power(FWHM):
    Return the (approx.) ratio of the highest power from a
    triangular spike pulse profile to the power from a
    perfect sinusoidal pulse profile.  In other words, if a
    sine gives you a power of 1, what power does a spike profile
    give you?  Both the spike and the sine are assumed to have
    an area under one full pulse of 1 unit.  Note:  A gaussian
    profile gives almost identical powers as a spike profile
    of the same width.  This expression was determined using
    a least-squares fit (Max abs error ~ 0.016).
        'FWHM' is the full width at half-max of the spike.
            (0.0 < FWHM <= 0.5)

### Function `num_spike_powers`

num_spike_powers(FWHM):
    Return the (approx.) number of powers from a triangular spike
    pulse profile which are greater than one half the power
    perfect sinusoidal pulse profile.  Both the spike and the
    sine are assumed to have an area under one full pulse of 1 unit.
    Note:  A gaussian profile gives almost identical numbers of
    high powers as a spike profile of the same width.  This
    expression was determined using a least-squares fit.
    (Errors get large as FWHM -> 0).
        'FWHM' is the full width at half-max of the spike.
            (0.0 < FWHM <= 0.5)

### Function `incoherent_sum`

incoherent_sum(amps):
    Given a series of complex Fourier amplitudes, return a vector
        showing the accumulated incoherently-summed powers.

### Function `coherent_sum`

coherent_sum(amps):
    Given a series of complex Fourier amplitudes, return a vector
        showing the accumulated coherently-summed powers.

### Function `dft_vector_response`

dft_vector_response(roff, z=0.0, w=0.0, phs=0.0, N=1000):
    Return a complex vector addition of N vectors showing the DFT
        response for a noise-less signal with Fourier frequency
        offset roff, (roff=0 would mean that we are exactly at the
        signal freq), average Fourier f-dot, z, and Fourier 2nd
        deriv, w.  An optional phase in radians can be added.

### Function `prob_power`

prob_power(power):
    Return the probability for noise to exceed a normalized power
    level of 'power' in a power spectrum.

### Function `Ftest`

Ftest(chi2_1, dof_1, chi2_2, dof_2):
    Compute an F-test to see if a model with extra parameters is
    significant compared to a simpler model.  The input values are the
    (non-reduced) chi^2 values and the numbers of DOF for '1' the
    original model and '2' for the new model (with more fit params).
    The probability is computed exactly like Sherpa's F-test routine
    (in Ciao) and is also described in the Wikipedia article on the
    F-test:  http://en.wikipedia.org/wiki/F-test
    The returned value is the probability that the improvement in
    chi2 is due to chance (i.e. a low probability means that the
    new fit is quantitatively better, while a value near 1 means
    that the new model should likely be rejected).

### Function `equivalent_gaussian_sigma`

equivalent_gaussian_sigma(p):
    Return the equivalent gaussian sigma corresponding
        to the cumulative gaussian probability p.  In other
        words, return x, such that Q(x) = p, where Q(x) is the
        cumulative normal distribution.  For very small

### Function `extended_equiv_gaussian_sigma`

extended_equiv_gaussian_sigma(logp):
    Return the equivalent gaussian sigma corresponding
        to the log of the cumulative gaussian probability logp.
        In other words, return x, such that Q(x) = p, where Q(x)
        is the cumulative normal distribution.  This version uses
        the rational approximation from Abramowitz and Stegun,
        eqn 26.2.23.  Using the log(P) as input gives a much
        extended range.

### Function `log_asymtotic_incomplete_gamma`

log_asymtotic_incomplete_gamma(a, z):
    Return the log of the incomplete gamma function in its
        asymtotic limit as z->infty.  This is from Abramowitz
        and Stegun eqn 6.5.32.

### Function `log_asymtotic_gamma`

log_asymtotic_gamma(z):
    Return the log of the gamma function in its asymtotic limit
        as z->infty.  This is from Abramowitz and Stegun eqn 6.1.41.

### Function `prob_sum_powers`

prob_sum_powers(power, nsum):
    Return the probability for noise to exceed 'power' in
    the sum of 'nsum' normalized powers from a power spectrum.

### Function `log_prob_sum_powers`

log_prob_sum_powers(power, nsum):
    Return the log of the probability for noise to exceed
    'power' in the sum of 'nsum' normalized powers from a
    power spectrum.  This version uses allows the use of
    very large powers by using asymtotic expansions from
    Abramowitz and Stegun Chap 6.

### Function `sigma_power`

sigma_power(power):
    Return the approximate equivalent Gaussian sigma for noise
    to exceed a normalized power level given as 'power'
    in a power spectrum.

### Function `sigma_sum_powers`

sigma_sum_powers(power, nsum):
    Return the approximate equivalent Gaussian sigma for noise
    to exceed a sum of 'nsum' normalized powers given by 'power'
    in a power spectrum.

### Function `power_at_sigma`

power_at_sigma(sigma):
    Return the approximate normalized power level that is
    equivalent to a detection of significance 'sigma'.

### Function `powersum_at_sigma`

powersum_at_sigma(sigma, nsum):
    Return the approximate sum of 'nsum' normalized powers that is
    equivalent to a detection of significance 'sigma'.

### Function `cand_sigma`

cand_sigma(N, power):
    Return the sigma of a candidate found in a power
    spectrum of 'N' bins after taking into account the
    number of bins searched.

### Function `fft_max_pulsed_frac`

fft_max_pulsed_frac(N, numphot, sigma=3.0):
    Return the approximate maximum pulsed fraction for a
    sinusoidal signal that _wasn't_ found in a FFT-based
    search.  'N' is the number of bins searched in the FFT.
    'numphot' is the number of photons present in the data.
    And 'sigma' is your confidence (in sigma) that you
    have in expressing this limit.

### Function `p_to_f`

p_to_f(p, pd, pdd=None):
   Convert period, period derivative and period second
   derivative to the equivalent frequency counterparts.
   Will also convert from f to p.

### Function `pferrs`

pferrs(porf, porferr, pdorfd=None, pdorfderr=None):
   Calculate the period or frequency errors and
   the pdot or fdot errors from the opposite one.

### Function `pdot_from_B`

pdot_from_B(p, B):
    Return a pdot (or p, actually) that a pulsar with spin
    period (or pdot) 'p' (in sec) would experience given a
    magnetic field strength 'B' in gauss.

### Function `pdot_from_age`

pdot_from_age(p, age):
    Return the pdot that a pulsar with spin period 'p' (in sec)
    would experience given a characteristic age 'age' (in yrs).

### Function `pdot_from_edot`

pdot_from_edot(p, edot, I=1.0e45):
    Return the pdot that a pulsar with spin period 'p (in sec)
    would experience given an Edot 'edot' (in ergs/s) and a
    moment of inertia I.

### Function `pulsar_age`

pulsar_age(f, fdot, n=3, fo=1e99):
    Return the age of a pulsar (in years) given the spin frequency
    and frequency derivative.  By default, the characteristic age
    is returned (assuming a braking index 'n'=3 and an initial
    spin freqquency fo >> f).  But 'n' and 'fo' can be set.

### Function `pulsar_edot`

pulsar_edot(f, fdot, I=1.0e45):
    Return the pulsar Edot (in erg/s) given the spin frequency and
    frequency derivative. The NS moment of inertia is assumed to be
    I = 1.0e45 g cm^2

### Function `pulsar_B`

pulsar_B(f, fdot):
    Return the estimated pulsar surface magnetic field strength
    (in Gauss) given the spin frequency and frequency derivative.

### Function `pulsar_B_lightcyl`

pulsar_B_lightcyl(f, fdot):
    Return the estimated pulsar magnetic field strength at the
    light cylinder (in Gauss) given the spin frequency and
    frequency derivative.

### Function `psr_info`

psr_info(porf, pdorfd, time=None, input=None, I=1e45):
    Print a list of standard derived pulsar parameters based
    on the period (or frequency) and its first derivative.  The
    routine will automatically assume you are using periods if
    'porf' <= 1.0 and frequencies otherwise.  You can override this
    by setting input='p' or 'f' appropriately.  If time is specified
    (duration of an observation) it will also return the Fourier
    frequency 'r' and Fourier fdot 'z'.  I is the NS moment of inertia.

### Function `doppler`

doppler(freq_observed, voverc):
This routine returns the frequency emitted by a pulsar
(in MHz) given that we observe the pulsar at frequency
freq_observed (MHz) while moving with radial velocity
(in units of v/c) of voverc wrt the pulsar.


---

# psrfits.md

# Module docstring

Collect PSRFITS information, emulating behavior of PRESTO.
Read PSRFITS data.

Patrick Lazarus, May 11, 2010
  Jul 4, 2016  (Scott Ransom added 2-bit reading)
  Mar 25, 2021 (Scott Ransom added 1-bit reading)

### Function `unpack_1bit`

Unpack 1-bit data that has been read in as bytes.

Input:
    data: array of bits packed into an array of bytes.

Output:
    outdata: unpacked array. The size of this array will
        be eight times the size of the input data.

### Function `unpack_2bit`

Unpack 2-bit data that has been read in as bytes.

Input: 
    data: array of unsigned 2-bit ints packed into
        an array of bytes.

Output: 
    outdata: unpacked array. The size of this array will 
        be four times the size of the input data.

### Function `unpack_4bit`

Unpack 4-bit data that has been read in as bytes.

Input: 
    data4bit: array of unsigned 4-bit ints packed into
        an array of bytes.

Output: 
    outdata: unpacked array. The size of this array will 
        be twice the size of the input data.

### Function `DATEOBS_to_MJD`

Convert DATE-OBS string from PSRFITS primary HDU to a MJD.
Returns a 2-tuple:
    (integer part of MJD, fractional part of MJD)

### Function `is_PSRFITS`

Return True if filename appears to be PSRFITS format.
Return False otherwise.

### Function `debug_mode`

Set debugging mode.
If 'mode' is None return current debug mode.

### Function `read_subint`

Read a PSRFITS subint from a open pyfits file object.
 Applys scales, weights, and offsets to the data.

     Inputs: 
        isub: index of subint (first subint is 0)
        apply_weights: If True, apply weights. 
            (Default: apply weights)
        apply_scales: If True, apply scales. 
            (Default: apply scales)
        apply_offsets: If True, apply offsets. 
            (Default: apply offsets)
        apply_zero_off: If True, apply ZERO_OFF
            (Default: apply ZERO_OFF)
        total_intensity: If True, and data have 2+ polns, average them.
            (Default: return just total intensity)

     Output: 
        data: Subint data with scales, weights, and offsets
             applied in float32 dtype with shape (nsamps,(npoln),nchan).

### Function `get_weights`

Return weights for a particular subint.

Inputs:
    isub: index of subint (first subint is 0)

Output:
    weights: Subint weights. (There is one value for each channel)

### Function `get_scales`

Return scales for a particular subint.

Inputs:
    isub: index of subint (first subint is 0)

Output:
    scales: Subint scales. (There is one value for each channel * npoln)

### Function `get_offsets`

Return offsets for a particular subint.

Inputs:
    isub: index of subint (first subint is 0)

Output:
    offsets: Subint offsets. (There is one value for each channel * npoln)

### Function `get_spectra`

Return 2D array of data from PSRFITS file.

Inputs:
    startsamp, Starting sample
    N: number of samples to read

Output:
    data: 2D numpy array

### Function `__str__`

Format spectra_info's information into a easy to
read string and return it.


---

# pygaussfit.md

### Function `gen_gaussians`

gen_gaussians(params, N):
    Return a model of a DC-component + M gaussians
        params is a sequence of 1+M*3 values
            the first value is the DC component.  Each remaining
            group of three represents the gaussians phase (0-1),
            FWHM (0-1), and amplitude (>0.0).
        N is the number of points in the model.

### Function `update_background`

force an update of the background

### Function `ignore`

return True if event should be ignored

### Function `keypress`

on key press event

### Function `press`

on button press event

### Function `release`

on button release event

### Function `update`

draw using newfangled blit or oldfangled draw depending on useblit


---

# pyplotres.md

## Class `Resids`

The Resids object contains the following information
about TEMPO residuals:
    bary_TOA
    bary_freq
    numTOAs
    orbit_phs
    postfit_phs
    postfit_sec
    prefit_phs
    prefit_sec
    uncertainty
    weight

### Function `get_freq_label`

Return frequency label given a lo and hi
frequency pair.

### Function `print_text`

Print lines of text (in a list) in the terminal.

## Class `BadOptionValueError`

Bad value passed to option parser.
    

## Class `EmptyPlotValueError`

Empty plot.
    

### Function `__init__`

Read TEMPO results (resid2.tmp, tempo.lis, timfile and parfiles)
freqbands is a list of frequency pairs to display.

### Function `get_info`

Given a freq_label and index return formatted text
describing the TOA residual.

Assume postfit period for calculating residual in phase,
unless otherwise indicated.

### Function `get_xdata`

Return label describing xaxis and the corresponding
data given keyword 'key'.

### Function `get_ydata`

Return label describing yaxis and the corresponding
data/errors given keyword 'key'.
'postfit' is a boolean argument that determines if
postfit, or prefit data is to be returned.


---

# pypsrcat.md

### Function `add_psr_from_parfile`

Add a pulsar from a parfile to the list of pulsars `psrs`


---

# read_spd.md

## Class `spd`

A class for reading in single pulse files.

A quick description of each item in the class:

 data_zerodm
    A 2D freq-vs-time array around the pulse, not dedispersed (zero-DM'd data)
 data_zerodm_dedisp
    A 2D freq-vs-time array around the pulse, dedispersed (zero-DM'd data)
 data_nozerodm
    A 2D freq-vs-time array around the pulse, not dedispersed (non-zero-DM'd data)
 data_nozerodm_dedisp
    A 2D freq-vs-time array around the pulse, dedispersed (non-zero-DM'd data)
 
 spfiles
    PRESTO single pulse files for the DM-vs-time scatterplot
 dmVt_this_dms
    DM values for this pulse in the DM-vs-time scatterplot
 dmVt_this_times
    Time values for this pulse in the DM-vs-time scatterplot
 dmVt_this_sigmas
    Sigma values (determining point size) for this pulse in the DM-vs-time scatterplot
 dmVt_this_widths
    box car values for this pulse.


 dmsweep_delays
    Delays corresponding to frequencies for drawn-in dispersion sweep
 dmsweep_freqs
    Frequencies corresponding to delays for drawn-in dispersion sweep

 filename
    Name of the observation file that was analyzed     
 telescope
    Which telescope was used
 ra
    Right ascension as hh:mm:ss.s string
 dec
    Declination as dd:mm:ss.s string
 ra_deg
    Right ascension in degrees
 dec_deg
    Declination in degrees
 mjd
    Observation MJD
 total_obs_time
    Total duration of the observation this pulse was found in, in seconds
 rank
    Single pulse sifting rank
 tsamp
    Sampling time of raw data in seconds
 best_dm
    Best determined dispersion measure for this event
 sigma
    Significance of this event
 pulse_peak_sample
    The sample number in the full dedispersed time series at which this event peaked
 pulse_peak_time
    The time in seconds in the full dedispersed time series at which this event peaked
 pulsewidth_bins
    The width of the boxcar filter used to optimally detect this event, in number of bins
 pulsewidth_seconds
    The width of the boxcar filter used to optimally detect this event, in seconds
 nsamp
    The number of original time series samples included in the (possibly downsampled) waterfall plot
 waterfall_duration
    The total duration of the dedispersed waterfall plot
 waterfall_start_time
    The time (in seconds) in the full dedispersed time series at which the waterfall plot begins
 waterfall_tsamp
    Sampling time of the waterfall plot in seconds
 waterfall_nbins
    The number of samples across the dedispersed waterfall plot
 waterfall_nsubs
    The number of frequency bins across the waterfall plot
 waterfall_prededisp_nbins
    The number of samples prior to dedispersing and cutting off the ends of the waterfall plot
 min_freq
    The lowest frequency plotted
 max_freq
    The highest frequency plotted
 sweep_duration
    The total duration of the dispersed pulse across the band
 sweep_start_time
    The time at which to start plotting the dispersed reference line

### Function `ddm_response`

Returns the factor by which the S/N of a pulse of a given width observed
in a particular radio band should decrease given an error in dispersion
measure.

ddm
   Difference from optimal dispersion measure in pc/cm^3
width_ms
   Pulse width in milliseconds
band
   The bottom and top of the observing band in MHz
    (default: the Arecibo Mock band)

### Function `waterfall_time_axis`

Generate a time axis for the waterfall plot in seconds, either beginning
at zero or at the duration into the time series at which the plot actually
begins.

### Function `waterfall_freq_axis`

Generate a frequency axis for the waterfall plot.


---

# residuals.md

### Function `read_residuals`

read_residuals(filename="resid2.tmp"):
    Read a TEMPO1 style binary residuals file and return all the elements
        in a residuals 'class'.  The class instance will have an attribute
        called .numTOAs with the number of TOAs and up to 8 arrays with
        the following (as appropriate):
        .bary_TOA     Barycentric TOA (MJD)
        .uncertainty  TOA uncertainty (seconds)
        .bary_freq    Observing frequency (in barycenter frame)
        .prefit_phs   Prefit residual (pulse phase, from 0 to 1)
        .prefit_sec   Prefit residual (seconds)
        .postfit_phs  Postfit residual (pulse phase, from 0 to 1)
        .postfit_sec  Postfit residual (seconds)
        .orbit_phs    Orbital phase (where applicable)
        .weight       Weight of point in the fit


---

# rfifind.md

### Function `get_bandpass`

get_bandpass():
    This routine returns a 'good' bandpass based on an average
        of the average bandpasses, with the exception of the
        intervals that were recommended for zapping in the mask.

### Function `determine_padvals`

determine_padvals():
    This routines determines padding values to use for each
    channel.


---

# rrattrap.md

# Module docstring

rrattrap.py 

Single pulse sifting code: performs grouping and ranking of single pulses identified by PRESTO's single_pulse_search.py.
Usage:
    python rrattrap.py [OPTIONS] --inffile <.inf file> <.singlepulse files>

Output:
    - groups.txt : a file listing all single pulse groups and their ranking.
    - several colourized DM vs. time single-pulse plots, for different DM ranges, with colours corresponding to group ratings.

Chen Karako May 7, 2014
Updated by Chitrang Patel June 10, 2016.

## Class `SinglePulseGroup`

Define single pulse group
    

### Function `create_groups`

Given a recarray of singlepulses return a list of
SinglePulseGroup objects.

Inputs:
    sps: A recarray of single pulse info.
    min_nearby: Minimum number of nearby single pulse events
        to bother creating a group.
    time_thresh: Time-range within which another event must be found
    dm_thresh: DM-range within which another event must be found
    ignore_obs_end: if non-zero, the time (in seconds) to ignore from 
        the end of the observation. Useful for beams on which zero-DMing 
        was applied and caused artifacts in the sp output at the end of 
        the obs.

    *** NOTE: time_thresh and dm_thresh are used together

Outputs:
    groups: A list of SinglePulseGroup objects.

### Function `grouping_sp_dmt`

Groups SinglePulse objects based on proximity in time, DM. 
Outputs list of Single Pulse Groups.

### Function `grouping_rfi`

Groups together close groups of RFI, and considers as RFI other groups
that are close to RFI.

### Function `grouping_sp_t`

Groups SinglePulse objects based on proximity in time, assuming 
the DM difference is no more than DMDIFF=10.

Inputs:
    groups: A list of SinglePulseGroup objects.

Outputs:
    groups: A list of SinglePulseGroup objects.

### Function `flag_noise`

Flag groups as noise based on group size.
If the number of sp events in a group is < min_group,
this group is marked as noise.

Inputs:
    groups: A list of SinglePulseGroup objects.
    min_group: The minimum group size that a group must have
                in order not to be considered as noise. The
                default min_group is MIN_GROUP.

Outputs:
    None

### Function `flag_rfi`

Flag groups as RFI based on sigma behavior.
Takes as input list of Single Pulse Groups.
The ranks of the groups are updated in-place.

Inputs:
    groups: A list of SinglePulseGroup objects.

Outputs:
    None

### Function `rank_groups`

Rank groups based on their sigma vs. DM behaviour. 
Takes as input list of Single Pulse Groups.
The ranks of the groups are updated in-place.

Inputs:
    groups: A list of SinglePulseGroup objects.

Outputs:
    None

### Function `check_dmspan`

Read in groups and check whether each group's DM span exceeds the threshold.
    

### Function `get_obs_info`

Read in an .inf file to extract observation information.
Return observation RA, Dec, duration, and source name.

### Function `plot_sp_rated_all`

Take in dict of Single Pulse Group lists and 
plot the DM vs. t for all, with the plotted 
colour corresponding to group rank. 
The DM range to plot can also be specified.

### Function `plot_sp_rated_pgplot`

Plot groups according to their ranks. Uses pgplot rather 
than matplotlib for faster, more memory-efficient plotting.

Inputs:
    groups: A list of SinglePulseGroup objects.
    ylow (optional): lower y limit to plot. Default: ylow=0.
    yhigh (optional): higher y limit to plot. Default: yhigh=100.
    xlow (optional): lower x limit to plot. Default: xlow=0.
    xhigh (optional): higher x limit to plot. Default: use inf file
        to find observation duration, or if inf file unavailable,
        use xhigh=120s.

Outputs:
    None; saves a colorized sp plot.

### Function `pop_by_rank`

Remove groups with specified rank from a list of groups.
Removes the groups in place; nothing returned.

Inputs:
    groups: A list of SinglePulseGroup objects.
    rank: The rank of groups to be removed.

Outputs:
    None

### Function `rank_occur`

Return a dict of the number of groups of each rank in the groups list.

Inputs:
    groups: A list of SinglePulseGroup objects.

Outputs:
    rank_occur: A dict of ranks and the number of their occurrences
                in the groups list.

### Function `__init__`

SinglePulseGroup constructor.
Takes as input one single pulse (creates a group of one)
inputs DM,Sigma,Time,Sample,Downfact.

### Function `timeisclose`

Checks whether the overlap in time of self and other is within
time_thresh. Takes as input other, a SinglePulseGroup object,
as well as the optional input time_thresh (in s).

### Function `dmisclose`

Checks whether the DM of self and other is within dm_thresh of one
another. Takes as input other, a SinglePulseGroup object, as well as the optional input dm_thresh (in pc cm-3).

### Function `combine`

combines self and other SinglePulseGroup objects.
takes as input other, a SinglePulseGroup object.
combines in place; nothing returned.


---

# rrattrap_config.md

### Function `use_dmplan`

Sets a factor which multiplies the DMthreshold and time_threshold. The factor is 
the downsampling rate. 
This makes the DM_THRESH and TIME_THRESH depend on the DM instead of having fixed 
values throughout. This helps at higher DMs where the DM step size is > 0.5 pc cm-3. 


---

# sifting.md

### Function `remove_duplicate_candidates`

Remove duplicate candidates. The candlist is modified
**in-place**.

Note: This function is defined to maintain support
    for old code. It simply calls the 
    'remove_duplicate_candidates' method of candlist.

Inputs:
    ** All arguments are passed onto the
    'remove_duplicate_candidates' method of candlist.

Output:
    candlist: The modified candidate list.

### Function `remove_DM_problems`

Remove candidates with DM problems. The candlist is modified
**in-place**.

Note: This function is defined to maintain support
    for old code. It simply calls the 
    'remove_DM_problems' method of candlist.

Inputs:
    ** All arguments are passed onto the
    'remove_DM_problems' method of candlist.

Output:
    candlist: The modified candidate list.

### Function `remove_harmonics`

Remove harmonics. The candlist is modified
**in-place**.

Note: This function is defined to maintain support
    for old code. It simply calls the 
    'remove_harmonics' method of candlist.

Inputs:
    ** All arguments are passed onto the
    'remove_harmonics' method of candlist.

Output:
    candlist: The modified candidate list.

### Function `sigma_to_size`

Given a numpy array of sigma values, return an array
of same size with sizes of markers to plot.

Inputs:
    sigmas: Numpy array of sigma values.

Output:
    sizes: Numpy array of marker sizes.

### Function `read_candidates`

Read in accelsearch candidates from the test ACCEL files.
Return a Candlist object of Candidate instances.

Inputs:
    filenms: A list of files to read candidates from.
    prelim_reject: If True, perform preliminary rejection of
        candidates. (Default: True)
    track: If True, keep track of bad/duplicate candidates.
        (Default: False)

### Function `sift_directory`

Sift candidates in given directory.

Inputs:
    dir: The directory containing candidates to sift.
    outbasenm: The base name of the output files.

Outputs:
    None

### Function `plot_summary`

Produce a plot summarizing the sifiting performed.

Input:
    usefreqs: If True, the horizontal axis will use
        frequency. If False, use period.

Output:
    fig: A matplotlib figure instance.

### Function `plot_rejects`

Produce a plot showing why candidates were rejected by
the sifiting performed.

Input:
    usefreqs: If True, the horizontal axis will use
        frequency. If False, use period.

Output:
    fig: A matplotlib figure instance.

### Function `plot_goodcands`

Produce a plot highlighting good candidates as selected by
the sifiting performed.

Input:
    usefreqs: If True, the horizontal axis will use
        frequency. If False, use period.

Output:
    fig: A matplotlib figure instance.

### Function `reject_longperiod`

Find and remove very long period candidates.
Long period candidates are moved to the 'longperiod' bad-list.

Inputs:
    long_period: The longest allowed period for a 'good' cand.
        (Default: Globally defined limit, "long_period")

Outputs:
    None

### Function `reject_shortperiod`

Find and remove very short period candidates.
Short period candidates are moved to the 'shortperiod' bad-list.

Inputs:
    short_period: The shortest allowed period for a 'good' cand.
        (Default: Globally defined limit, "short_period")

Outputs:
    None

### Function `reject_knownbirds`

Find and remove candidates conincident with known birds.

Inputs:
    known_birds_f: A list of tuples containing bad frequencies
        and widths. The tuples should contain
            (<bad freq (Hz)>, <one-sided width (Hz)>)
        (Default: Globally defined "known_birds_f")
    known_birds_p: A list of tuples containing bad peridocities
        and widths. The tuples should contain
            (<bad freq (ms)>, <one-sided width (ms)>)
        (Default: Globally defined "known_birds_p")

Outputs:
    None

### Function `reject_threshold`

Find and remove candidates that don't pass our threshold.
The conditions for rejection are different for candidates
with a single harmonic, and multiple harmonics.

Inputs:
    sigma_threshold: The threshold for sigma.
        (Default: Globally defined threshold, "sigma_threshold")
    c_pow_threshold: The threshold for coherent power.
        (Default: Globally defined threshold, "c_pow_threshold")

Outputs:
    None

### Function `reject_harmpowcutoff`

Find and remove the candidates where the harmonic with the
highest power is not more than harm_pow_cutoff.

Inputs:
    harm_pow_cutoff: Minimum power for a good harmonic.
        (Default: Globally defined "harm_pow_cutoff")

Outputs:
    None

### Function `reject_rogueharmpow`

Find and remove candidates which are dominated by a single
high-power but high-numbered harmonic.

Inputs:
    None
    
Ouputs:
    None

### Function `default_rejection`

Run all rejection methonds with default arguments.

Inputs:
    None

Outputs:
    None

### Function `remove_duplicate_candidates`

Remove lower-significance 'duplicate' (i.e. same period)
candidates from a list of candidates.  For the highest
significance candidate, include a list of the DMs (and SNRs)
of all the other detections.

Inputs:
    verbosity: Verbosity level. (Default: 1)

Ouputs:
    None

### Function `remove_harmonics`

Remove the candidates that are lower significance harmonics
of other candidates from the candlist.

Inputs:
    verbosity: Verbosity level. (Default: 1)

Ouputs:
    None

### Function `remove_DM_problems`

Remove the candidates where any of the following are true:
1) The number of hits is < numdms
2) The highest S/N candidate occurs below a DM of low_DM_cutoff
3) The minimum difference in DM indices between the hits is > 1

Inputs:
    numdms: The minimum number of hits for a good candidate.
    dmlist: List of DMs.
    low_DM_cutoff: The lowest DM possible for a good candidate.
    verbosity: Verbosity level. (Default: 1)

Ouputs:
    None

### Function `print_cand_summary`

Write a summary of all candidates to file (or stdout).

Input:
    summaryfilenm: Name of file to write to. If None write to stdout.
        (Default: write to stdout).

Outputs:
    None

### Function `write_cand_report`

Write a report of all bad candidates to file (or stdout).

Input:
    reportfilenm: Name of file to write to. If None write to stdout.
        (Default: write to stdout).

Outputs:
    None

### Function `get_numcands`

Get the number of good candidates (i.e. len(self.cands)).

Inputs:
    None

Outputs:
    None

### Function `extend`

Extend Candlist with another. This combines
the candidates, as well as the lists of bad cands.

Inputs:
    other: A second Candlist object to extend from.

Outputs:
    None - the original Candlist object is extended in place.

### Function `to_file`

Write Candlist to file (or stdout).

Input:
    candfilenm: Name of file to write to. If None,
        write to stdout. (Default: write to stdout).

Outputs:
    None


---

# sigproc.md

### Function `dec2radians`

dec2radians(src_dej):
   Convert the SIGPROC-style DDMMSS.SSSS declination to radians

### Function `ra2radians`

ra2radians(src_raj):
   Convert the SIGPROC-style HHMMSS.SSSS right ascension to radians

### Function `read_header`

read_header(infile):
   Read a SIGPROC-style header and return the keys/values in a dictionary,
      as well as the length of the header: (hdrdict, hdrlen)

### Function `samples_per_file`

samples_per_file(infile, hdrdict, hdrlen):
   Given an input SIGPROC-style filterbank file and a header
       dictionary and length (as returned by read_header()),
       return the number of (time-domain) samples in the file.


---

# simple_roots.md

### Function `bisect`

bisect(func, lox, hix, TOL=1e-14, MAXIT=200):
   Try to find a root between 'lox' and 'hix' using a simple
   bisection of the region.  'TOL' is an _absolute_
   tolerance.  'MAXIT' is the maximum number of iterations

### Function `secant`

secant(func, oldx, x, TOL=1e-14):
   Similar to Newton's method, but the derivative is estimated
   by divided difference using only function calls.  A root is
   estimated by x = x - f(x) (x - oldx)/(f(x) - f(oldx))
   where oldx = x[i-1] and x = x[i].

### Function `newton_raphson`

newton_raphson(func, dfunc, lox, hix, TOL):
   Finds the root of |func| which is bracketed by values
   |lox| and |hix| to an accuracy of +/- |TOL|. The algorithm
   used is a safe version of Newton-Raphson (see page 366 of NR in
   C, 2ed). |func| must be a function of one variable whose
   derivative is the function 'dfunc'.


---

# simple_zapbirds.md

### Function `mod_get_baryv`

mod_get_baryv(ra, dec, mjd, T, obs="PK", bary=True):
  Determine the average barycentric velocity towards 'ra', 'dec'
  during an observation from 'obs'.  The RA and DEC are in the
  standard string format (i.e. 'hh:mm:ss.ssss' and 'dd:mm:ss.ssss').
  'T' is in sec and 'mjd' is (of course) in MJD.  The obs variable
  is the standard two character string from TEMPO:  PK, GB, AO, GM, JB, ...
  If bary is true, we will need to back out the topocentric times

### Function `group_infiles`

Find the common basenames of files, and sort each by numerical DM, if present

Parameters
----------
infilenms : list of strings
    These are the input filenames

Returns
-------
sorted list of filenames

### Function `zapfile`

Zap the frequencies and widths in zaplist from fftfile

Parameters
----------
fftfile : file oject
    The .fft file that will be zapped (opened in "rb+" mode)
zaplist : list of tuples
    List of (freq, width)s (in Hz) to zap
info : infodata object
    From the .inf file describing the .fft file


---

# sinc_interp.md

### Function `kaiser_window`

kaiser_window(xs, halfwidth, alpha):
    Return the kaiser window function for the values 'xs' when the
        the half-width of the window should be 'haldwidth' with
        the folloff parameter 'alpha'.  The following values are
        particularly interesting:

        alpha
        -----
        0           Rectangular Window
        5           Similar to Hamming window
        6           Similar to Hanning window
        8.6         Almost identical to the Blackman window 

### Function `hanning_window`

hanning_window(xs, halfwidth):
    Return the Hanning window of halfwidth 'halfwidth' evaluated at
        the values 'xs'.

### Function `hamming_window`

hamming_window(xs, halfwidth):
    Return the Hamming window of halfwidth 'halfwidth' evaluated at
        the values 'xs'.

### Function `blackman_window`

blackman_window(xs, halfwidth):
    Return the Blackman window of halfwidth 'halfwidth' evaluated at
        the values 'xs'.

### Function `rectangular_window`

rectangular_window(xs, halfwidth):
    Return a rectangular window of halfwidth 'halfwidth' evaluated at
        the values 'xs'.

### Function `windowed_sinc_interp`

windowed_sinc_interp(data, newx, halfwidth=None,
                     window='hanning', alpha=6.0):
    Return a single windowed-sinc-interpolated point from the data.

### Function `periodic_interp`

periodic_interp(data, zoomfact, window='hanning', alpha=6.0):
    Return a periodic, windowed, sinc-interpolation of the data which
        is oversampled by a factor of 'zoomfact'.


---

# single_pulse_search.md

### Function `fft_convolve`

fft_convolve(fftd_data, fftd_kern, lo, hi):
    Perform a convolution with the complex floating point vectors
        'fftd_data' and 'fftd_kern'.  The returned vector will start at
        at bin 'lo' (must be an integer), and go up to but not
        include bin 'hi' (also an integer).


---

# sp_pgplot.md

# Module docstring

Routine for easy to use 1-D and 2-D plotting using 'PGPLOT'
      and the Python 'PPGPLOT' package

Written by Scott M. Ransom (ransom@cfa.harvard.edu)
         last revision: 01 Jul 2000

'PGPLOT' was writtten by Tim Pearson <tjp@astro.caltech.edu>,
and can be found at http://astro.caltech.edu/~tjp/pgplot/

'PPGPLOT' was written by Nick Patavalis <npat@ariadne.di.uoa.gr>,
and can be found at http://ariadne.di.uoa.gr/ppgplot/
_or_ an updated version is available in the same directory
where this file was found:  ftp://cfa-ftp.harvard.edu/pub/ransom

### Function `plot_waterfall`

plot2d waterfall plot(z, ...)
    An interface to make various 2D plots using PGPLOT.
        'z' is the 2D Numpy array to be plotted.
    The optional entries are:
        x:         x values                    (default = 0, 1, ...) 
        y:         y values                    (default = 0, 1, ...) 
        title:     graph title                 (default = None)      
        rangex:    range for the x-axis        (default = automatic) 
        rangey:    range for the y-axis        (default = automatic) 
        rangez:    range for the z-axis        (default = automatic) 
        labx:      label for the x-axis        (default = None)      
        laby:      label for the y-axis        (default = None)      
        rangex2:   range for 2nd x-axis        (default = None)      
        rangey2:   range for 2nd y-axis        (default = None)      
        labx2:     label for the 2nd x-axis    (default = None)      
        laby2:     label for the 2nd y-axis    (default = None)      
        logx:      make the 1st x-axis log     (default = 0 (no))
        logy:      make the 1st y-axis log     (default = 0 (no))
        logx2:     make the 2nd x-axis log     (default = 0 (no))
        logy2:     make the 2nd y-axis log     (default = 0 (no))
        image:     color palette for image     (default = 'rainbow') 
        contours:  list of contour values      (default = None)      
        line:      contour line style          (default = 1 (solid)) 
        width:     contour line width          (default = 1 (thin))  
        color:     contour line color          (default = 'white')   
        labels:    color of contour labels     (default = None)      
        labelint:  contour label spacing       (default = 20)        
        labelmin:  min contour label spacing   (default = 20)        
        font:      PGPLOT font to use          (default = 1 (normal))
        fontsize:  PGPLOT font size to use     (default = 1.0 (normal))
        id:        show ID line on plot        (default = 0 (no))    
        noscale:   turn off auto scaling       (default = 0 (no))    
        aspect:    Aspect ratio                (default = 1 (square))
        ticks:     Ticks point in or out       (default = 'out')   
        panels:    Number of subpanels [r,c]   (default = [1,1])
        device:    PGPLOT device to use        (default = '')   
    Note:  Many default values are defined in global variables
        with names like ppgplot_font_ or ppgplot_device_.

### Function `dm_time_plot`

Plot DM vs Time subplot for the spd plots.
Input: 
    dms: list of dms of single pulse events to be plotted.
    times: list of times of single pulse events to be plotted.
    sigmas: list of sigmas of single pulse events to be plotted.
    dm_arr: array of dms of the main single pulse group (plotted in black).
    sigma_arr: array of sigmas of the main single pulse group (plotted in black).
    time_arr: array of times of single pulse group (plotted in black).
    Total_observed_time: float : Total observation time 
    xwin: True or False. Use xwin or vcps window.

### Function `setpalette`

setpalette(self, palette):
    Set the color palette for imag-style routines


---

# spcand.md

## Class `params`

A class for input parameters for the spd plots.

### Function `read_from_file`

Set up parameters based on input from the groups.txt file.
Input: params: list of parameters (DM, S/N, Time, Sample number, downfactor)
       tsamp: sampling time (downsampled: 65.5 us for PALFA)
       N    : The total number of time samples in the observation
       lofreq: lowest observation frequency
       hifreq: highest observation frequency
       rawdatafile: supply a PSRFITS file instance
optional arguments:
       dedisp: Do you want to dedisperse?(Type: Boolean).
       scaleindep:Do you want to scale each subband independently?(Type: Boolean)
       zerodm:Do you want to use zero-DM filtering?(Type: Boolean)
       mask: Do you want to use a rfifind mask? (Type: Boolean)
       barytime: Is the given time(s) barycentric?
       bandpass_corr:Would you like to remove the bandpass? (Type: Boolean)

### Function `manual_params`

Set up parameters based on input from the groups.txt file.
Input:
       subdm: DM to use when subbanding.
       dm: DM to use when dedispersing data for plot. 
       sweep_dm: Show the frequency sweep using this DM.
       sigma: signal-to-noise of the pulse
       start_time: start time of the data to be read in for waterfalling.
       width_bins: Smooth each channel/subband with a boxcar width_bins wide.
       downsamp: Factor to downsample in time by. Default: Don't downsample.
       duration: duration of data to be waterfalled.
       nbins: Number of time bins to plot. This option overrides
               the duration argument. 
       nsub: Number of subbands to use. Must be a factor of number of channels.
       tsamp: sampling time (downsampled: 65.5 us for PALFA)
       N: total number of samples in an observations
       lofreq: lowest observation frequency
       hifreq: highest observation frequency
       rawdatafile: supply a psrfits file instance
optional arguments:
       dedisp: Do you want to dedisperse?(Type: Boolean).
       scaleindep:Do you want to scale each subband independently?(Type: Boolean)
       zerodm:Do you want to use zero-DM filtering?(Type: Boolean)
       mask: Do you want to use a rfifind mask? (Type: Boolean)
       barytime: Is the given time(s) barycentric?
       bandpass_corr:Would you like to remove the bandpass? (Type: Boolean)


---

# spectra.md

## Class `Spectra`

A class to store spectra. This is mainly to provide
reusable functionality.

### Function `__init__`

Spectra constructor.

Inputs:
    freqs: Observing frequencies for each channel.
    dt: Sample time (in seconds).
    data: A 2D numpy array containing pulsar data.
            Axis 0 should contain channels. (e.g. data[0,:])
            Axis 1 should contain spectra. (e.g. data[:,0])
    starttime: Start time (in seconds) of the spectra
            with respect to the start of the observation.
            (Default: 0).
    dm: Dispersion measure (in pc/cm^3). (Default: 0)

Output:
    spectra_obj: Spectrum object.

### Function `shift_channels`

Shift each channel to the left by the corresponding 
value in bins, an array.

Inputs:
    bins: An array containing the number of bins
        to shift each channel by.
    padval: Value to use when shifting near the edge
        of a channel. This can be a numeric value,
        'median', 'mean', or 'rotate'. 
        
        The values 'median' and 'mean' refer to the 
        median and mean of the channel. The value 
        'rotate' takes values from one end of the 
        channel and shifts them to the other.

Outputs:
    None

*** Shifting happens in-place ***

### Function `subband`

Reduce the number of channels to 'nsub' by subbanding.
The channels within a subband are combined using the
DM 'subdm'. 'padval' is passed to the call to
'Spectra.shift_channels'.

Inputs:
    nsub: Number of subbands. Must be a factor of 
        the number of channels.
    subdm: The DM with which to combine channels within
        each subband (Default: don't shift channels 
        within each subband)
    padval: The padding value to use when shifting
        channels during dedispersion. See documentation
        of Spectra.shift_channels. (Default: 0)

Outputs:
    None

*** Subbanding happens in-place ***

### Function `scaled`

Return a scaled version of the Spectra object.
When scaling subtract the median from each channel,
and divide by global std deviation (if indep==False), or
divide by std deviation of each row (if indep==True).

Input:
    indep: Boolean. If True, scale each row
        independantly (Default: False).

Output:
    scaled_spectra: A scaled version of the
        Spectra object.

### Function `scaled2`

Return a scaled version of the Spectra object.
When scaling subtract the min from each channel,
and divide by global max (if indep==False), or
divide by max of each row (if indep==True).

Input:
    indep: Boolean. If True, scale each row
        independantly (Default: False).

Output:
    scaled_spectra: A scaled version of the
        Spectra object.

### Function `masked`

Replace masked data with 'maskval'. Returns
a masked copy of the Spectra object.

Inputs:
    mask: An array of boolean values of the same size and shape
        as self.data. True represents an entry to be masked.
    maskval: Value to use when masking. This can be a numeric
        value, 'median', 'mean', or 'median-mid80'.

        The values 'median' and 'mean' refer to the median and
        mean of the channel, respectively. The value 'median-mid80'
        refers to the median of the channel after the top and bottom
        10% of the sorted channel is removed.
        (Default: 'median-mid80')

Output:
    maskedspec: A masked version of the Spectra object.

### Function `dedisperse`

Shift channels according to the delays predicted by
the given DM.

Inputs:
    dm: The DM (in pc/cm^3) to use.
    padval: The padding value to use when shifting
        channels during dedispersion. See documentation
        of Spectra.shift_channels. (Default: 0)

Outputs:
    None

*** Dedispersion happens in place ***

### Function `smooth`

Smooth each channel by convolving with a top hat
of given width. The height of the top had is
chosen shuch that RMS=1 after smoothing. 
Overlap values are determined by 'padval'.

Inputs:
    width: Number of bins to smooth by (Default: no smoothing)
    padval: Padding value to use. Possible values are
        float-value, 'mean', 'median', 'wrap'.
        (Default: 0).

Ouputs:
    None

This bit of code is taken from Scott Ransom's
PRESTO's single_pulse_search.py (line ~ 423).

*** Smoothing is done in place. ***

### Function `trim`

Trim the end of the data by 'bins' spectra.

Input:
    bins: Number of spectra to trim off the end of the observation.
        If bins is negative trim spectra off the beginning of the
        observation.

Outputs:
    None

*** Trimming is irreversible ***

### Function `downsample`

Downsample (in-place) the spectra by co-adding
'factor' adjacent bins.

Inputs:
    factor: Reduce the number of spectra by this
        factor. Must be a factor of the number of
        spectra if 'trim' is False.
    trim: Trim off excess bins.

Ouputs:
    None

*** Downsampling is done in place ***


---

# spio.md

### Function `get_textfile`

Read in the groups.txt file.
Contains information about the DM, time, box car width, signal to noise, sample number and rank    of groups. 
Input: name of the text file.
Output: Array of strings in the file line by line.

### Function `group_info`

Extracts out relevant information from the groups.txt file as strings. 
Input: integer:rank of the groups to read.
       string :name of the text file to read from.
Output: 
       list of single pulse parameters as strings.

### Function `split_parameters`

Splits the string into individual parameters and converts them into floats/int. 
Input: integer:rank of the groups to read.
       string :name of the text file to read from.
Output: 
       list of single pulse parameters as floats and integers.

### Function `read_RRATrap_info`

Generates DM, time, signal-to-noise and pulse width arrays for all the single pulse events
that belong to this group.
Inputs:
    groups.txt file.
    list of line numbers in the file that read something like : Rank:             6.000000
    rank of the group according to the RRATrap classification.
Outputs:
    dm_list, dm_arr : DMs of the single pulse events in this group
    time_list : Times of the single pulse events in this group 
    sigma_arr : signal-to-noise of the single pulse events in this group 
    width_arr : box car widths of the single pulse events in this group 

### Function `old_read_sp_files`

*** OLD VERSION ***
Read all *.singlepulse files in the current directory.
Return 5 arrays (properties of all single pulses):
        DM, sigma, time, sample, downfact.

### Function `read_sp_files`

Read all *.singlepulse files in the current directory in a DM range.
Return 5 arrays (properties of all single pulses):
        DM, sigma, time, sample, downfact.

### Function `read_tarfile`

Read in the .singlepulse.tgz file instead of individual .singlepulse files.
Return an array of (properties of all single pulses):
      DM, sigma, time, sample, downfact. 
Input: filenames: names of all the singlepulse files.
       names: subset of filenames. Names of the singlepulse files to be 
       plotted in DM vs time.
       tar: tar file (.singlepulse.tgz).

### Function `pick_DM_for_singlepulse_files`

Extract DM values from filenames from .singlepulse files.
Input: string : .singlepulse file mane 
Output: float: DM value of that file.

### Function `gen_arrays`

Extract dms, times and signal to noise from each singlepulse file as 1D arrays.
Input: 
       dm: The dm array of the main pulse. Used to decide the DM range in the DM vs time plot and pick out singlepulse files with those DMs.
       threshold: Min signal to noise of the single pulse event that is plotted.
       sp_files: all the .singlepulse file names.
       tar: Instead of the providing individual singlepulse files, you can provide the .singlepulse.tgz tarball.
Output:
       Arrays: dms, times, sigmas of the singlepulse events and an array of dm_vs_times file names.
       
Options: Either a tarball of singlepulse files or individual singlepulse files can be supplied.
         Faster when individual singlepulse files are supplied.   

### Function `read_spd`

Reads in all the .spd and the .singlepulse.tgz info that can reproduce the sp plots.
Inputs: spd_file: .spd file
        .singlepulse.tgz: if not supplied, it will only output .spd info. 
                          Default: not supplied. 
Output: An object that has all the relevant information to remake the plot. 


---

# stacksearch.md

## Class `fftfile`

A PRESTO FFT file (i.e. with suffix '.fft') and associated metadata

## Class `stack`

A PRESTO stack of FFT power spectra, normalized as chi^2/2

## Class `candidate`

An individual stack candidate.

## Class `stackcands`

Candidates from a stack search of power spectra.

### Function `__init__`

Initialize a PRESTO fftfile class instance.

Parameters
----------
ff : file or str or Path
    The PRESTO .fft file to open

### Function `powers`

The powers for the FFT amplitudes.

### Function `phases`

The phases (in degrees) for the FFT amplitudes.

### Function `freqs`

The frequencies (in Hz) for the FFT amplitudes.

### Function `rednoise_normalize`

Normalize the power spectrum while removing rednoise. Based on PRESTO's method
of rednoise removal, in which a logarithmically increasing window is used at low
frequencies to compute the local median. The median value to divide for each
frequency bin is identified by a linear fit between adjacent local medians.

Parameters
----------
b0: int
    The size of the first window to normalize the power spectrum. Default = 50

bmax: int
    The maximum size of the largest window to normalize the power spectrum. Default = 10000

get_medians: bool
    Whether to get the medians out of the rednoise normalization process. Default = False

Returns
-------
normalized_power_spectrum: np.ndarray
    An ndarray of the normalized power spectrum with rednoise removed

### Function `__init__`

Initialize a PRESTO FFT power spectra stack class instance.

Parameters
----------
ffts : list of file or str or Path
    The PRESTO .fft files to open and add to the stack

### Function `add_to_stack`

Add a PRESTO FFT to a power spectrum stack class instance.

Parameters
----------
ff : file or str or Path
    The PRESTO .fft file to open and add to the stack
detrended : bool
    Whether the FFT has already been detrended or not (default is False)
blocklen : int
    The block length for linear detrending of the powers (if detrending is needed)

### Function `expected_stack_stats`

The mean, median, and stdev expected in the stack or hstack from chi^2 stats

Parameters
----------
hstack : boolean
    Use hstack (if True) or stack (if False)

### Function `get_stats`

Return the mean, median, and standard deviation of the stack or hstack

Parameters
----------
lobin : int
    The lowest frequency bin to include in the stats (useful for avoiding rednoise)
hstack : boolean
    Use hstack (if True) or stack (if False)

### Function `show_stats`

Show the stats of the stack or hstack as compared to what is expected

Parameters
----------
lobin : int
    The lowest frequency bin to include in the stats (useful for avoiding rednoise)

### Function `sum_next_harmonics`

Generate a stack with summed harmonics based on the next power of two

### Function `power_threshold_from_sigma`

Return the threshold power required for the harmonic stack to exceed sigma

### Function `search_hstack`

Return a sorted array of the hstack indices exceeding pthresh (most->least significant)

Parameters
----------
pthresh : float
    The summed power threshold required to return a candidate
        (usually set by using the power_threshold_from_sigma() method)
lobin : int
    The lowest bin to search for significant signals

### Function `calc_freqs`

Return the harmonic-adjusted (i.e. fundamental) frequencies (Hz) for the bins

Parameters
----------
bins : np.ndarray
    An array of indices in the hstack to compute fundamental frequencies for

### Function `__init__`

Initialize a stackcands class which will contain a list of stack cands.

Parameters
----------
stack : stack
    The stack class instance for the search.
indices : np.ndarray
    The Fourier indices which were selected.
powers : np.ndarray
    The corresponding stack powers for the candidate indices.

### Function `add_candidates`

Add more candidates to the current stack candidates list.

Parameters
----------
stack : stack
    The stack class instance for the search.
indices : np.ndarray
    The Fourier indices which were selected.
powers : np.ndarray
    The corresponding stack powers for the candidate indices.

### Function `remove_related_cands`

Remove duplicate or harmonically related candidates (less significant but same bin)

### Function `output_candidates`

Write text-formatted stack candidates to stdout or to a file.

Parameters
----------
outfile : string, optional
    Output file name, by default None
maxncands : int, optional
    Max number of candidates to output, by default 100


---

# subband_smearing.md

### Function `subband_smear`

subband_smear(DM, subDM, subBW, fctr):
    Return the smearing in ms caused by subbanding at DM='DM' given
    subbands of bandwidth 'subBW' (MHz) at DM='subDM'.  All values
    are computed at the frequency fctr in MHz.

### Function `chan_smear`

chan_smear(DM, chanDM, chanBW, fctr):
    Return the smearing in ms caused by a finite channels at DM='DM'
    given channels of bandwidth 'chanBW' (MHz) at DM='chanDM'.  All
    values are computed at the frequency fctr in MHz.

### Function `orig_smear`

orig_smear(DM, nchan, chanDM, BW, fctr, dt):
    Return the total smearing in ms due to the sampling rate,
    and the smearing over each channel.

### Function `total_smear`

total_smear(DM, nchan, chanDM, nsub, subDM,
            BW, fctr, dt, downsamp):
    Return the total smearing in ms due to the original channel
    format and the properties of the subbands.


---

# sum_profiles.md

### Function `measure_phase`

measure_phase(profile, template):
    Call FFTFIT on the profile and template to determine the
        following parameters: shift,eshift,snr,esnr,b,errb,ngood
        (returned as a tuple).  These are defined as in Taylor's
        talk at the Royal Society.

### Function `parse_vals`

parse_vals(valstring):
   Return a list of integers that corresponds to each of the numbers
      in a string representation where '-' gives an inclusive range
      and ',' separates individual values or ranges.  For example:

      > parse_vals('5,8,10-13,17')

      would return:  [5, 8, 10, 11, 12, 13, 17]


---

# tim2dat.md

### Function `write_inf_file`

Write a PRESTO .inf file given a .dat file and
a dictionary of SIGPROC-style header values.

Inputs:
    datfn: The PRESTO .dat file to write a .inf file for.
    hdr: A dictionary of SIGPROC header values, as produced
        by PRESTO's sigproc.read_header.
    hdrlen: Length (in bytes) of SIGPROC file's header.

Output:
    inffn: The corresponding .inf file that is created.

### Function `convert_tim_to_dat`

Convert a SIGPROC time series .tim file to a
PRESTO .dat time series

Input:
    tim: The SIGPROC .tim time series file to convert.

Output:
    datfn: The PRESTO .dat time series file


---

# waterfaller.md

# Module docstring

waterfaller.py

Make waterfall plots to show frequency sweep of a single pulse.
Reads PSRFITS or SIGPROC filterbank format files.

Patrick Lazarus - Aug. 19, 2011
Paul Scholz - Nov 2015

### Function `get_mask`

Return an array of boolean values to act as a mask
for a Spectra object.

Inputs:
    rfimask: An rfifind.rfifind object
    startsamp: Starting sample
    N: number of samples to read

Output:
    mask: 2D numpy array of boolean values. 
        True represents an element that should be masked.

### Function `waterfall`

Create a waterfall plot (i.e. dynamic specrum) from a raw data file.
Inputs:
   rawdatafile - a PsrfitsData instance.
   start - start time of the data to be read in for waterfalling.
   duration - duration of data to be waterfalled.
Optional Inputs:
   dm - DM to use when dedispersing data.
         Default: Don't de-disperse
   nbins - Number of time bins to plot. This option overrides
            the duration argument. 
            Default: determine nbins from duration.
   nsub - Number of subbands to use. Must be a factor of number of channels.
           Default: Number of channels.
   subdm - DM to use when subbanding. Default: same as dm argument.
   zerodm - subtract mean of each time-sample from data before 
             de-dispersing.
   downsamp - Factor to downsample in time by. Default: Don't downsample.
   scaleindep - Scale each channel independently.
                 Default: Scale using global maximum.
   width_bins - Smooth each channel/subband with a boxcar width_bins wide.
                 Default: Don't smooth.
   maskfn - Filename of RFIFIND mask to use for masking data.
             Default: Don't mask data.
   bandpass_corr - Correct for the bandpass. Requires an rfifind
                    mask provided by maskfn keyword argument.
                    Default: Do not remove bandpass.
   ref_freq - Reference frequency to de-disperse to. 
               If subbanding and de-dispersing the start time 
               will be corrected to account for change in
               reference frequency. 
               Default: Frequency of top channel.
Outputs:
   data - Spectra instance of waterfalled data cube.
   nbinsextra - number of time bins read in from raw data. 
   nbins - number of bins in duration.
   start - corrected start time. 

### Function `plot_waterfall`

I want a docstring too!
    


---

# weights_to_ignorechan.md

### Function `read_weights`

reat_weights(filename):
    Read the channels and weights from a .weights text file.

### Function `build_chanline`

build_chanline(weights):
    Build an ignorechans line from a .weights file written by hand or rfifind.py
        The ignorechans line can be used to ignore channels with prepdata, prepfold, 
        prepsubband, rfifind, and mpiprepsubband.

### Function `build_pazline`

build_pazline(chanline):
    Build a command line for paz from an ignorechan line
