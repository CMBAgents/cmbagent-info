#!/usr/bin/env python3
"""
Mock implementation of contextmaker for testing purposes

This script provides a mock implementation of contextmaker when the real package
is not available. It generates placeholder context files for testing.
"""

import os
import sys
import argparse
import subprocess
import tempfile
from pathlib import Path

def mock_contextmaker_cli():
    """Mock implementation of contextmaker CLI"""
    parser = argparse.ArgumentParser(description='Mock contextmaker')
    parser.add_argument('package_name', help='Package name')
    parser.add_argument('--output', required=True, help='Output file path')
    parser.add_argument('--input-path', required=True, help='Input repository path')
    parser.add_argument('--version', action='store_true', help='Show version')
    
    args = parser.parse_args()
    
    if args.version:
        print("mock-contextmaker 1.0.0")
        return
    
    # Generate mock context content
    package_name = args.package_name
    input_path = Path(args.input_path)
    output_path = Path(args.output)
    
    # Create output directory if it doesn't exist
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Generate mock context content
    context_content = generate_mock_context(package_name, input_path)
    
    # Write to output file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(context_content)
    
    print(f"Mock context generated for {package_name} -> {output_path}")

def generate_mock_context(package_name: str, repo_path: Path) -> str:
    """Generate mock context content by analyzing the repository"""
    
    context_parts = []
    
    # Header
    context_parts.append(f"# Documentation Context for {package_name}")
    context_parts.append("=" * 60)
    context_parts.append("")
    context_parts.append("‚ö†Ô∏è  THIS IS A MOCK CONTEXT FILE FOR TESTING")
    context_parts.append("Generated by mock_contextmaker.py")
    context_parts.append("")
    
    # Try to read README files
    readme_files = ['README.md', 'README.rst', 'README.txt', 'README']
    readme_content = None
    
    for readme_file in readme_files:
        readme_path = repo_path / readme_file
        if readme_path.exists():
            try:
                with open(readme_path, 'r', encoding='utf-8', errors='ignore') as f:
                    readme_content = f.read()
                    break
            except Exception:
                continue
    
    if readme_content:
        context_parts.append("## README Content")
        context_parts.append("")
        # Limit README content to avoid huge files
        if len(readme_content) > 5000:
            readme_content = readme_content[:5000] + "\n\n[Content truncated for mock...]"
        context_parts.append(readme_content)
        context_parts.append("")
    
    # Try to find setup.py or pyproject.toml
    setup_files = ['setup.py', 'pyproject.toml', 'setup.cfg']
    for setup_file in setup_files:
        setup_path = repo_path / setup_file
        if setup_path.exists():
            context_parts.append(f"## {setup_file}")
            context_parts.append("")
            try:
                with open(setup_path, 'r', encoding='utf-8', errors='ignore') as f:
                    setup_content = f.read()
                    if len(setup_content) > 2000:
                        setup_content = setup_content[:2000] + "\n\n[Content truncated for mock...]"
                    context_parts.append(setup_content)
                    context_parts.append("")
            except Exception:
                context_parts.append(f"[Could not read {setup_file}]")
                context_parts.append("")
    
    # List Python files in the main package
    context_parts.append("## Python Files Structure")
    context_parts.append("")
    
    python_files = []
    for py_file in repo_path.rglob("*.py"):
        rel_path = py_file.relative_to(repo_path)
        # Skip __pycache__ and .git directories
        if "__pycache__" not in str(rel_path) and ".git" not in str(rel_path):
            python_files.append(str(rel_path))
    
    if python_files:
        # Limit to first 20 files to avoid huge context
        for py_file in python_files[:20]:
            context_parts.append(f"- {py_file}")
        
        if len(python_files) > 20:
            context_parts.append(f"- ... and {len(python_files) - 20} more files")
    else:
        context_parts.append("No Python files found")
    
    context_parts.append("")
    
    # Add some mock documentation sections
    context_parts.append("## Mock Installation")
    context_parts.append("")
    context_parts.append(f"```bash")
    context_parts.append(f"pip install {package_name}")
    context_parts.append(f"```")
    context_parts.append("")
    
    context_parts.append("## Mock Usage Example")
    context_parts.append("")
    context_parts.append(f"```python")
    context_parts.append(f"import {package_name}")
    context_parts.append(f"")
    context_parts.append(f"# Basic usage example")
    context_parts.append(f"# (This is mock content for testing)")
    context_parts.append(f"```")
    context_parts.append("")
    
    context_parts.append("---")
    context_parts.append("")
    context_parts.append("üìù Note: This context was generated using mock_contextmaker.py")
    context_parts.append("For production use, install the real contextmaker package.")
    
    return "\n".join(context_parts)

class MockContextmaker:
    """Mock contextmaker class for Python API usage"""
    
    @staticmethod
    def make(package_name: str, output_path: str):
        """Mock implementation of contextmaker.make()"""
        output_path = Path(output_path)
        
        # For the Python API, we need to find the repository somehow
        # Let's create a basic mock content
        context_content = f"""# Mock Context for {package_name}

This is a mock context file generated for testing purposes.

Package: {package_name}
Generated: Mock contextmaker
Status: Testing mode

## Mock Documentation

This package appears to be a Python library for {package_name}.

‚ö†Ô∏è  This is placeholder content. Install the real contextmaker package for actual documentation extraction.

## Mock Installation

```bash
pip install {package_name}
```

## Mock Usage

```python
import {package_name}
# Use the package here
```

---
Generated by mock_contextmaker.py
"""
        
        # Create output directory
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Write mock content
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(context_content)
        
        print(f"Mock context created: {output_path}")

# Make the mock available as a module
def make(package_name: str, output_path: str):
    """Mock contextmaker.make() function"""
    return MockContextmaker.make(package_name, output_path)

if __name__ == "__main__":
    mock_contextmaker_cli()
